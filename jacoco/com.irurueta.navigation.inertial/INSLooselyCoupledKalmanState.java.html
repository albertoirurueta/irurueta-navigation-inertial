<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>INSLooselyCoupledKalmanState.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-navigation-inertial</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.navigation.inertial</a> &gt; <span class="el_source">INSLooselyCoupledKalmanState.java</span></div><h1>INSLooselyCoupledKalmanState.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2019 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.navigation.inertial;

import com.irurueta.algebra.AlgebraException;
import com.irurueta.algebra.Matrix;
import com.irurueta.algebra.SingularValueDecomposer;
import com.irurueta.geometry.InhomogeneousPoint3D;
import com.irurueta.geometry.InvalidRotationMatrixException;
import com.irurueta.geometry.Point3D;
import com.irurueta.geometry.Rotation3D;
import com.irurueta.navigation.frames.CoordinateTransformation;
import com.irurueta.navigation.frames.ECEFFrame;
import com.irurueta.navigation.frames.ECEFPosition;
import com.irurueta.navigation.frames.ECEFVelocity;
import com.irurueta.navigation.frames.FrameType;
import com.irurueta.navigation.frames.InvalidSourceAndDestinationFrameTypeException;
import com.irurueta.navigation.gnss.ECEFPositionAndVelocity;
import com.irurueta.units.*;

import java.io.Serial;
import java.io.Serializable;
import java.util.Objects;

/**
 * Kalman filter state for loosely coupled INS/GNSS extended kalman filter.
 */
public class INSLooselyCoupledKalmanState implements Serializable, Cloneable {

    /**
     * Number of parameters of the Kalman filter.
     */
    public static final int NUM_PARAMS = 15;

    /**
     * Serialization version. This is used to ensure compatibility of deserialization of permanently stored serialized
     * instances.
     */
    @Serial
    private static final long serialVersionUID = 0L;

    /**
     * Estimated body to ECEF coordinate transformation matrix.
     */
    private Matrix bodyToEcefCoordinateTransformationMatrix;

    /**
     * Estimated ECEF user velocity resolved around x axis and expressed in meters per second (m/s).
     */
    private double vx;

    /**
     * Estimated ECEF user velocity resolved around y axis and expressed in meters per second (m/s).
     */
    private double vy;

    /**
     * Estimated ECEF user velocity resolved around z axis and expressed in meters per second (m/s).
     */
    private double vz;

    /**
     * X coordinate of estimated ECEF user position expressed in meters (m).
     */
    private double x;

    /**
     * Y coordinate of estimated ECEF user position expressed in meters (m).
     */
    private double y;

    /**
     * Z coordinate of estimated ECEF user position expressed in meters (m).
     */
    private double z;

    /**
     * Estimated accelerometer bias resolved around x axis and expressed in
     * meters per squared second (m/s^2).
     */
    private double accelerationBiasX;

    /**
     * Estimated accelerometer bias resolved around y axis and expressed in
     * meters per squared second (m/s^2).
     */
    private double accelerationBiasY;

    /**
     * Estimated accelerometer bias resolved around z axis and expressed in
     * meters per squared second (m/s^2).
     */
    private double accelerationBiasZ;

    /**
     * Estimated gyroscope bias resolved around x axis and expressed in
     * radians per second (rad/s).
     */
    private double gyroBiasX;

    /**
     * Estimated gyroscope bias resolved around y axis and expressed in
     * radians per second (rad/s).
     */
    private double gyroBiasY;

    /**
     * Estimated gyroscope bias resolved around z axis and expressed in
     * radians per second (rad/s).
     */
    private double gyroBiasZ;

    /**
     * Estimated Kalman filter error covariance matrix.
     * Notice that covariance is expressed in terms of ECEF coordinates.
     * If accuracy of position, attitude or velocity needs to be expressed in terms
     * of NED coordinates, their respective sub-matrices of this covariance matrix
     * must be rotated, taking into account the Jacobian of the matrix transformation
     * relating both coordinates, the covariance can be expressed following the law
     * of propagation of uncertainties
     * &lt;a href=&quot;https://en.wikipedia.org/wiki/Propagation_of_uncertainty&quot;&gt;(https://en.wikipedia.org/wiki/Propagation_of_uncertainty)&lt;/a&gt;
     * as: cov(f(x)) = J*cov(x)*J'.
     */
    private Matrix covariance;

    /**
     * Constructor.
     */
<span class="fc" id="L142">    public INSLooselyCoupledKalmanState() {</span>
<span class="fc" id="L143">    }</span>

    /**
     * Constructor.
     *
     * @param bodyToEcefCoordinateTransformationMatrix estimated body to ECEF coordinate transformation matrix.
     * @param vx                                       estimated ECEF user velocity resolved around x axis and
     *                                                 expressed in meters per second (m/s).
     * @param vy                                       estimated ECEF user velocity resolved around y axis and
     *                                                 expressed in meters per second (m/s).
     * @param vz                                       estimated ECEF user velocity resolved around z axis and
     *                                                 expressed in meters per second (m/s).
     * @param x                                        x coordinate of estimated ECEF user position expressed
     *                                                 in meters (m).
     * @param y                                        y coordinate of estimated ECEF user position expressed
     *                                                 in meters (m).
     * @param z                                        z coordinate of estimated ECEF user position expressed
     *                                                 in meters (m).
     * @param accelerationBiasX                        estimated accelerometer bias resolved around x axis and
     *                                                 expressed in meters per squared second (m/s^2).
     * @param accelerationBiasY                        estimated accelerometer bias resolved around y axis and
     *                                                 expressed in meters per squared second (m/s^2).
     * @param accelerationBiasZ                        estimated accelerometer bias resolved around z axis and
     *                                                 expressed in meters per squared second (m/s^2).
     * @param gyroBiasX                                estimated gyroscope bias resolved around x axis and
     *                                                 expressed in radians per second (rad/s).
     * @param gyroBiasY                                estimated gyroscope bias resolved around y axis and
     *                                                 expressed in radians per second (rad/s).
     * @param gyroBiasZ                                estimated gyroscope bias resolved around z axis and
     *                                                 expressed in radians per second (rad/s).
     * @param covariance                               estimated Kalman filter error covariance matrix.
     * @throws IllegalArgumentException if provided body to ECEF coordinate transformation matrix is not 3x3
     *                                  or if provided covariance matrix is not 15x15.
     */
    public INSLooselyCoupledKalmanState(
            final Matrix bodyToEcefCoordinateTransformationMatrix, final double vx, final double vy, final double vz,
            final double x, final double y, final double z,
            final double accelerationBiasX, final double accelerationBiasY, final double accelerationBiasZ,
<span class="fc" id="L181">            final double gyroBiasX, final double gyroBiasY, final double gyroBiasZ, final Matrix covariance) {</span>
<span class="fc" id="L182">        setBodyToEcefCoordinateTransformationMatrix(bodyToEcefCoordinateTransformationMatrix);</span>
<span class="fc" id="L183">        setVelocityCoordinates(vx, vy, vz);</span>
<span class="fc" id="L184">        setPositionCoordinates(x, y, z);</span>
<span class="fc" id="L185">        setAccelerationBiasCoordinates(accelerationBiasX, accelerationBiasY, accelerationBiasZ);</span>
<span class="fc" id="L186">        setGyroBiasCoordinates(gyroBiasX, gyroBiasY, gyroBiasZ);</span>
<span class="fc" id="L187">        setCovariance(covariance);</span>
<span class="fc" id="L188">    }</span>

    /**
     * Constructor.
     *
     * @param c                 body to ECEF coordinate transformation.
     * @param vx                estimated ECEF user velocity resolved around x axis.
     * @param vy                estimated ECEF user velocity resolved around y axis.
     * @param vz                estimated ECEF user velocity resolved around z axis.
     * @param x                 x coordinate of estimated ECEF user position.
     * @param y                 y coordinate of estimated ECEF user position.
     * @param z                 z coordinate of estimated ECEF user position.
     * @param accelerationBiasX estimated accelerometer bias resolved around x axis and
     *                          expressed in meters per squared second (m/s^2).
     * @param accelerationBiasY estimated accelerometer bias resolved around y axis and
     *                          expressed in meters per squared second (m/s^2).
     * @param accelerationBiasZ estimated accelerometer bias resolved around z axis and
     *                          expressed in meters per squared second (m/s^2).
     * @param gyroBiasX         estimated gyroscope bias resolved around x axis and
     *                          expressed in radians per second (rad/s).
     * @param gyroBiasY         estimated gyroscope bias resolved around y axis and
     *                          expressed in radians per second (rad/s).
     * @param gyroBiasZ         estimated gyroscope bias resolved around z axis and
     *                          expressed in radians per second (rad/s).
     * @param covariance        estimated Kalman filter error covariance matrix.
     * @throws IllegalArgumentException if provided covariance matrix is not 15x15.
     */
    public INSLooselyCoupledKalmanState(
            final CoordinateTransformation c, final Speed vx, final Speed vy, final Speed vz,
            final Distance x, final Distance y, final Distance z,
            final double accelerationBiasX, final double accelerationBiasY, final double accelerationBiasZ,
<span class="fc" id="L219">            final double gyroBiasX, final double gyroBiasY, final double gyroBiasZ, final Matrix covariance) {</span>
<span class="fc" id="L220">        setC(c);</span>
<span class="fc" id="L221">        setVelocityCoordinates(vx, vy, vz);</span>
<span class="fc" id="L222">        setPositionCoordinates(x, y, z);</span>
<span class="fc" id="L223">        setAccelerationBiasCoordinates(accelerationBiasX, accelerationBiasY, accelerationBiasZ);</span>
<span class="fc" id="L224">        setGyroBiasCoordinates(gyroBiasX, gyroBiasY, gyroBiasZ);</span>
<span class="fc" id="L225">        setCovariance(covariance);</span>
<span class="fc" id="L226">    }</span>

    /**
     * Constructor.
     *
     * @param c                 body to ECEF coordinate transformation.
     * @param vx                estimated ECEF user velocity resolved around x axis.
     * @param vy                estimated ECEF user velocity resolved around y axis.
     * @param vz                estimated ECEF user velocity resolved around z axis.
     * @param position          estimated ECEF user position.
     * @param accelerationBiasX estimated accelerometer bias resolved around x axis and
     *                          expressed in meters per squared second (m/s^2).
     * @param accelerationBiasY estimated accelerometer bias resolved around y axis and
     *                          expressed in meters per squared second (m/s^2).
     * @param accelerationBiasZ estimated accelerometer bias resolved around z axis and
     *                          expressed in meters per squared second (m/s^2).
     * @param gyroBiasX         estimated gyroscope bias resolved around x axis and
     *                          expressed in radians per second (rad/s).
     * @param gyroBiasY         estimated gyroscope bias resolved around y axis and
     *                          expressed in radians per second (rad/s).
     * @param gyroBiasZ         estimated gyroscope bias resolved around z axis and
     *                          expressed in radians per second (rad/s).
     * @param covariance        estimated Kalman filter error covariance matrix.
     * @throws IllegalArgumentException if provided covariance matrix is not 15x15.
     */
    public INSLooselyCoupledKalmanState(
            final CoordinateTransformation c, final Speed vx, final Speed vy, final Speed vz, final Point3D position,
            final double accelerationBiasX, final double accelerationBiasY, final double accelerationBiasZ,
<span class="fc" id="L254">            final double gyroBiasX, final double gyroBiasY, final double gyroBiasZ, final Matrix covariance) {</span>
<span class="fc" id="L255">        setC(c);</span>
<span class="fc" id="L256">        setVelocityCoordinates(vx, vy, vz);</span>
<span class="fc" id="L257">        setPosition(position);</span>
<span class="fc" id="L258">        setAccelerationBiasCoordinates(accelerationBiasX, accelerationBiasY, accelerationBiasZ);</span>
<span class="fc" id="L259">        setGyroBiasCoordinates(gyroBiasX, gyroBiasY, gyroBiasZ);</span>
<span class="fc" id="L260">        setCovariance(covariance);</span>
<span class="fc" id="L261">    }</span>

    /**
     * Constructor.
     *
     * @param c                 body to ECEF coordinate transformation.
     * @param velocity          estimated ECEF user velocity.
     * @param position          estimated ECEF user position.
     * @param accelerationBiasX estimated accelerometer bias resolved around x axis and
     *                          expressed in meters per squared second (m/s^2).
     * @param accelerationBiasY estimated accelerometer bias resolved around y axis and
     *                          expressed in meters per squared second (m/s^2).
     * @param accelerationBiasZ estimated accelerometer bias resolved around z axis and
     *                          expressed in meters per squared second (m/s^2).
     * @param gyroBiasX         estimated gyroscope bias resolved around x axis and
     *                          expressed in radians per second (rad/s).
     * @param gyroBiasY         estimated gyroscope bias resolved around y axis and
     *                          expressed in radians per second (rad/s).
     * @param gyroBiasZ         estimated gyroscope bias resolved around z axis and
     *                          expressed in radians per second (rad/s).
     * @param covariance        estimated Kalman filter error covariance matrix.
     * @throws IllegalArgumentException if provided covariance matrix is not 15x15.
     */
    public INSLooselyCoupledKalmanState(
            final CoordinateTransformation c, final ECEFVelocity velocity, final ECEFPosition position,
            final double accelerationBiasX, final double accelerationBiasY, final double accelerationBiasZ,
<span class="fc" id="L287">            final double gyroBiasX, final double gyroBiasY, final double gyroBiasZ, final Matrix covariance) {</span>
<span class="fc" id="L288">        setC(c);</span>
<span class="fc" id="L289">        setEcefVelocity(velocity);</span>
<span class="fc" id="L290">        setEcefPosition(position);</span>
<span class="fc" id="L291">        setAccelerationBiasCoordinates(accelerationBiasX, accelerationBiasY, accelerationBiasZ);</span>
<span class="fc" id="L292">        setGyroBiasCoordinates(gyroBiasX, gyroBiasY, gyroBiasZ);</span>
<span class="fc" id="L293">        setCovariance(covariance);</span>
<span class="fc" id="L294">    }</span>

    /**
     * Constructor.
     *
     * @param c                   body to ECEF coordinate transformation.
     * @param positionAndVelocity estimated ECEF user velocity and position.
     * @param accelerationBiasX   estimated accelerometer bias resolved around x axis and
     *                            expressed in meters per squared second (m/s^2).
     * @param accelerationBiasY   estimated accelerometer bias resolved around y axis and
     *                            expressed in meters per squared second (m/s^2).
     * @param accelerationBiasZ   estimated accelerometer bias resolved around z axis and
     *                            expressed in meters per squared second (m/s^2).
     * @param gyroBiasX           estimated gyroscope bias resolved around x axis and
     *                            expressed in radians per second (rad/s).
     * @param gyroBiasY           estimated gyroscope bias resolved around y axis and
     *                            expressed in radians per second (rad/s).
     * @param gyroBiasZ           estimated gyroscope bias resolved around z axis and
     *                            expressed in radians per second (rad/s).
     * @param covariance          estimated Kalman filter error covariance matrix.
     * @throws IllegalArgumentException if provided covariance matrix is not 15x15.
     */
    public INSLooselyCoupledKalmanState(
            final CoordinateTransformation c, final ECEFPositionAndVelocity positionAndVelocity,
            final double accelerationBiasX, final double accelerationBiasY, final double accelerationBiasZ,
<span class="fc" id="L319">            final double gyroBiasX, final double gyroBiasY, final double gyroBiasZ, final Matrix covariance) {</span>
<span class="fc" id="L320">        setC(c);</span>
<span class="fc" id="L321">        setPositionAndVelocity(positionAndVelocity);</span>
<span class="fc" id="L322">        setAccelerationBiasCoordinates(accelerationBiasX, accelerationBiasY, accelerationBiasZ);</span>
<span class="fc" id="L323">        setGyroBiasCoordinates(gyroBiasX, gyroBiasY, gyroBiasZ);</span>
<span class="fc" id="L324">        setCovariance(covariance);</span>
<span class="fc" id="L325">    }</span>

    /**
     * Constructor.
     *
     * @param frame             estimated user ECEF frame.
     * @param accelerationBiasX estimated accelerometer bias resolved around x axis and
     *                          expressed in meters per squared second (m/s^2).
     * @param accelerationBiasY estimated accelerometer bias resolved around y axis and
     *                          expressed in meters per squared second (m/s^2).
     * @param accelerationBiasZ estimated accelerometer bias resolved around z axis and
     *                          expressed in meters per squared second (m/s^2).
     * @param gyroBiasX         estimated gyroscope bias resolved around x axis and
     *                          expressed in radians per second (rad/s).
     * @param gyroBiasY         estimated gyroscope bias resolved around y axis and
     *                          expressed in radians per second (rad/s).
     * @param gyroBiasZ         estimated gyroscope bias resolved around z axis and
     *                          expressed in radians per second (rad/s).
     * @param covariance        estimated Kalman filter error covariance .
     * @throws IllegalArgumentException if provided covariance matrix is not 15x15.
     */
    public INSLooselyCoupledKalmanState(
            final ECEFFrame frame,
            final double accelerationBiasX, final double accelerationBiasY, final double accelerationBiasZ,
<span class="fc" id="L349">            final double gyroBiasX, final double gyroBiasY, final double gyroBiasZ, final Matrix covariance) {</span>
<span class="fc" id="L350">        setFrame(frame);</span>
<span class="fc" id="L351">        setAccelerationBiasCoordinates(accelerationBiasX, accelerationBiasY, accelerationBiasZ);</span>
<span class="fc" id="L352">        setGyroBiasCoordinates(gyroBiasX, gyroBiasY, gyroBiasZ);</span>
<span class="fc" id="L353">        setCovariance(covariance);</span>
<span class="fc" id="L354">    }</span>

    /**
     * Constructor.
     *
     * @param c                 body to ECEF coordinate transformation.
     * @param vx                estimated ECEF user velocity resolved around x axis.
     * @param vy                estimated ECEF user velocity resolved around y axis.
     * @param vz                estimated ECEF user velocity resolved around z axis.
     * @param x                 x coordinate of estimated ECEF user position.
     * @param y                 y coordinate of estimated ECEF user position.
     * @param z                 z coordinate of estimated ECEF user position.
     * @param accelerationBiasX estimated accelerometer bias resolved around x axis.
     * @param accelerationBiasY estimated accelerometer bias resolved around y axis.
     * @param accelerationBiasZ estimated accelerometer bias resolved around z axis.
     * @param gyroBiasX         estimated gyroscope bias resolved around x axis.
     * @param gyroBiasY         estimated gyroscope bias resolved around y axis.
     * @param gyroBiasZ         estimated gyroscope bias resolved around z axis.
     * @param covariance        estimated Kalman filter error covariance matrix.
     * @throws IllegalArgumentException if provided covariance matrix is not 15x15.
     */
    public INSLooselyCoupledKalmanState(
            final CoordinateTransformation c, final Speed vx, final Speed vy, final Speed vz,
            final Distance x, final Distance y, final Distance z, final Acceleration accelerationBiasX,
            final Acceleration accelerationBiasY, final Acceleration accelerationBiasZ,
            final AngularSpeed gyroBiasX, final AngularSpeed gyroBiasY, final AngularSpeed gyroBiasZ,
<span class="fc" id="L380">            final Matrix covariance) {</span>
<span class="fc" id="L381">        setC(c);</span>
<span class="fc" id="L382">        setVelocityCoordinates(vx, vy, vz);</span>
<span class="fc" id="L383">        setPositionCoordinates(x, y, z);</span>
<span class="fc" id="L384">        setAccelerationBiasCoordinates(accelerationBiasX, accelerationBiasY, accelerationBiasZ);</span>
<span class="fc" id="L385">        setGyroBiasCoordinates(gyroBiasX, gyroBiasY, gyroBiasZ);</span>
<span class="fc" id="L386">        setCovariance(covariance);</span>
<span class="fc" id="L387">    }</span>

    /**
     * Constructor.
     *
     * @param c                 body to ECEF coordinate transformation.
     * @param vx                estimated ECEF user velocity resolved around x axis.
     * @param vy                estimated ECEF user velocity resolved around y axis.
     * @param vz                estimated ECEF user velocity resolved around z axis.
     * @param position          estimated ECEF user position expressed in meters (m).
     * @param accelerationBiasX estimated accelerometer bias resolved around x axis.
     * @param accelerationBiasY estimated accelerometer bias resolved around y axis.
     * @param accelerationBiasZ estimated accelerometer bias resolved around z axis.
     * @param gyroBiasX         estimated gyroscope bias resolved around x axis.
     * @param gyroBiasY         estimated gyroscope bias resolved around y axis.
     * @param gyroBiasZ         estimated gyroscope bias resolved around z axis.
     * @param covariance        estimated Kalman filter error covariance matrix.
     * @throws IllegalArgumentException if provided covariance matrix is not 15x15.
     */
    public INSLooselyCoupledKalmanState(
            final CoordinateTransformation c, final Speed vx, final Speed vy, final Speed vz, final Point3D position,
            final Acceleration accelerationBiasX, final Acceleration accelerationBiasY,
            final Acceleration accelerationBiasZ, final AngularSpeed gyroBiasX, final AngularSpeed gyroBiasY,
<span class="fc" id="L410">            final AngularSpeed gyroBiasZ, final Matrix covariance) {</span>
<span class="fc" id="L411">        setC(c);</span>
<span class="fc" id="L412">        setVelocityCoordinates(vx, vy, vz);</span>
<span class="fc" id="L413">        setPosition(position);</span>
<span class="fc" id="L414">        setAccelerationBiasCoordinates(accelerationBiasX, accelerationBiasY, accelerationBiasZ);</span>
<span class="fc" id="L415">        setGyroBiasCoordinates(gyroBiasX, gyroBiasY, gyroBiasZ);</span>
<span class="fc" id="L416">        setCovariance(covariance);</span>
<span class="fc" id="L417">    }</span>

    /**
     * Constructor.
     *
     * @param c                 body to ECEF coordinate transformation.
     * @param velocity          estimated ECEF user velocity.
     * @param position          estimated ECEF user position.
     * @param accelerationBiasX estimated accelerometer bias resolved around x axis.
     * @param accelerationBiasY estimated accelerometer bias resolved around y axis.
     * @param accelerationBiasZ estimated accelerometer bias resolved around z axis.
     * @param gyroBiasX         estimated gyroscope bias resolved around x axis.
     * @param gyroBiasY         estimated gyroscope bias resolved around y axis.
     * @param gyroBiasZ         estimated gyroscope bias resolved around z axis.
     * @param covariance        estimated Kalman filter error covariance matrix.
     * @throws IllegalArgumentException if provided covariance matrix is not 15x15.
     */
    public INSLooselyCoupledKalmanState(
            final CoordinateTransformation c, final ECEFVelocity velocity, final ECEFPosition position,
            final Acceleration accelerationBiasX, final Acceleration accelerationBiasY,
            final Acceleration accelerationBiasZ, final AngularSpeed gyroBiasX, final AngularSpeed gyroBiasY,
<span class="fc" id="L438">            final AngularSpeed gyroBiasZ, final Matrix covariance) {</span>
<span class="fc" id="L439">        setC(c);</span>
<span class="fc" id="L440">        setEcefVelocity(velocity);</span>
<span class="fc" id="L441">        setEcefPosition(position);</span>
<span class="fc" id="L442">        setAccelerationBiasCoordinates(accelerationBiasX, accelerationBiasY, accelerationBiasZ);</span>
<span class="fc" id="L443">        setGyroBiasCoordinates(gyroBiasX, gyroBiasY, gyroBiasZ);</span>
<span class="fc" id="L444">        setCovariance(covariance);</span>
<span class="fc" id="L445">    }</span>

    /**
     * Constructor.
     *
     * @param c                   body to ECEF coordinate transformation.
     * @param positionAndVelocity estimated ECEF user position and velocity.
     * @param accelerationBiasX   estimated accelerometer bias resolved around x axis.
     * @param accelerationBiasY   estimated accelerometer bias resolved around y axis.
     * @param accelerationBiasZ   estimated accelerometer bias resolved around z axis.
     * @param gyroBiasX           estimated gyroscope bias resolved around x axis.
     * @param gyroBiasY           estimated gyroscope bias resolved around y axis.
     * @param gyroBiasZ           estimated gyroscope bias resolved around z axis.
     * @param covariance          estimated Kalman filter error covariance matrix.
     * @throws IllegalArgumentException if provided covariance matrix is not 15x15.
     */
    public INSLooselyCoupledKalmanState(
            final CoordinateTransformation c, final ECEFPositionAndVelocity positionAndVelocity,
            final Acceleration accelerationBiasX, final Acceleration accelerationBiasY,
            final Acceleration accelerationBiasZ, final AngularSpeed gyroBiasX, final AngularSpeed gyroBiasY,
<span class="fc" id="L465">            final AngularSpeed gyroBiasZ, final Matrix covariance) {</span>
<span class="fc" id="L466">        setC(c);</span>
<span class="fc" id="L467">        setPositionAndVelocity(positionAndVelocity);</span>
<span class="fc" id="L468">        setAccelerationBiasCoordinates(accelerationBiasX, accelerationBiasY, accelerationBiasZ);</span>
<span class="fc" id="L469">        setGyroBiasCoordinates(gyroBiasX, gyroBiasY, gyroBiasZ);</span>
<span class="fc" id="L470">        setCovariance(covariance);</span>
<span class="fc" id="L471">    }</span>

    /**
     * Constructor.
     *
     * @param frame             estimated user ECEF frame.
     * @param accelerationBiasX estimated accelerometer bias resolved around x axis.
     * @param accelerationBiasY estimated accelerometer bias resolved around y axis.
     * @param accelerationBiasZ estimated accelerometer bias resolved around z axis.
     * @param gyroBiasX         estimated gyroscope bias resolved around x axis.
     * @param gyroBiasY         estimated gyroscope bias resolved around y axis.
     * @param gyroBiasZ         estimated gyroscope bias resolved around z axis.
     * @param covariance        estimated Kalman filter error covariance matrix.
     * @throws IllegalArgumentException if provided covariance matrix is not 15x15.
     */
    public INSLooselyCoupledKalmanState(
            final ECEFFrame frame, final Acceleration accelerationBiasX, final Acceleration accelerationBiasY,
            final Acceleration accelerationBiasZ, final AngularSpeed gyroBiasX, final AngularSpeed gyroBiasY,
<span class="fc" id="L489">            final AngularSpeed gyroBiasZ, final Matrix covariance) {</span>
<span class="fc" id="L490">        setFrame(frame);</span>
<span class="fc" id="L491">        setAccelerationBiasCoordinates(accelerationBiasX, accelerationBiasY, accelerationBiasZ);</span>
<span class="fc" id="L492">        setGyroBiasCoordinates(gyroBiasX, gyroBiasY, gyroBiasZ);</span>
<span class="fc" id="L493">        setCovariance(covariance);</span>
<span class="fc" id="L494">    }</span>

    /**
     * Constructor.
     *
     * @param bodyToEcefCoordinateTransformationMatrix estimated body to ECEF coordinate transformation matrix.
     * @param vx                                       estimated ECEF user velocity resolved around x axis.
     * @param vy                                       estimated ECEF user velocity resolved around y axis.
     * @param vz                                       estimated ECEF user velocity resolved around z axis.
     * @param x                                        x coordinate of estimated ECEF user position.
     * @param y                                        y coordinate of estimated ECEF user position.
     * @param z                                        z coordinate of estimated ECEF user position.
     * @param accelerationBiasX                        estimated accelerometer bias resolved around x axis and
     *                                                 expressed in meters per squared second (m/s^2).
     * @param accelerationBiasY                        estimated accelerometer bias resolved around y axis and
     *                                                 expressed in meters per squared second (m/s^2).
     * @param accelerationBiasZ                        estimated accelerometer bias resolved around z axis and
     *                                                 expressed in meters per squared second (m/s^2).
     * @param gyroBiasX                                estimated gyroscope bias resolved around x axis and
     *                                                 expressed in radians per second (rad/s).
     * @param gyroBiasY                                estimated gyroscope bias resolved around y axis and
     *                                                 expressed in radians per second (rad/s).
     * @param gyroBiasZ                                estimated gyroscope bias resolved around z axis and
     *                                                 expressed in radians per second (rad/s).
     * @param covariance                               estimated Kalman filter error covariance matrix.
     * @throws IllegalArgumentException if provided body to ECEF coordinate transformation matrix is not 3x3
     *                                  or if provided covariance matrix is not 15x15.
     */
    public INSLooselyCoupledKalmanState(
            final Matrix bodyToEcefCoordinateTransformationMatrix, final Speed vx, final Speed vy, final Speed vz,
            final Distance x, final Distance y, final Distance z,
            final double accelerationBiasX, final double accelerationBiasY, final double accelerationBiasZ,
<span class="fc" id="L526">            final double gyroBiasX, final double gyroBiasY, final double gyroBiasZ, final Matrix covariance) {</span>
<span class="fc" id="L527">        setBodyToEcefCoordinateTransformationMatrix(bodyToEcefCoordinateTransformationMatrix);</span>
<span class="fc" id="L528">        setVelocityCoordinates(vx, vy, vz);</span>
<span class="fc" id="L529">        setPositionCoordinates(x, y, z);</span>
<span class="fc" id="L530">        setAccelerationBiasCoordinates(accelerationBiasX, accelerationBiasY, accelerationBiasZ);</span>
<span class="fc" id="L531">        setGyroBiasCoordinates(gyroBiasX, gyroBiasY, gyroBiasZ);</span>
<span class="fc" id="L532">        setCovariance(covariance);</span>
<span class="fc" id="L533">    }</span>

    /**
     * Constructor.
     *
     * @param bodyToEcefCoordinateTransformationMatrix estimated body to ECEF coordinate transformation matrix.
     * @param vx                                       estimated ECEF user velocity resolved around x axis.
     * @param vy                                       estimated ECEF user velocity resolved around y axis.
     * @param vz                                       estimated ECEF user velocity resolved around z axis.
     * @param position                                 estimated ECEF user position.
     * @param accelerationBiasX                        estimated accelerometer bias resolved around x axis and
     *                                                 expressed in meters per squared second (m/s^2).
     * @param accelerationBiasY                        estimated accelerometer bias resolved around y axis and
     *                                                 expressed in meters per squared second (m/s^2).
     * @param accelerationBiasZ                        estimated accelerometer bias resolved around z axis and
     *                                                 expressed in meters per squared second (m/s^2).
     * @param gyroBiasX                                estimated gyroscope bias resolved around x axis and
     *                                                 expressed in radians per second (rad/s).
     * @param gyroBiasY                                estimated gyroscope bias resolved around y axis and
     *                                                 expressed in radians per second (rad/s).
     * @param gyroBiasZ                                estimated gyroscope bias resolved around z axis and
     *                                                 expressed in radians per second (rad/s).
     * @param covariance                               estimated Kalman filter error covariance matrix.
     * @throws IllegalArgumentException if provided body to ECEF coordinate transformation matrix is not 3x3
     *                                  or if provided covariance matrix is not 15x15.
     */
    public INSLooselyCoupledKalmanState(
            final Matrix bodyToEcefCoordinateTransformationMatrix, final Speed vx, final Speed vy, final Speed vz,
            final Point3D position,
            final double accelerationBiasX, final double accelerationBiasY, final double accelerationBiasZ,
<span class="fc" id="L563">            final double gyroBiasX, final double gyroBiasY, final double gyroBiasZ, final Matrix covariance) {</span>
<span class="fc" id="L564">        setBodyToEcefCoordinateTransformationMatrix(bodyToEcefCoordinateTransformationMatrix);</span>
<span class="fc" id="L565">        setVelocityCoordinates(vx, vy, vz);</span>
<span class="fc" id="L566">        setPosition(position);</span>
<span class="fc" id="L567">        setAccelerationBiasCoordinates(accelerationBiasX, accelerationBiasY, accelerationBiasZ);</span>
<span class="fc" id="L568">        setGyroBiasCoordinates(gyroBiasX, gyroBiasY, gyroBiasZ);</span>
<span class="fc" id="L569">        setCovariance(covariance);</span>
<span class="fc" id="L570">    }</span>

    /**
     * Constructor.
     *
     * @param bodyToEcefCoordinateTransformationMatrix estimated body to ECEF coordinate transformation matrix.
     * @param velocity                                 estimated ECEF user velocity.
     * @param position                                 estimated ECEF user position.
     * @param accelerationBiasX                        estimated accelerometer bias resolved around x axis and
     *                                                 expressed in meters per squared second (m/s^2).
     * @param accelerationBiasY                        estimated accelerometer bias resolved around y axis and
     *                                                 expressed in meters per squared second (m/s^2).
     * @param accelerationBiasZ                        estimated accelerometer bias resolved around z axis and
     *                                                 expressed in meters per squared second (m/s^2).
     * @param gyroBiasX                                estimated gyroscope bias resolved around x axis and
     *                                                 expressed in radians per second (rad/s).
     * @param gyroBiasY                                estimated gyroscope bias resolved around y axis and
     *                                                 expressed in radians per second (rad/s).
     * @param gyroBiasZ                                estimated gyroscope bias resolved around z axis and
     *                                                 expressed in radians per second (rad/s).
     * @param covariance                               estimated Kalman filter error covariance matrix.
     * @throws IllegalArgumentException if provided body to ECEF coordinate transformation matrix is not 3x3
     *                                  or if provided covariance matrix is not 15x15.
     */
    public INSLooselyCoupledKalmanState(
            final Matrix bodyToEcefCoordinateTransformationMatrix, final ECEFVelocity velocity,
            final ECEFPosition position,
            final double accelerationBiasX, final double accelerationBiasY, final double accelerationBiasZ,
<span class="fc" id="L598">            final double gyroBiasX, final double gyroBiasY, final double gyroBiasZ, final Matrix covariance) {</span>
<span class="fc" id="L599">        setBodyToEcefCoordinateTransformationMatrix(bodyToEcefCoordinateTransformationMatrix);</span>
<span class="fc" id="L600">        setEcefVelocity(velocity);</span>
<span class="fc" id="L601">        setEcefPosition(position);</span>
<span class="fc" id="L602">        setAccelerationBiasCoordinates(accelerationBiasX, accelerationBiasY, accelerationBiasZ);</span>
<span class="fc" id="L603">        setGyroBiasCoordinates(gyroBiasX, gyroBiasY, gyroBiasZ);</span>
<span class="fc" id="L604">        setCovariance(covariance);</span>
<span class="fc" id="L605">    }</span>

    /**
     * Constructor.
     *
     * @param bodyToEcefCoordinateTransformationMatrix estimated body to ECEF coordinate transformation matrix.
     * @param positionAndVelocity                      estimated ECEF user position and velocity.
     * @param accelerationBiasX                        estimated accelerometer bias resolved around x axis and
     *                                                 expressed in meters per squared second (m/s^2).
     * @param accelerationBiasY                        estimated accelerometer bias resolved around y axis and
     *                                                 expressed in meters per squared second (m/s^2).
     * @param accelerationBiasZ                        estimated accelerometer bias resolved around z axis and
     *                                                 expressed in meters per squared second (m/s^2).
     * @param gyroBiasX                                estimated gyroscope bias resolved around x axis and
     *                                                 expressed in radians per second (rad/s).
     * @param gyroBiasY                                estimated gyroscope bias resolved around y axis and
     *                                                 expressed in radians per second (rad/s).
     * @param gyroBiasZ                                estimated gyroscope bias resolved around z axis and
     *                                                 expressed in radians per second (rad/s).
     * @param covariance                               estimated Kalman filter error covariance matrix.
     * @throws IllegalArgumentException if provided body to ECEF coordinate transformation matrix is not 3x3
     *                                  or if provided covariance matrix is not 15x15.
     */
    public INSLooselyCoupledKalmanState(
            final Matrix bodyToEcefCoordinateTransformationMatrix, final ECEFPositionAndVelocity positionAndVelocity,
            final double accelerationBiasX, final double accelerationBiasY, final double accelerationBiasZ,
<span class="fc" id="L631">            final double gyroBiasX, final double gyroBiasY, final double gyroBiasZ, final Matrix covariance) {</span>
<span class="fc" id="L632">        setBodyToEcefCoordinateTransformationMatrix(bodyToEcefCoordinateTransformationMatrix);</span>
<span class="fc" id="L633">        setPositionAndVelocity(positionAndVelocity);</span>
<span class="fc" id="L634">        setAccelerationBiasCoordinates(accelerationBiasX, accelerationBiasY, accelerationBiasZ);</span>
<span class="fc" id="L635">        setGyroBiasCoordinates(gyroBiasX, gyroBiasY, gyroBiasZ);</span>
<span class="fc" id="L636">        setCovariance(covariance);</span>
<span class="fc" id="L637">    }</span>

    /**
     * Constructor.
     *
     * @param bodyToEcefCoordinateTransformationMatrix estimated body to ECEF coordinate transformation matrix.
     * @param vx                                       estimated ECEF user velocity resolved around x axis.
     * @param vy                                       estimated ECEF user velocity resolved around y axis.
     * @param vz                                       estimated ECEF user velocity resolved around z axis.
     * @param x                                        x coordinate of estimated ECEF user position.
     * @param y                                        y coordinate of estimated ECEF user position.
     * @param z                                        z coordinate of estimated ECEF user position.
     * @param accelerationBiasX                        estimated accelerometer bias resolved around x axis.
     * @param accelerationBiasY                        estimated accelerometer bias resolved around y axis.
     * @param accelerationBiasZ                        estimated accelerometer bias resolved around z axis.
     * @param gyroBiasX                                estimated gyroscope bias resolved around x axis.
     * @param gyroBiasY                                estimated gyroscope bias resolved around y axis.
     * @param gyroBiasZ                                estimated gyroscope bias resolved around z axis.
     * @param covariance                               estimated Kalman filter error covariance matrix.
     * @throws IllegalArgumentException if provided body to ECEF coordinate transformation matrix is not 3x3
     *                                  or if provided covariance matrix is not 15x15.
     */
    public INSLooselyCoupledKalmanState(
            final Matrix bodyToEcefCoordinateTransformationMatrix, final Speed vx, final Speed vy, final Speed vz,
            final Distance x, final Distance y, final Distance z, final Acceleration accelerationBiasX,
            final Acceleration accelerationBiasY, final Acceleration accelerationBiasZ, final AngularSpeed gyroBiasX,
<span class="fc" id="L663">            final AngularSpeed gyroBiasY, final AngularSpeed gyroBiasZ, final Matrix covariance) {</span>
<span class="fc" id="L664">        setBodyToEcefCoordinateTransformationMatrix(bodyToEcefCoordinateTransformationMatrix);</span>
<span class="fc" id="L665">        setVelocityCoordinates(vx, vy, vz);</span>
<span class="fc" id="L666">        setPositionCoordinates(x, y, z);</span>
<span class="fc" id="L667">        setAccelerationBiasCoordinates(accelerationBiasX, accelerationBiasY, accelerationBiasZ);</span>
<span class="fc" id="L668">        setGyroBiasCoordinates(gyroBiasX, gyroBiasY, gyroBiasZ);</span>
<span class="fc" id="L669">        setCovariance(covariance);</span>
<span class="fc" id="L670">    }</span>

    /**
     * Constructor.
     *
     * @param bodyToEcefCoordinateTransformationMatrix estimated body to ECEF coordinate transformation matrix.
     * @param vx                                       estimated ECEF user velocity resolved around x axis.
     * @param vy                                       estimated ECEF user velocity resolved around y axis.
     * @param vz                                       estimated ECEF user velocity resolved around z axis.
     * @param position                                 estimated ECEF user position expressed in meters (m).
     * @param accelerationBiasX                        estimated accelerometer bias resolved around x axis.
     * @param accelerationBiasY                        estimated accelerometer bias resolved around y axis.
     * @param accelerationBiasZ                        estimated accelerometer bias resolved around z axis.
     * @param gyroBiasX                                estimated gyroscope bias resolved around x axis.
     * @param gyroBiasY                                estimated gyroscope bias resolved around y axis.
     * @param gyroBiasZ                                estimated gyroscope bias resolved around z axis.
     * @param covariance                               estimated Kalman filter error covariance matrix.
     * @throws IllegalArgumentException if provided body to ECEF coordinate transformation matrix is not 3x3
     *                                  or if provided covariance matrix is not 15x15.
     */
    public INSLooselyCoupledKalmanState(
            final Matrix bodyToEcefCoordinateTransformationMatrix, final Speed vx, final Speed vy, final Speed vz,
            final Point3D position, final Acceleration accelerationBiasX, final Acceleration accelerationBiasY,
            final Acceleration accelerationBiasZ, final AngularSpeed gyroBiasX, final AngularSpeed gyroBiasY,
<span class="fc" id="L694">            final AngularSpeed gyroBiasZ, final Matrix covariance) {</span>
<span class="fc" id="L695">        setBodyToEcefCoordinateTransformationMatrix(bodyToEcefCoordinateTransformationMatrix);</span>
<span class="fc" id="L696">        setVelocityCoordinates(vx, vy, vz);</span>
<span class="fc" id="L697">        setPosition(position);</span>
<span class="fc" id="L698">        setAccelerationBiasCoordinates(accelerationBiasX, accelerationBiasY, accelerationBiasZ);</span>
<span class="fc" id="L699">        setGyroBiasCoordinates(gyroBiasX, gyroBiasY, gyroBiasZ);</span>
<span class="fc" id="L700">        setCovariance(covariance);</span>
<span class="fc" id="L701">    }</span>

    /**
     * Constructor.
     *
     * @param bodyToEcefCoordinateTransformationMatrix estimated body to ECEF coordinate transformation matrix.
     * @param velocity                                 estimated ECEF user velocity.
     * @param position                                 estimated ECEF user position.
     * @param accelerationBiasX                        estimated accelerometer bias resolved around x axis.
     * @param accelerationBiasY                        estimated accelerometer bias resolved around y axis.
     * @param accelerationBiasZ                        estimated accelerometer bias resolved around z axis.
     * @param gyroBiasX                                estimated gyroscope bias resolved around x axis.
     * @param gyroBiasY                                estimated gyroscope bias resolved around y axis.
     * @param gyroBiasZ                                estimated gyroscope bias resolved around z axis.
     * @param covariance                               estimated Kalman filter error covariance matrix.
     * @throws IllegalArgumentException if provided body to ECEF coordinate transformation matrix is not 3x3
     *                                  or if provided covariance matrix is not 15x15.
     */
    public INSLooselyCoupledKalmanState(
            final Matrix bodyToEcefCoordinateTransformationMatrix, final ECEFVelocity velocity,
            final ECEFPosition position, final Acceleration accelerationBiasX, final Acceleration accelerationBiasY,
            final Acceleration accelerationBiasZ, final AngularSpeed gyroBiasX, final AngularSpeed gyroBiasY,
<span class="fc" id="L723">            final AngularSpeed gyroBiasZ, final Matrix covariance) {</span>
<span class="fc" id="L724">        setBodyToEcefCoordinateTransformationMatrix(bodyToEcefCoordinateTransformationMatrix);</span>
<span class="fc" id="L725">        setEcefVelocity(velocity);</span>
<span class="fc" id="L726">        setEcefPosition(position);</span>
<span class="fc" id="L727">        setAccelerationBiasCoordinates(accelerationBiasX, accelerationBiasY, accelerationBiasZ);</span>
<span class="fc" id="L728">        setGyroBiasCoordinates(gyroBiasX, gyroBiasY, gyroBiasZ);</span>
<span class="fc" id="L729">        setCovariance(covariance);</span>
<span class="fc" id="L730">    }</span>

    /**
     * Constructor.
     *
     * @param bodyToEcefCoordinateTransformationMatrix estimated body to ECEF coordinate transformation matrix.
     * @param positionAndVelocity                      estimated ECEF user position and velocity.
     * @param accelerationBiasX                        estimated accelerometer bias resolved around x axis.
     * @param accelerationBiasY                        estimated accelerometer bias resolved around y axis.
     * @param accelerationBiasZ                        estimated accelerometer bias resolved around z axis.
     * @param gyroBiasX                                estimated gyroscope bias resolved around x axis.
     * @param gyroBiasY                                estimated gyroscope bias resolved around y axis.
     * @param gyroBiasZ                                estimated gyroscope bias resolved around z axis.
     * @param covariance                               estimated Kalman filter error covariance matrix.
     * @throws IllegalArgumentException if provided body to ECEF coordinate transformation matrix is not 3x3
     *                                  or if provided covariance matrix is not 15x15.
     */
    public INSLooselyCoupledKalmanState(
            final Matrix bodyToEcefCoordinateTransformationMatrix, final ECEFPositionAndVelocity positionAndVelocity,
            final Acceleration accelerationBiasX, final Acceleration accelerationBiasY,
            final Acceleration accelerationBiasZ, final AngularSpeed gyroBiasX, final AngularSpeed gyroBiasY,
<span class="fc" id="L751">            final AngularSpeed gyroBiasZ, final Matrix covariance) {</span>
<span class="fc" id="L752">        setBodyToEcefCoordinateTransformationMatrix(bodyToEcefCoordinateTransformationMatrix);</span>
<span class="fc" id="L753">        setPositionAndVelocity(positionAndVelocity);</span>
<span class="fc" id="L754">        setAccelerationBiasCoordinates(accelerationBiasX, accelerationBiasY, accelerationBiasZ);</span>
<span class="fc" id="L755">        setGyroBiasCoordinates(gyroBiasX, gyroBiasY, gyroBiasZ);</span>
<span class="fc" id="L756">        setCovariance(covariance);</span>
<span class="fc" id="L757">    }</span>

    /**
     * Copy constructor.
     *
     * @param input input instance to copy data from.
     */
<span class="fc" id="L764">    public INSLooselyCoupledKalmanState(final INSLooselyCoupledKalmanState input) {</span>
<span class="fc" id="L765">        copyFrom(input);</span>
<span class="fc" id="L766">    }</span>

    /**
     * Gets estimated body to ECEF coordinate transformation matrix.
     *
     * @return estimated body to ECEF coordinate transformation matrix.
     */
    public Matrix getBodyToEcefCoordinateTransformationMatrix() {
<span class="fc" id="L774">        return bodyToEcefCoordinateTransformationMatrix;</span>
    }

    /**
     * Sets estimated body to ECEF coordinate transformation matrix.
     *
     * @param bodyToEcefCoordinateTransformationMatrix estimated body to ECEF coordinate
     *                                                 transformation matrix.
     * @throws IllegalArgumentException if provided matrix is not 3x3.
     */
    public void setBodyToEcefCoordinateTransformationMatrix(final Matrix bodyToEcefCoordinateTransformationMatrix) {
<span class="fc bfc" id="L785" title="All 2 branches covered.">        if (bodyToEcefCoordinateTransformationMatrix.getRows() != CoordinateTransformation.ROWS</span>
<span class="fc bfc" id="L786" title="All 2 branches covered.">                || bodyToEcefCoordinateTransformationMatrix.getColumns() != CoordinateTransformation.COLS) {</span>
<span class="fc" id="L787">            throw new IllegalArgumentException();</span>
        }
<span class="fc" id="L789">        this.bodyToEcefCoordinateTransformationMatrix = bodyToEcefCoordinateTransformationMatrix;</span>
<span class="fc" id="L790">    }</span>

    /**
     * Gets estimated ECEF user velocity resolved around x axis and expressed in meters per second (m/s).
     *
     * @return estimated ECEF user velocity resolved around x axis and expressed in meters per second (m/s).
     */
    public double getVx() {
<span class="fc" id="L798">        return vx;</span>
    }

    /**
     * Sets estimated ECEF user velocity resolved around x axis and expressed in meters per second (m/s).
     *
     * @param vx estimated ECEF user velocity resolved around x axis and expressed in meters per second (m/s).
     */
    public void setVx(final double vx) {
<span class="fc" id="L807">        this.vx = vx;</span>
<span class="fc" id="L808">    }</span>

    /**
     * Gets estimated ECEF user velocity resolved around y axis and expressed in meters per second (m/s).
     *
     * @return estimated ECEF user velocity resolved around y axis and expressed in meters per second (m/s).
     */
    public double getVy() {
<span class="fc" id="L816">        return vy;</span>
    }

    /**
     * Sets estimated ECEF user velocity resolved around y axis and expressed in meters per second (m/s).
     *
     * @param vy estimated ECEF user velocity resolved around y axis and expressed in meters per second (m/s).
     */
    public void setVy(final double vy) {
<span class="fc" id="L825">        this.vy = vy;</span>
<span class="fc" id="L826">    }</span>

    /**
     * Gets estimated ECEF user velocity resolved around z axis and expressed in meters per second (m/s).
     *
     * @return estimated ECEF user velocity resolved around z axis and expressed in meters per second (m/s).
     */
    public double getVz() {
<span class="fc" id="L834">        return vz;</span>
    }

    /**
     * Sets estimated ECEF user velocity resolved around z axis and expressed in meters per second (m/s).
     *
     * @param vz estimated ECEF user velocity resolved around z axis and expressed in meters per second (m/s).
     */
    public void setVz(final double vz) {
<span class="fc" id="L843">        this.vz = vz;</span>
<span class="fc" id="L844">    }</span>

    /**
     * Sets estimated ECEF user velocity coordinates.
     *
     * @param vx estimated ECEF user velocity resolved around x axis and expressed in meters per second (m/s).
     * @param vy estimated ECEF user velocity resolved around y axis and expressed in meters per second (m/s).
     * @param vz estimated ECEF user velocity resolved around z axis and expressed in meters per second (m/s).
     */
    public void setVelocityCoordinates(final double vx, final double vy, final double vz) {
<span class="fc" id="L854">        this.vx = vx;</span>
<span class="fc" id="L855">        this.vy = vy;</span>
<span class="fc" id="L856">        this.vz = vz;</span>
<span class="fc" id="L857">    }</span>

    /**
     * Gets x coordinate of estimated ECEF user position expressed in meters (m).
     *
     * @return x coordinate of estimated ECEF user position expressed in meters (m).
     */
    public double getX() {
<span class="fc" id="L865">        return x;</span>
    }

    /**
     * Sets x coordinate of estimated ECEF user position expressed in meters (m).
     *
     * @param x x coordinate of estimated ECEF user position expressed in meters (m).
     */
    public void setX(final double x) {
<span class="fc" id="L874">        this.x = x;</span>
<span class="fc" id="L875">    }</span>

    /**
     * Gets y coordinate of estimated ECEF user position expressed in meters (m).
     *
     * @return y coordinate of estimated ECEF user position expressed in meters (m).
     */
    public double getY() {
<span class="fc" id="L883">        return y;</span>
    }

    /**
     * Sets y coordinate of estimated ECEF user position expressed in meters (m).
     *
     * @param y y coordinate of estimated ECEF user position expressed in meters (m).
     */
    public void setY(final double y) {
<span class="fc" id="L892">        this.y = y;</span>
<span class="fc" id="L893">    }</span>

    /**
     * Gets z coordinate of estimated ECEF user position expressed in meters (m).
     *
     * @return z coordinate of estimated ECEF user position expressed in meters (m).
     */
    public double getZ() {
<span class="fc" id="L901">        return z;</span>
    }

    /**
     * Sets z coordinate of estimated ECEF user position expressed in meters (m).
     *
     * @param z z coordinate of estimated ECEF user position expressed in meters (m).
     */
    public void setZ(final double z) {
<span class="fc" id="L910">        this.z = z;</span>
<span class="fc" id="L911">    }</span>

    /**
     * Sets estimated ECEF user position coordinates.
     *
     * @param x x coordinate of estimated ECEF user position expressed in meters (m).
     * @param y y coordinate of estimated ECEF user position expressed in meters (m).
     * @param z z coordinate of estimated ECEF user position expressed in meters (m).
     */
    public void setPositionCoordinates(final double x, final double y, final double z) {
<span class="fc" id="L921">        this.x = x;</span>
<span class="fc" id="L922">        this.y = y;</span>
<span class="fc" id="L923">        this.z = z;</span>
<span class="fc" id="L924">    }</span>

    /**
     * Gets estimated accelerometer bias resolved around x axis and expressed in
     * meters per squared second (m/s^2).
     *
     * @return estimated accelerometer bias resolved around x axis and expressed in
     * meters per squared second (m/s^2).
     */
    public double getAccelerationBiasX() {
<span class="fc" id="L934">        return accelerationBiasX;</span>
    }

    /**
     * Sets estimated accelerometer bias resolved around x axis and expressed in
     * meters per squared second (m/s^2).
     *
     * @param accelerationBiasX estimated accelerometer bias resolved around x axis and
     *                          expressed in meters per squared second (m/s^2).
     */
    public void setAccelerationBiasX(final double accelerationBiasX) {
<span class="fc" id="L945">        this.accelerationBiasX = accelerationBiasX;</span>
<span class="fc" id="L946">    }</span>

    /**
     * Gets estimated accelerometer bias resolved around y axis and expressed in
     * meters per squared second (m/s^2).
     *
     * @return estimated accelerometer bias resolved around y axis and expressed in
     * meters per squared second (m/s^2).
     */
    public double getAccelerationBiasY() {
<span class="fc" id="L956">        return accelerationBiasY;</span>
    }

    /**
     * Sets estimated accelerometer bias resolved around y axis and expressed in
     * meters per squared second (m/s^2).
     *
     * @param accelerationBiasY estimated accelerometer bias resolved around y axis
     *                          and expressed in meters per squared second (m/s^2).
     */
    public void setAccelerationBiasY(final double accelerationBiasY) {
<span class="fc" id="L967">        this.accelerationBiasY = accelerationBiasY;</span>
<span class="fc" id="L968">    }</span>

    /**
     * Gets estimated accelerometer bias resolved around z axis and expressed in
     * meters per squared second (m/s^2).
     *
     * @return estimated accelerometer bias resolved around z axis and
     * expressed in meters per squared second (m/s^2).
     */
    public double getAccelerationBiasZ() {
<span class="fc" id="L978">        return accelerationBiasZ;</span>
    }

    /**
     * Sets estimated accelerometer bias resolved around z axis and expressed in
     * meters per squared second (m/s^2).
     *
     * @param accelerationBiasZ estimated accelerometer bias resolved around z axis
     *                          and expressed in meters per squared second (m/s^2).
     */
    public void setAccelerationBiasZ(final double accelerationBiasZ) {
<span class="fc" id="L989">        this.accelerationBiasZ = accelerationBiasZ;</span>
<span class="fc" id="L990">    }</span>

    /**
     * Sets estimated accelerometer bias expressed in meters per squared second (m/s^2).
     *
     * @param accelerationBiasX estimated accelerometer bias resolved around x axis and
     *                          expressed in meters per squared second (m/s^2).
     * @param accelerationBiasY estimated accelerometer bias resolved around y axis and
     *                          expressed in meters per squared second (m/s^2).
     * @param accelerationBiasZ estimated accelerometer bias resolved around z axis and
     *                          expressed in meters per squared second (m/s^2).
     */
    public void setAccelerationBiasCoordinates(
            final double accelerationBiasX, final double accelerationBiasY, final double accelerationBiasZ) {
<span class="fc" id="L1004">        this.accelerationBiasX = accelerationBiasX;</span>
<span class="fc" id="L1005">        this.accelerationBiasY = accelerationBiasY;</span>
<span class="fc" id="L1006">        this.accelerationBiasZ = accelerationBiasZ;</span>
<span class="fc" id="L1007">    }</span>

    /**
     * Gets estimated gyroscope bias resolved around x axis and expressed in
     * radians per second (rad/s).
     *
     * @return estimated gyroscope bias resolved around x axis and expressed in
     * radians per second (rad/s).
     */
    public double getGyroBiasX() {
<span class="fc" id="L1017">        return gyroBiasX;</span>
    }

    /**
     * Sets estimated gyroscope bias resolved around x axis and expressed in
     * radians per second (rad/s).
     *
     * @param gyroBiasX estimated gyroscope bias resolved around x axis and
     *                  expressed in radians per second (rad/s).
     */
    public void setGyroBiasX(final double gyroBiasX) {
<span class="fc" id="L1028">        this.gyroBiasX = gyroBiasX;</span>
<span class="fc" id="L1029">    }</span>

    /**
     * Gets estimated gyroscope bias resolved around y axis and expressed in
     * radians per second (rad/s).
     *
     * @return estimated gyroscope bias resolved around y axis and expressed
     * in radians per second (rad/s).
     */
    public double getGyroBiasY() {
<span class="fc" id="L1039">        return gyroBiasY;</span>
    }

    /**
     * Sets estimated gyroscope bias resolved around y axis and expressed in
     * radians per second (rad/s).
     *
     * @param gyroBiasY estimated gyroscope bias resolved around y axis and
     *                  expressed in radians per second (rad/s).
     */
    public void setGyroBiasY(final double gyroBiasY) {
<span class="fc" id="L1050">        this.gyroBiasY = gyroBiasY;</span>
<span class="fc" id="L1051">    }</span>

    /**
     * Gets estimated gyroscope bias resolved around z axis and expressed in
     * radians per second (rad/s).
     *
     * @return estimated gyroscope bias resolved around z axis and expressed
     * in radians per second (rad/s).
     */
    public double getGyroBiasZ() {
<span class="fc" id="L1061">        return gyroBiasZ;</span>
    }

    /**
     * Sets estimated gyroscope bias resolved around z axis and expressed in
     * radians per second (rad/s).
     *
     * @param gyroBiasZ estimated gyroscope bias resolved around z axis and
     *                  expressed in radians per second (rad/s).
     */
    public void setGyroBiasZ(final double gyroBiasZ) {
<span class="fc" id="L1072">        this.gyroBiasZ = gyroBiasZ;</span>
<span class="fc" id="L1073">    }</span>

    /**
     * Sets estimated gyroscope bias coordinates expressed in radians
     * per second (rad/s).
     *
     * @param gyroBiasX estimated gyroscope bias resolved around x axis and
     *                  expressed in radians per second (rad/s).
     * @param gyroBiasY estimated gyroscope bias resolved around y axis and
     *                  expressed in radians per second (rad/s).
     * @param gyroBiasZ estimated gyroscope bias resolved around z axis and
     *                  expressed in radians per second (rad/s).
     */
    public void setGyroBiasCoordinates(final double gyroBiasX, final double gyroBiasY, final double gyroBiasZ) {
<span class="fc" id="L1087">        this.gyroBiasX = gyroBiasX;</span>
<span class="fc" id="L1088">        this.gyroBiasY = gyroBiasY;</span>
<span class="fc" id="L1089">        this.gyroBiasZ = gyroBiasZ;</span>
<span class="fc" id="L1090">    }</span>

    /**
     * Gets Kalman filter error covariance matrix.
     * Notice that covariance is expressed in terms of ECEF coordinates.
     * If accuracy of position, attitude or velocity needs to be expressed in terms
     * of NED coordinates, their respective sub-matrices of this covariance matrix
     * must be rotated, taking into account the Jacobian of the matrix transformation
     * relating both coordinates, the covariance can be expressed following the law
     * of propagation of uncertainties
     * &lt;a href=&quot;https://en.wikipedia.org/wiki/Propagation_of_uncertainty&quot;&gt;(https://en.wikipedia.org/wiki/Propagation_of_uncertainty)&lt;/a&gt;
     * as: cov(f(x)) = J*cov(x)*J'.
     *
     * @param result instance where result data will be copied to.
     * @return true if result data has been copied, false otherwise.
     */
    public boolean getCovariance(final Matrix result) {
<span class="fc bfc" id="L1107" title="All 2 branches covered.">        if (covariance != null) {</span>
<span class="fc" id="L1108">            covariance.copyTo(result);</span>
<span class="fc" id="L1109">            return true;</span>
        } else {
<span class="fc" id="L1111">            return false;</span>
        }
    }

    /**
     * Gets Kalman filter error covariance matrix.
     * Notice that covariance is expressed in terms of ECEF coordinates.
     * If accuracy of position, attitude or velocity needs to be expressed in terms
     * of NED coordinates, their respective sub-matrices of this covariance matrix
     * must be rotated, taking into account the Jacobian of the matrix transformation
     * relating both coordinates, the covariance can be expressed following the law
     * of propagation of uncertainties
     * &lt;a href=&quot;https://en.wikipedia.org/wiki/Propagation_of_uncertainty&quot;&gt;(https://en.wikipedia.org/wiki/Propagation_of_uncertainty)&lt;/a&gt;
     * as: cov(f(x)) = J*cov(x)*J'.
     *
     * @return Kalman filter error covariance matrix.
     */
    public Matrix getCovariance() {
<span class="fc" id="L1129">        return covariance;</span>
    }

    /**
     * Sets Kalman filter error covariance matrix.
     *
     * @param covariance Kalman filter error covariance matrix to be set.
     * @throws IllegalArgumentException if provided covariance matrix is not 15x15.
     */
    public void setCovariance(final Matrix covariance) {
<span class="pc bpc" id="L1139" title="1 of 4 branches missed.">        if (covariance.getRows() != NUM_PARAMS || covariance.getColumns() != NUM_PARAMS) {</span>
<span class="fc" id="L1140">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L1143">        this.covariance = covariance;</span>
<span class="fc" id="L1144">    }</span>

    /**
     * Gets body to ECEF coordinate transformation.
     *
     * @return body to ECEF coordinate transformation.
     * @throws InvalidRotationMatrixException if current body to ECEF transformation matrix is
     *                                        not valid (is not a 3x3 orthonormal matrix).
     */
    public CoordinateTransformation getC() throws InvalidRotationMatrixException {
<span class="fc bfc" id="L1154" title="All 2 branches covered.">        if (bodyToEcefCoordinateTransformationMatrix != null) {</span>
            try {
                // Make sure that matrix is orthonormal
<span class="fc" id="L1157">                final var fixed = fixRotationMatrix();</span>
<span class="fc" id="L1158">                return new CoordinateTransformation(fixed, FrameType.BODY_FRAME,</span>
                        FrameType.EARTH_CENTERED_EARTH_FIXED_FRAME);
<span class="nc" id="L1160">            } catch (final AlgebraException ignore) {</span>
<span class="nc" id="L1161">                return null;</span>
            }

        } else {
<span class="fc" id="L1165">            return null;</span>
        }
    }

    /**
     * Gets body to ECEF coordinate transformation.
     *
     * @param threshold threshold to determine whether current body to ECEF transformation
     *                  matrix is valid or not (to check that matrix is 3x3 orthonormal).
     * @return body to ECEF coordinate transformation.
     * @throws InvalidRotationMatrixException if current body to ECEF transformation matrix
     *                                        is considered not valid (is not a 3x3 orthonormal matrix) with provided threshold.
     */
    public CoordinateTransformation getC(final double threshold) throws InvalidRotationMatrixException {
<span class="pc bpc" id="L1179" title="1 of 2 branches missed.">        return bodyToEcefCoordinateTransformationMatrix != null</span>
<span class="nc" id="L1180">                ? new CoordinateTransformation(bodyToEcefCoordinateTransformationMatrix, FrameType.BODY_FRAME,</span>
                FrameType.EARTH_CENTERED_EARTH_FIXED_FRAME, threshold)
<span class="fc" id="L1182">                : null;</span>
    }

    /**
     * Gets body to ECEF coordinate transformation.
     *
     * @param result instance where body to ECEF coordinate transformation will be stored.
     * @return true if result instance was updated, false otherwise.
     * @throws InvalidRotationMatrixException if current body to ECEF transformation matrix
     *                                        is not valid (is not a 3x3 orthonormal matrix).
     */
    public boolean getC(final CoordinateTransformation result) throws InvalidRotationMatrixException {
<span class="fc bfc" id="L1194" title="All 2 branches covered.">        if (bodyToEcefCoordinateTransformationMatrix != null) {</span>
<span class="fc" id="L1195">            result.setSourceType(FrameType.BODY_FRAME);</span>
<span class="fc" id="L1196">            result.setDestinationType(FrameType.EARTH_CENTERED_EARTH_FIXED_FRAME);</span>
<span class="fc" id="L1197">            result.setMatrix(bodyToEcefCoordinateTransformationMatrix);</span>
<span class="fc" id="L1198">            return true;</span>
        } else {
<span class="fc" id="L1200">            return false;</span>
        }
    }

    /**
     * Gets body to ECEF coordinate transformation.
     *
     * @param result    instance where body to ECEF coordinate transformation will be stored.
     * @param threshold threshold to determine whether current body to ECEF transformation
     *                  matrix is valid or not (to check that matrix is 3x3 orthonormal).
     * @return true if result instance was updated, false otherwise.
     * @throws InvalidRotationMatrixException if current body to ECEF transformation matrix
     *                                        is not valid (is not a 3x3 orthonormal matrix) with provided threshold.
     */
    public boolean getC(final CoordinateTransformation result, final double threshold)
            throws InvalidRotationMatrixException {
<span class="fc bfc" id="L1216" title="All 2 branches covered.">        if (bodyToEcefCoordinateTransformationMatrix != null) {</span>
<span class="fc" id="L1217">            result.setSourceType(FrameType.BODY_FRAME);</span>
<span class="fc" id="L1218">            result.setDestinationType(FrameType.EARTH_CENTERED_EARTH_FIXED_FRAME);</span>
<span class="fc" id="L1219">            result.setMatrix(bodyToEcefCoordinateTransformationMatrix, threshold);</span>
<span class="fc" id="L1220">            return true;</span>
        } else {
<span class="fc" id="L1222">            return false;</span>
        }
    }

    /**
     * Sets body to ECEF coordinate transformation.
     *
     * @param c body to ECEF coordinate transformation to be set.
     * @throws IllegalArgumentException if provided coordinate transformation is
     *                                  not null and is not a body to ECEF transformation.
     */
    public void setC(final CoordinateTransformation c) {
<span class="fc bfc" id="L1234" title="All 2 branches covered.">        if (c == null) {</span>
<span class="fc" id="L1235">            bodyToEcefCoordinateTransformationMatrix = null;</span>

        } else {

<span class="fc bfc" id="L1239" title="All 2 branches covered.">            if (c.getSourceType() != FrameType.BODY_FRAME</span>
<span class="pc bpc" id="L1240" title="1 of 2 branches missed.">                    || c.getDestinationType() != FrameType.EARTH_CENTERED_EARTH_FIXED_FRAME) {</span>
<span class="fc" id="L1241">                throw new IllegalArgumentException();</span>
            }

<span class="fc bfc" id="L1244" title="All 2 branches covered.">            if (bodyToEcefCoordinateTransformationMatrix != null) {</span>
<span class="fc" id="L1245">                c.getMatrix(bodyToEcefCoordinateTransformationMatrix);</span>
            } else {
<span class="fc" id="L1247">                bodyToEcefCoordinateTransformationMatrix = c.getMatrix();</span>
            }
        }
<span class="fc" id="L1250">    }</span>

    /**
     * Gets estimated ECEF user velocity resolved around x axis.
     *
     * @param result instance where estimated ECEF user velocity resolved around x axis will be stored.
     */
    public void getSpeedX(final Speed result) {
<span class="fc" id="L1258">        result.setValue(vx);</span>
<span class="fc" id="L1259">        result.setUnit(SpeedUnit.METERS_PER_SECOND);</span>
<span class="fc" id="L1260">    }</span>

    /**
     * Gets estimated ECEF user velocity resolved around x axis.
     *
     * @return estimated ECEF user velocity resolved around x axis.
     */
    public Speed getSpeedX() {
<span class="fc" id="L1268">        return new Speed(vx, SpeedUnit.METERS_PER_SECOND);</span>
    }

    /**
     * Sets estimated ECEF user velocity resolved around x axis.
     *
     * @param vx estimated ECEF user velocity resolved around x axis.
     */
    public void setSpeedX(final Speed vx) {
<span class="fc" id="L1277">        this.vx = SpeedConverter.convert(vx.getValue().doubleValue(), vx.getUnit(), SpeedUnit.METERS_PER_SECOND);</span>
<span class="fc" id="L1278">    }</span>

    /**
     * Gets estimated ECEF user velocity resolved around y axis.
     *
     * @param result instance where estimated ECEF user velocity resolved around y axis will be stored.
     */
    public void getSpeedY(final Speed result) {
<span class="fc" id="L1286">        result.setValue(vy);</span>
<span class="fc" id="L1287">        result.setUnit(SpeedUnit.METERS_PER_SECOND);</span>
<span class="fc" id="L1288">    }</span>

    /**
     * Gets estimated ECEF user velocity resolved around y axis.
     *
     * @return estimated ECEF velocity resolved around y axis.
     */
    public Speed getSpeedY() {
<span class="fc" id="L1296">        return new Speed(vy, SpeedUnit.METERS_PER_SECOND);</span>
    }

    /**
     * Sets estimated ECEF user velocity resolved around y axis.
     *
     * @param vy estimated ECEF user velocity resolved around y axis.
     */
    public void setSpeedY(final Speed vy) {
<span class="fc" id="L1305">        this.vy = SpeedConverter.convert(vy.getValue().doubleValue(), vy.getUnit(), SpeedUnit.METERS_PER_SECOND);</span>
<span class="fc" id="L1306">    }</span>

    /**
     * Gets estimated ECEF user velocity resolved around z axis.
     *
     * @param result instance where estimated ECEF user velocity resolved around z axis will be stored.
     */
    public void getSpeedZ(final Speed result) {
<span class="fc" id="L1314">        result.setValue(vz);</span>
<span class="fc" id="L1315">        result.setUnit(SpeedUnit.METERS_PER_SECOND);</span>
<span class="fc" id="L1316">    }</span>

    /**
     * Gets estimated ECEF user velocity resolved around z axis.
     *
     * @return estimated ECEF velocity resolved around z axis.
     */
    public Speed getSpeedZ() {
<span class="fc" id="L1324">        return new Speed(vz, SpeedUnit.METERS_PER_SECOND);</span>
    }

    /**
     * Sets estimated ECEF user velocity resolved around z axis.
     *
     * @param vz estimated ECEF velocity resolved around z axis.
     */
    public void setSpeedZ(final Speed vz) {
<span class="fc" id="L1333">        this.vz = SpeedConverter.convert(vz.getValue().doubleValue(), vz.getUnit(), SpeedUnit.METERS_PER_SECOND);</span>
<span class="fc" id="L1334">    }</span>

    /**
     * Sets estimated ECEF user velocity.
     *
     * @param vx estimated ECEF velocity resolved around x axis.
     * @param vy estimated ECEF velocity resolved around y axis.
     * @param vz estimated ECEF velocity resolved around z axis.
     */
    public void setVelocityCoordinates(final Speed vx, final Speed vy, final Speed vz) {
<span class="fc" id="L1344">        setSpeedX(vx);</span>
<span class="fc" id="L1345">        setSpeedY(vy);</span>
<span class="fc" id="L1346">        setSpeedZ(vz);</span>
<span class="fc" id="L1347">    }</span>

    /**
     * Gets estimated ECEF user velocity.
     *
     * @param result instance where estimated ECEF user velocity will be stored.
     */
    public void getEcefVelocity(final ECEFVelocity result) {
<span class="fc" id="L1355">        result.setCoordinates(vx, vy, vz);</span>
<span class="fc" id="L1356">    }</span>

    /**
     * Gets estimated ECEF user velocity.
     *
     * @return estimated ECEF user velocity.
     */
    public ECEFVelocity getEcefVelocity() {
<span class="fc" id="L1364">        return new ECEFVelocity(vx, vy, vz);</span>
    }

    /**
     * Sets estimated ECEF user velocity.
     *
     * @param ecefVelocity estimated ECEF user velocity.
     */
    public void setEcefVelocity(final ECEFVelocity ecefVelocity) {
<span class="fc" id="L1373">        vx = ecefVelocity.getVx();</span>
<span class="fc" id="L1374">        vy = ecefVelocity.getVy();</span>
<span class="fc" id="L1375">        vz = ecefVelocity.getVz();</span>
<span class="fc" id="L1376">    }</span>

    /**
     * Gets x coordinate of estimated ECEF user position.
     *
     * @param result instance where x coordinate of estimated ECEF user position
     *               will be stored.
     */
    public void getDistanceX(final Distance result) {
<span class="fc" id="L1385">        result.setValue(x);</span>
<span class="fc" id="L1386">        result.setUnit(DistanceUnit.METER);</span>
<span class="fc" id="L1387">    }</span>

    /**
     * Gets x coordinate of estimated ECEF user position.
     *
     * @return x coordinate of estimated ECEF user position.
     */
    public Distance getDistanceX() {
<span class="fc" id="L1395">        return new Distance(x, DistanceUnit.METER);</span>
    }

    /**
     * Sets x coordinate of estimated ECEF user position.
     *
     * @param x x coordinate of estimated ECEF user position.
     */
    public void setDistanceX(final Distance x) {
<span class="fc" id="L1404">        this.x = DistanceConverter.convert(x.getValue().doubleValue(), x.getUnit(), DistanceUnit.METER);</span>
<span class="fc" id="L1405">    }</span>

    /**
     * Gets y coordinate of estimated ECEF user position.
     *
     * @param result instance where y coordinate of estimated ECEF user position
     *               will be stored.
     */
    public void getDistanceY(final Distance result) {
<span class="fc" id="L1414">        result.setValue(y);</span>
<span class="fc" id="L1415">        result.setUnit(DistanceUnit.METER);</span>
<span class="fc" id="L1416">    }</span>

    /**
     * Gets y coordinate of estimated ECEF user position.
     *
     * @return y coordinate of estimated ECEF user position.
     */
    public Distance getDistanceY() {
<span class="fc" id="L1424">        return new Distance(y, DistanceUnit.METER);</span>
    }

    /**
     * Sets y coordinate of estimated ECEF user position.
     *
     * @param y y coordinate of estimated ECEF user position.
     */
    public void setDistanceY(final Distance y) {
<span class="fc" id="L1433">        this.y = DistanceConverter.convert(y.getValue().doubleValue(), y.getUnit(), DistanceUnit.METER);</span>
<span class="fc" id="L1434">    }</span>

    /**
     * Gets z coordinate of estimated ECEF user position.
     *
     * @param result instance where z coordinate of estimated ECEF user position
     *               will be stored.
     */
    public void getDistanceZ(final Distance result) {
<span class="fc" id="L1443">        result.setValue(z);</span>
<span class="fc" id="L1444">        result.setUnit(DistanceUnit.METER);</span>
<span class="fc" id="L1445">    }</span>

    /**
     * Gets z coordinate of estimated ECEF user position.
     *
     * @return z coordinate of estimated ECEF user position.
     */
    public Distance getDistanceZ() {
<span class="fc" id="L1453">        return new Distance(z, DistanceUnit.METER);</span>
    }

    /**
     * Sets z coordinate of estimated ECEF user position.
     *
     * @param z z coordinate of estimated ECEF user position.
     */
    public void setDistanceZ(final Distance z) {
<span class="fc" id="L1462">        this.z = DistanceConverter.convert(z.getValue().doubleValue(), z.getUnit(), DistanceUnit.METER);</span>
<span class="fc" id="L1463">    }</span>

    /**
     * Sets coordinates of estimated ECEF user position.
     *
     * @param x x coordinate of estimated ECEF user position.
     * @param y y coordinate of estimated ECEF user position.
     * @param z z coordinate of estimated ECEF user position.
     */
    public void setPositionCoordinates(final Distance x, final Distance y, final Distance z) {
<span class="fc" id="L1473">        setDistanceX(x);</span>
<span class="fc" id="L1474">        setDistanceY(y);</span>
<span class="fc" id="L1475">        setDistanceZ(z);</span>
<span class="fc" id="L1476">    }</span>

    /**
     * Gets estimated ECEF user position expressed in meters (m).
     *
     * @param result instance where estimated ECEF user position expressed
     *               in meters (m) will be stored.
     */
    public void getPosition(final Point3D result) {
<span class="fc" id="L1485">        result.setInhomogeneousCoordinates(x, y, z);</span>
<span class="fc" id="L1486">    }</span>

    /**
     * Gets estimated ECEF user position expressed in meters (m).
     *
     * @return estimated ECEF user position expressed in meters (m).
     */
    public Point3D getPosition() {
<span class="fc" id="L1494">        return new InhomogeneousPoint3D(x, y, z);</span>
    }

    /**
     * Sets estimated ECEF user position expressed in meters (m).
     *
     * @param position estimated ECEF user position expressed in
     *                 meters (m).
     */
    public void setPosition(final Point3D position) {
<span class="fc" id="L1504">        x = position.getInhomX();</span>
<span class="fc" id="L1505">        y = position.getInhomY();</span>
<span class="fc" id="L1506">        z = position.getInhomZ();</span>
<span class="fc" id="L1507">    }</span>

    /**
     * Gets estimated ECEF user position.
     *
     * @param result instance where estimated ECEF user position
     *               will be stored.
     */
    public void getEcefPosition(final ECEFPosition result) {
<span class="fc" id="L1516">        result.setCoordinates(x, y, z);</span>
<span class="fc" id="L1517">    }</span>

    /**
     * Gets estimated ECEF user position.
     *
     * @return estimated ECEF user position.
     */
    public ECEFPosition getEcefPosition() {
<span class="fc" id="L1525">        return new ECEFPosition(x, y, z);</span>
    }

    /**
     * Sets estimated ECEF user position.
     *
     * @param ecefPosition estimated ECEF user position.
     */
    public void setEcefPosition(final ECEFPosition ecefPosition) {
<span class="fc" id="L1534">        x = ecefPosition.getX();</span>
<span class="fc" id="L1535">        y = ecefPosition.getY();</span>
<span class="fc" id="L1536">        z = ecefPosition.getZ();</span>
<span class="fc" id="L1537">    }</span>

    /**
     * Gets estimated ECEF user position and velocity.
     *
     * @param result instance where estimated ECEF user position and velocity
     *               will be stored.
     */
    public void getPositionAndVelocity(final ECEFPositionAndVelocity result) {
<span class="fc" id="L1546">        result.setPositionCoordinates(x, y, z);</span>
<span class="fc" id="L1547">        result.setVelocityCoordinates(vx, vy, vz);</span>
<span class="fc" id="L1548">    }</span>

    /**
     * Gets estimated ECEF user position and velocity.
     *
     * @return estimated ECEF user position and velocity.
     */
    public ECEFPositionAndVelocity getPositionAndVelocity() {
<span class="fc" id="L1556">        return new ECEFPositionAndVelocity(x, y, z, vx, vy, vz);</span>
    }

    /**
     * Sets estimated ECEF user position and velocity.
     *
     * @param positionAndVelocity estimated ECEF user position and velocity.
     */
    public void setPositionAndVelocity(final ECEFPositionAndVelocity positionAndVelocity) {
<span class="fc" id="L1565">        x = positionAndVelocity.getX();</span>
<span class="fc" id="L1566">        y = positionAndVelocity.getY();</span>
<span class="fc" id="L1567">        z = positionAndVelocity.getZ();</span>
<span class="fc" id="L1568">        vx = positionAndVelocity.getVx();</span>
<span class="fc" id="L1569">        vy = positionAndVelocity.getVy();</span>
<span class="fc" id="L1570">        vz = positionAndVelocity.getVz();</span>
<span class="fc" id="L1571">    }</span>

    /**
     * Gets body to ECEF frame containing coordinate transformation, position and
     * velocity.
     *
     * @param result instance where body to ECEF frame will be stored.
     * @return true if result was updated, false otherwise.
     */
    public boolean getFrame(final ECEFFrame result) {
<span class="fc bfc" id="L1581" title="All 2 branches covered.">        if (bodyToEcefCoordinateTransformationMatrix != null) {</span>
            try {
<span class="fc" id="L1583">                result.setCoordinateTransformation(getC());</span>
<span class="nc" id="L1584">            } catch (final InvalidSourceAndDestinationFrameTypeException | InvalidRotationMatrixException e) {</span>
<span class="nc" id="L1585">                return false;</span>
<span class="fc" id="L1586">            }</span>
<span class="fc" id="L1587">            result.setCoordinates(x, y, z);</span>
<span class="fc" id="L1588">            result.setVelocityCoordinates(vx, vy, vz);</span>
<span class="fc" id="L1589">            return true;</span>
        } else {
<span class="fc" id="L1591">            return false;</span>
        }
    }

    /**
     * Gets body to ECEF frame containing coordinate transformation, position and
     * velocity.
     *
     * @return body to ECEF frame.
     */
    public ECEFFrame getFrame() {
<span class="fc bfc" id="L1602" title="All 2 branches covered.">        if (bodyToEcefCoordinateTransformationMatrix != null) {</span>
            try {
<span class="fc" id="L1604">                return new ECEFFrame(x, y, z, vx, vy, vz, getC());</span>
<span class="nc" id="L1605">            } catch (final InvalidSourceAndDestinationFrameTypeException | InvalidRotationMatrixException e) {</span>
<span class="nc" id="L1606">                return null;</span>
            }
        } else {
<span class="fc" id="L1609">            return null;</span>
        }
    }

    /**
     * Sets body to ECEF frame containing coordinate transformation, position and
     * velocity.
     *
     * @param frame body to ECEF frame to be set.
     */
    public void setFrame(final ECEFFrame frame) {
<span class="fc" id="L1620">        x = frame.getX();</span>
<span class="fc" id="L1621">        y = frame.getY();</span>
<span class="fc" id="L1622">        z = frame.getZ();</span>

<span class="fc" id="L1624">        vx = frame.getVx();</span>
<span class="fc" id="L1625">        vy = frame.getVy();</span>
<span class="fc" id="L1626">        vz = frame.getVz();</span>

<span class="fc bfc" id="L1628" title="All 2 branches covered.">        if (bodyToEcefCoordinateTransformationMatrix != null) {</span>
<span class="fc" id="L1629">            frame.getCoordinateTransformationMatrix(bodyToEcefCoordinateTransformationMatrix);</span>
        } else {
<span class="fc" id="L1631">            bodyToEcefCoordinateTransformationMatrix = frame.getCoordinateTransformationMatrix();</span>
        }
<span class="fc" id="L1633">    }</span>

    /**
     * Gets estimated accelerometer bias resolved around x axis.
     *
     * @param result instance where estimated accelerometer bias resolved around
     *               x axis will be stored.
     */
    public void getAccelerationBiasXAsAcceleration(final Acceleration result) {
<span class="fc" id="L1642">        result.setValue(accelerationBiasX);</span>
<span class="fc" id="L1643">        result.setUnit(AccelerationUnit.METERS_PER_SQUARED_SECOND);</span>
<span class="fc" id="L1644">    }</span>

    /**
     * Gets estimated accelerometer bias resolved around x axis.
     *
     * @return estimated accelerometer bias resolved around x axis.
     */
    public Acceleration getAccelerationBiasXAsAcceleration() {
<span class="fc" id="L1652">        return new Acceleration(accelerationBiasX, AccelerationUnit.METERS_PER_SQUARED_SECOND);</span>
    }

    /**
     * Sets estimated accelerometer bias resolved around x axis.
     *
     * @param accelerationBiasX estimated accelerometer bias resolved
     *                          around x axis.
     */
    public void setAccelerationBiasX(final Acceleration accelerationBiasX) {
<span class="fc" id="L1662">        this.accelerationBiasX = AccelerationConverter.convert(accelerationBiasX.getValue().doubleValue(),</span>
<span class="fc" id="L1663">                accelerationBiasX.getUnit(), AccelerationUnit.METERS_PER_SQUARED_SECOND);</span>
<span class="fc" id="L1664">    }</span>

    /**
     * Gets estimated accelerometer bias resolved around y axis.
     *
     * @param result instance where estimated accelerometer bias resolved around
     *               y axis will be stored.
     */
    public void getAccelerationBiasYAsAcceleration(final Acceleration result) {
<span class="fc" id="L1673">        result.setValue(accelerationBiasY);</span>
<span class="fc" id="L1674">        result.setUnit(AccelerationUnit.METERS_PER_SQUARED_SECOND);</span>
<span class="fc" id="L1675">    }</span>

    /**
     * Gets estimated accelerometer bias resolved around y axis.
     *
     * @return estimated accelerometer bias resolved around y axis.
     */
    public Acceleration getAccelerationBiasYAsAcceleration() {
<span class="fc" id="L1683">        return new Acceleration(accelerationBiasY, AccelerationUnit.METERS_PER_SQUARED_SECOND);</span>
    }

    /**
     * Sets estimated accelerometer bias resolved around y axis.
     *
     * @param accelerationBiasY estimated accelerometer bias resolved
     *                          around y axis.
     */
    public void setAccelerationBiasY(final Acceleration accelerationBiasY) {
<span class="fc" id="L1693">        this.accelerationBiasY = AccelerationConverter.convert(accelerationBiasY.getValue().doubleValue(),</span>
<span class="fc" id="L1694">                accelerationBiasY.getUnit(), AccelerationUnit.METERS_PER_SQUARED_SECOND);</span>
<span class="fc" id="L1695">    }</span>

    /**
     * Gets estimated accelerometer bias resolved around z axis.
     *
     * @param result instance where estimated accelerometer bias resolved around
     *               z axis will be stored.
     */
    public void getAccelerationBiasZAsAcceleration(final Acceleration result) {
<span class="fc" id="L1704">        result.setValue(accelerationBiasZ);</span>
<span class="fc" id="L1705">        result.setUnit(AccelerationUnit.METERS_PER_SQUARED_SECOND);</span>
<span class="fc" id="L1706">    }</span>

    /**
     * Gets estimated accelerometer bias resolved around z axis.
     *
     * @return estimated accelerometer bias resolved around z axis.
     */
    public Acceleration getAccelerationBiasZAsAcceleration() {
<span class="fc" id="L1714">        return new Acceleration(accelerationBiasZ, AccelerationUnit.METERS_PER_SQUARED_SECOND);</span>
    }

    /**
     * Sets estimated accelerometer bias resolved around z axis.
     *
     * @param accelerationBiasZ estimated accelerometer bias resolved
     *                          around z axis.
     */
    public void setAccelerationBiasZ(final Acceleration accelerationBiasZ) {
<span class="fc" id="L1724">        this.accelerationBiasZ = AccelerationConverter.convert(accelerationBiasZ.getValue().doubleValue(),</span>
<span class="fc" id="L1725">                accelerationBiasZ.getUnit(), AccelerationUnit.METERS_PER_SQUARED_SECOND);</span>
<span class="fc" id="L1726">    }</span>

    /**
     * Sets estimated accelerometer bias coordinates.
     *
     * @param accelerationBiasX estimated accelerometer bias resolved around x axis.
     * @param accelerationBiasY estimated accelerometer bias resolved around y axis.
     * @param accelerationBiasZ estimated accelerometer bias resolved around z axis.
     */
    public void setAccelerationBiasCoordinates(
            final Acceleration accelerationBiasX, final Acceleration accelerationBiasY,
            final Acceleration accelerationBiasZ) {
<span class="fc" id="L1738">        setAccelerationBiasX(accelerationBiasX);</span>
<span class="fc" id="L1739">        setAccelerationBiasY(accelerationBiasY);</span>
<span class="fc" id="L1740">        setAccelerationBiasZ(accelerationBiasZ);</span>
<span class="fc" id="L1741">    }</span>

    /**
     * Gets estimated gyroscope bias resolved around x axis.
     *
     * @param result instance where estimated gyroscope bias resolved around x axis will
     *               be stored.
     */
    public void getAngularSpeedGyroBiasX(final AngularSpeed result) {
<span class="fc" id="L1750">        result.setValue(gyroBiasX);</span>
<span class="fc" id="L1751">        result.setUnit(AngularSpeedUnit.RADIANS_PER_SECOND);</span>
<span class="fc" id="L1752">    }</span>

    /**
     * Gets estimated gyroscope bias resolved around x axis.
     *
     * @return estimated gyroscope bias resolved around x axis.
     */
    public AngularSpeed getAngularSpeedGyroBiasX() {
<span class="fc" id="L1760">        return new AngularSpeed(gyroBiasX, AngularSpeedUnit.RADIANS_PER_SECOND);</span>
    }

    /**
     * Sets estimated gyroscope bias resolved around x axis.
     *
     * @param gyroBiasX estimated gyroscope bias resolved around x axis.
     */
    public void setGyroBiasX(final AngularSpeed gyroBiasX) {
<span class="fc" id="L1769">        this.gyroBiasX = AngularSpeedConverter.convert(gyroBiasX.getValue().doubleValue(), gyroBiasX.getUnit(),</span>
                AngularSpeedUnit.RADIANS_PER_SECOND);
<span class="fc" id="L1771">    }</span>

    /**
     * Gets estimated gyroscope bias resolved around y axis.
     *
     * @param result instance where estimated gyroscope bias resolved around y axis will
     *               be stored.
     */
    public void getAngularSpeedGyroBiasY(final AngularSpeed result) {
<span class="fc" id="L1780">        result.setValue(gyroBiasY);</span>
<span class="fc" id="L1781">        result.setUnit(AngularSpeedUnit.RADIANS_PER_SECOND);</span>
<span class="fc" id="L1782">    }</span>

    /**
     * Gets estimated gyroscope bias resolved around y axis.
     *
     * @return estimated gyroscope bias resolved around y axis.
     */
    public AngularSpeed getAngularSpeedGyroBiasY() {
<span class="fc" id="L1790">        return new AngularSpeed(gyroBiasY, AngularSpeedUnit.RADIANS_PER_SECOND);</span>
    }

    /**
     * Sets estimated gyroscope bias resolved around y axis.
     *
     * @param gyroBiasY estimated gyroscope bias resolved around y axis.
     */
    public void setGyroBiasY(final AngularSpeed gyroBiasY) {
<span class="fc" id="L1799">        this.gyroBiasY = AngularSpeedConverter.convert(gyroBiasY.getValue().doubleValue(), gyroBiasY.getUnit(),</span>
                AngularSpeedUnit.RADIANS_PER_SECOND);
<span class="fc" id="L1801">    }</span>

    /**
     * Gets estimated gyroscope bias resolved around z axis.
     *
     * @param result instance where estimated gyroscope bias resolved around z axis will
     *               be stored.
     */
    public void getAngularSpeedGyroBiasZ(final AngularSpeed result) {
<span class="fc" id="L1810">        result.setValue(gyroBiasZ);</span>
<span class="fc" id="L1811">        result.setUnit(AngularSpeedUnit.RADIANS_PER_SECOND);</span>
<span class="fc" id="L1812">    }</span>

    /**
     * Gets estimated gyroscope bias resolved around z axis.
     *
     * @return estimated gyroscope bias resolved around z axis.
     */
    public AngularSpeed getAngularSpeedGyroBiasZ() {
<span class="fc" id="L1820">        return new AngularSpeed(gyroBiasZ, AngularSpeedUnit.RADIANS_PER_SECOND);</span>
    }

    /**
     * Sets estimated gyroscope bias resolved around z axis.
     *
     * @param gyroBiasZ estimated gyroscope bias resolved around z axis.
     */
    public void setGyroBiasZ(final AngularSpeed gyroBiasZ) {
<span class="fc" id="L1829">        this.gyroBiasZ = AngularSpeedConverter.convert(gyroBiasZ.getValue().doubleValue(), gyroBiasZ.getUnit(),</span>
                AngularSpeedUnit.RADIANS_PER_SECOND);
<span class="fc" id="L1831">    }</span>

    /**
     * Sets estimated gyroscope bias coordinates.
     *
     * @param gyroBiasX estimated gyroscope bias resolved around x axis.
     * @param gyroBiasY estimated gyroscope bias resolved around y axis.
     * @param gyroBiasZ estimated gyroscope bias resolved around z axis.
     */
    public void setGyroBiasCoordinates(
            final AngularSpeed gyroBiasX, final AngularSpeed gyroBiasY, final AngularSpeed gyroBiasZ) {
<span class="fc" id="L1842">        setGyroBiasX(gyroBiasX);</span>
<span class="fc" id="L1843">        setGyroBiasY(gyroBiasY);</span>
<span class="fc" id="L1844">        setGyroBiasZ(gyroBiasZ);</span>
<span class="fc" id="L1845">    }</span>

    /**
     * Copies this instance data into provided instance.
     *
     * @param output destination instance where data will be copied to.
     */
    public void copyTo(final INSLooselyCoupledKalmanState output) {
<span class="fc" id="L1853">        output.copyFrom(this);</span>
<span class="fc" id="L1854">    }</span>

    /**
     * Copies data of provided instance into this instance.
     *
     * @param input instance to copy data from.
     */
    public void copyFrom(final INSLooselyCoupledKalmanState input) {
        // copy coordinate transformation matrix
<span class="fc bfc" id="L1863" title="All 2 branches covered.">        if (input.bodyToEcefCoordinateTransformationMatrix == null) {</span>
<span class="fc" id="L1864">            bodyToEcefCoordinateTransformationMatrix = null;</span>
        } else {
<span class="fc bfc" id="L1866" title="All 2 branches covered.">            if (bodyToEcefCoordinateTransformationMatrix == null) {</span>
<span class="fc" id="L1867">                bodyToEcefCoordinateTransformationMatrix = new Matrix(input.bodyToEcefCoordinateTransformationMatrix);</span>
            } else {
<span class="fc" id="L1869">                bodyToEcefCoordinateTransformationMatrix.copyFrom(input.bodyToEcefCoordinateTransformationMatrix);</span>
            }
        }

<span class="fc" id="L1873">        vx = input.vx;</span>
<span class="fc" id="L1874">        vy = input.vy;</span>
<span class="fc" id="L1875">        vz = input.vz;</span>

<span class="fc" id="L1877">        x = input.x;</span>
<span class="fc" id="L1878">        y = input.y;</span>
<span class="fc" id="L1879">        z = input.z;</span>

<span class="fc" id="L1881">        accelerationBiasX = input.accelerationBiasX;</span>
<span class="fc" id="L1882">        accelerationBiasY = input.accelerationBiasY;</span>
<span class="fc" id="L1883">        accelerationBiasZ = input.accelerationBiasZ;</span>

<span class="fc" id="L1885">        gyroBiasX = input.gyroBiasX;</span>
<span class="fc" id="L1886">        gyroBiasY = input.gyroBiasY;</span>
<span class="fc" id="L1887">        gyroBiasZ = input.gyroBiasZ;</span>

        // copy covariance
<span class="fc bfc" id="L1890" title="All 2 branches covered.">        if (input.covariance == null) {</span>
<span class="fc" id="L1891">            covariance = null;</span>
        } else {
<span class="fc bfc" id="L1893" title="All 2 branches covered.">            if (covariance == null) {</span>
<span class="fc" id="L1894">                covariance = new Matrix(input.covariance);</span>
            } else {
<span class="fc" id="L1896">                covariance.copyFrom(input.covariance);</span>
            }
        }
<span class="fc" id="L1899">    }</span>

    /**
     * Computes and returns hash code for this instance. Hash codes are almost unique
     * values that are useful for fast classification and storage of objects in collections.
     *
     * @return Hash code.
     */
    @Override
    public int hashCode() {
<span class="fc" id="L1909">        return Objects.hash(bodyToEcefCoordinateTransformationMatrix, vx, vy, vz, x, y, z,</span>
<span class="fc" id="L1910">                accelerationBiasX, accelerationBiasY, accelerationBiasZ, gyroBiasX, gyroBiasY, gyroBiasZ,</span>
                covariance);
    }

    /**
     * Checks if provided object is a INSLooselyCoupledKalmanState having exactly the same
     * contents as this instance.
     *
     * @param obj Object to be compared.
     * @return true if both objects are considered to be equal, false otherwise.
     */
    @Override
    public boolean equals(final Object obj) {
<span class="fc bfc" id="L1923" title="All 2 branches covered.">        if (this == obj) {</span>
<span class="fc" id="L1924">            return true;</span>
        }
<span class="pc bpc" id="L1926" title="2 of 4 branches missed.">        if (obj == null || getClass() != obj.getClass()) {</span>
<span class="nc" id="L1927">            return false;</span>
        }
<span class="fc" id="L1929">        final var other = (INSLooselyCoupledKalmanState) obj;</span>
<span class="fc" id="L1930">        return equals(other);</span>
    }

    /**
     * Checks if provided instance has exactly the same contents as this instance.
     *
     * @param other instance to be compared.
     * @return true if both instances are considered to be equal, false otherwise.
     */
    public boolean equals(final INSLooselyCoupledKalmanState other) {
<span class="fc" id="L1940">        return equals(other, 0.0);</span>
    }

    /**
     * Checks if provided instance has contents similar to this instance up to provided
     * threshold value.
     *
     * @param other     instance to be compared.
     * @param threshold maximum difference allowed for values.
     * @return true if both instances are considered to be equal (up to provided threshold),
     * false otherwise.
     */
    public boolean equals(final INSLooselyCoupledKalmanState other, final double threshold) {
<span class="fc bfc" id="L1953" title="All 2 branches covered.">        if (other == null) {</span>
<span class="fc" id="L1954">            return false;</span>
        }

<span class="fc bfc" id="L1957" title="All 2 branches covered.">        return Math.abs(vx - other.vx) &lt;= threshold</span>
<span class="pc bpc" id="L1958" title="1 of 2 branches missed.">                &amp;&amp; Math.abs(vy - other.vy) &lt;= threshold</span>
<span class="pc bpc" id="L1959" title="1 of 2 branches missed.">                &amp;&amp; Math.abs(vz - other.vz) &lt;= threshold</span>
<span class="pc bpc" id="L1960" title="1 of 2 branches missed.">                &amp;&amp; Math.abs(x - other.x) &lt;= threshold</span>
<span class="pc bpc" id="L1961" title="1 of 2 branches missed.">                &amp;&amp; Math.abs(y - other.y) &lt;= threshold</span>
<span class="pc bpc" id="L1962" title="1 of 2 branches missed.">                &amp;&amp; Math.abs(z - other.z) &lt;= threshold</span>
<span class="pc bpc" id="L1963" title="1 of 2 branches missed.">                &amp;&amp; Math.abs(accelerationBiasX - other.accelerationBiasX) &lt;= threshold</span>
<span class="pc bpc" id="L1964" title="1 of 2 branches missed.">                &amp;&amp; Math.abs(accelerationBiasY - other.accelerationBiasY) &lt;= threshold</span>
<span class="pc bpc" id="L1965" title="1 of 2 branches missed.">                &amp;&amp; Math.abs(accelerationBiasZ - other.accelerationBiasZ) &lt;= threshold</span>
<span class="pc bpc" id="L1966" title="1 of 2 branches missed.">                &amp;&amp; Math.abs(gyroBiasX - other.gyroBiasX) &lt;= threshold</span>
<span class="pc bpc" id="L1967" title="1 of 2 branches missed.">                &amp;&amp; Math.abs(gyroBiasY - other.gyroBiasY) &lt;= threshold</span>
<span class="pc bpc" id="L1968" title="2 of 4 branches missed.">                &amp;&amp; Math.abs(gyroBiasZ - other.gyroBiasZ) &lt;= threshold</span>
                &amp;&amp; other.bodyToEcefCoordinateTransformationMatrix != null
<span class="pc bpc" id="L1970" title="2 of 4 branches missed.">                &amp;&amp; other.bodyToEcefCoordinateTransformationMatrix.equals(bodyToEcefCoordinateTransformationMatrix,</span>
<span class="fc bfc" id="L1971" title="All 2 branches covered.">                threshold) &amp;&amp; other.covariance != null &amp;&amp; other.covariance.equals(covariance, threshold);</span>
    }

    /**
     * Makes a copy of this instance.
     *
     * @return a copy of this instance.
     * @throws CloneNotSupportedException if clone fails for some reason.
     */
    @Override
    protected Object clone() throws CloneNotSupportedException {
<span class="fc" id="L1982">        final var result = (INSLooselyCoupledKalmanState) super.clone();</span>
<span class="fc" id="L1983">        copyTo(result);</span>
<span class="fc" id="L1984">        return result;</span>
    }

    /**
     * Fixes current body to ECEF coordinate transformation matrix to ensure it
     * remains orthonormal and valid to build a Coordinate transformation or
     * a rotation.
     *
     * @return a fixed rotation matrix.
     * @throws AlgebraException if there are numerical instabilities.
     */
    private Matrix fixRotationMatrix() throws AlgebraException {
<span class="fc" id="L1996">        final var decomposer = new SingularValueDecomposer(bodyToEcefCoordinateTransformationMatrix);</span>
<span class="fc" id="L1997">        decomposer.decompose();</span>

        // fixed = u * w * v'
<span class="fc" id="L2000">        final var u = decomposer.getU();</span>
        // make sure all singular values are 1
<span class="fc" id="L2002">        final var w = Matrix.identity(Rotation3D.INHOM_COORDS, Rotation3D.INHOM_COORDS);</span>
<span class="fc" id="L2003">        final var v = decomposer.getV();</span>

        // fixed = u * w * v'
<span class="fc" id="L2006">        u.multiply(w);</span>
<span class="fc" id="L2007">        v.transpose();</span>
<span class="fc" id="L2008">        u.multiply(v);</span>

<span class="fc" id="L2010">        return u;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>