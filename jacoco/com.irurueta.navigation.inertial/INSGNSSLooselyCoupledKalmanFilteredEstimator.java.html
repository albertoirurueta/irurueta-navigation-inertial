<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>INSGNSSLooselyCoupledKalmanFilteredEstimator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-navigation-inertial</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.navigation.inertial</a> &gt; <span class="el_source">INSGNSSLooselyCoupledKalmanFilteredEstimator.java</span></div><h1>INSGNSSLooselyCoupledKalmanFilteredEstimator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2020 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.navigation.inertial;

import com.irurueta.navigation.LockedException;
import com.irurueta.navigation.NotReadyException;
import com.irurueta.navigation.frames.CoordinateTransformation;
import com.irurueta.navigation.frames.ECEFFrame;
import com.irurueta.navigation.frames.InvalidSourceAndDestinationFrameTypeException;
import com.irurueta.navigation.geodesic.Constants;
import com.irurueta.navigation.gnss.GNSSEstimation;
import com.irurueta.navigation.gnss.GNSSException;
import com.irurueta.navigation.gnss.GNSSLeastSquaresPositionAndVelocityEstimator;
import com.irurueta.navigation.gnss.GNSSMeasurement;
import com.irurueta.units.Time;
import com.irurueta.units.TimeConverter;
import com.irurueta.units.TimeUnit;

import java.util.ArrayList;
import java.util.Collection;

/**
 * Calculates position, velocity, attitude and IMU biases using a GNSS unweighted
 * iterated least squares estimator along with an INS loosely coupled Kalman filter
 * to take into account inertial measurements to smooth results.
 * This implementation is based on the equations defined in &quot;Principles of GNSS, Inertial, and Multisensor
 * Integrated Navigation Systems, Second Edition&quot; and on the companion software available at:
 * &lt;a href=&quot;https://github.com/ymjdz/MATLAB-Codes/blob/master/Loosely_coupled_INS_GNSS.m&quot;&gt;
 *     https://github.com/ymjdz/MATLAB-Codes/blob/master/Loosely_coupled_INS_GNSS.m
 * &lt;/a&gt;
 */
@SuppressWarnings(&quot;DuplicatedCode&quot;)
public class INSGNSSLooselyCoupledKalmanFilteredEstimator {

    /**
     * Internal estimator to compute least squares solution for GNSS measurements.
     */
<span class="fc" id="L51">    private final GNSSLeastSquaresPositionAndVelocityEstimator lsEstimator</span>
            = new GNSSLeastSquaresPositionAndVelocityEstimator();

    /**
     * Internal INS estimator to update kinematic measures and propagate
     * estimated state.
     */
<span class="fc" id="L58">    private final INSLooselyCoupledKalmanFilteredEstimator insEstimator =</span>
<span class="fc" id="L59">            new INSLooselyCoupledKalmanFilteredEstimator(new INSLooselyCoupledKalmanFilteredEstimatorListener() {</span>
                @Override
                public void onUpdateStart(final INSLooselyCoupledKalmanFilteredEstimator estimator) {
<span class="pc bpc" id="L62" title="1 of 2 branches missed.">                    if (listener != null) {</span>
<span class="fc" id="L63">                        listener.onUpdateBodyKinematicsStart(</span>
                                INSGNSSLooselyCoupledKalmanFilteredEstimator.this);
                    }
<span class="fc" id="L66">                }</span>

                @Override
                public void onUpdateEnd(final INSLooselyCoupledKalmanFilteredEstimator estimator) {
<span class="pc bpc" id="L70" title="1 of 2 branches missed.">                    if (listener != null) {</span>
<span class="fc" id="L71">                        listener.onUpdateBodyKinematicsEnd(</span>
                                INSGNSSLooselyCoupledKalmanFilteredEstimator.this);
                    }
<span class="fc" id="L74">                }</span>

                @Override
                public void onPropagateStart(final INSLooselyCoupledKalmanFilteredEstimator estimator) {
<span class="pc bpc" id="L78" title="1 of 2 branches missed.">                    if (listener != null) {</span>
<span class="fc" id="L79">                        listener.onPropagateStart(INSGNSSLooselyCoupledKalmanFilteredEstimator.this);</span>
                    }
<span class="fc" id="L81">                }</span>

                @Override
                public void onPropagateEnd(final INSLooselyCoupledKalmanFilteredEstimator estimator) {
<span class="pc bpc" id="L85" title="1 of 2 branches missed.">                    if (listener != null) {</span>
<span class="fc" id="L86">                        listener.onPropagateEnd(INSGNSSLooselyCoupledKalmanFilteredEstimator.this);</span>
                    }
<span class="fc" id="L88">                }</span>

                @Override
                public void onReset(final INSLooselyCoupledKalmanFilteredEstimator estimator) {
                    // no action needed
<span class="fc" id="L93">                }</span>
            });

    /**
     * Listener to notify events raised by this instance.
     */
    private INSGNSSLooselyCoupledKalmanFilteredEstimatorListener listener;

    /**
     * GNSS measurements of a collection of satellites.
     */
    private Collection&lt;GNSSMeasurement&gt; measurements;

    /**
     * Last provided user kinematics containing applied specific force
     * and angular rates resolved in body axes.
     */
    private BodyKinematics kinematics;

    /**
     * Contains last provided user kinematics minus currently estimated bias
     * for acceleration and angular rate values.
     */
    private BodyKinematics correctedKinematics;

    /**
     * Internally keeps user position, velocity and attitude.
     */
    private ECEFFrame frame;

    /**
     * Current Kalman filter state containing current INS estimation along with
     * Kalman filter covariance error matrix.
     */
    private INSLooselyCoupledKalmanState state;

    /**
     * Current estimation containing user ECEF position, user ECEF velocity, clock offset
     * and clock drift.
     */
    private GNSSEstimation estimation;

    /**
     * Indicates whether this estimator is running or not.
     */
    private boolean running;

    /**
     * Constructor.
     */
<span class="fc" id="L143">    public INSGNSSLooselyCoupledKalmanFilteredEstimator() {</span>
<span class="fc" id="L144">    }</span>

    /**
     * Constructor.
     *
     * @param config INS Kalman filter configuration parameters (usually obtained
     *               through calibration).
     */
<span class="fc" id="L152">    public INSGNSSLooselyCoupledKalmanFilteredEstimator(final INSLooselyCoupledKalmanConfig config) {</span>
        try {
<span class="fc" id="L154">            insEstimator.setConfig(config);</span>
<span class="nc" id="L155">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L157">        }</span>
<span class="fc" id="L158">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
<span class="fc" id="L167">    public INSGNSSLooselyCoupledKalmanFilteredEstimator(final double epochInterval) {</span>
        try {
<span class="fc" id="L169">            insEstimator.setEpochInterval(epochInterval);</span>
<span class="nc" id="L170">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L172">        }</span>
<span class="fc" id="L173">    }</span>

    /**
     * Constructor.
     *
     * @param listener listener to notify events raised by this instance.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
<span class="fc" id="L181">            final INSGNSSLooselyCoupledKalmanFilteredEstimatorListener listener) {</span>
<span class="fc" id="L182">        this.listener = listener;</span>
<span class="fc" id="L183">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS loosely coupled Kalman filter configuration parameters
     *                      (usually obtained through calibration).
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config, final double epochInterval) {
<span class="fc" id="L196">        this(epochInterval);</span>
        try {
<span class="fc" id="L198">            insEstimator.setConfig(config);</span>
<span class="nc" id="L199">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L201">        }</span>
<span class="fc" id="L202">    }</span>

    /**
     * Constructor.
     *
     * @param config   INS loosely coupled Kalman filter configuration parameters
     *                 (usually obtained through calibration).
     * @param listener listener to notify events raised by this instance.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config,
            final INSGNSSLooselyCoupledKalmanFilteredEstimatorListener listener) {
<span class="fc" id="L214">        this(config);</span>
<span class="fc" id="L215">        this.listener = listener;</span>
<span class="fc" id="L216">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final double epochInterval, final INSGNSSLooselyCoupledKalmanFilteredEstimatorListener listener) {
<span class="fc" id="L228">        this(epochInterval);</span>
<span class="fc" id="L229">        this.listener = listener;</span>
<span class="fc" id="L230">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS loosely coupled Kalman filter configuration parameters
     *                      (usually obtained through calibration).
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config, final double epochInterval,
            final INSGNSSLooselyCoupledKalmanFilteredEstimatorListener listener) {
<span class="fc" id="L245">        this(config, epochInterval);</span>
<span class="fc" id="L246">        this.listener = listener;</span>
<span class="fc" id="L247">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval between consecutive
     *                      propagations or measurements.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(final Time epochInterval) {
<span class="fc" id="L257">        this(TimeConverter.convert(epochInterval.getValue().doubleValue(), epochInterval.getUnit(), TimeUnit.SECOND));</span>
<span class="fc" id="L258">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS loosely coupled Kalman filter configuration parameters
     *                      (usually obtained through calibration).
     * @param epochInterval minimum epoch interval between consecutive propagations
     *                      or measurements.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config, final Time epochInterval) {
<span class="fc" id="L271">        this(config, TimeConverter.convert(epochInterval.getValue().doubleValue(), epochInterval.getUnit(),</span>
                TimeUnit.SECOND));
<span class="fc" id="L273">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval between consecutive
     *                      propagations or measurements.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final Time epochInterval, final INSGNSSLooselyCoupledKalmanFilteredEstimatorListener listener) {
<span class="fc" id="L285">        this(epochInterval);</span>
<span class="fc" id="L286">        this.listener = listener;</span>
<span class="fc" id="L287">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS loosely coupled Kalman filter configuration parameters
     *                      (usually obtained through calibration).
     * @param epochInterval minimum epoch interval between consecutive
     *                      propagations or measurements.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config, final Time epochInterval,
            final INSGNSSLooselyCoupledKalmanFilteredEstimatorListener listener) {
<span class="fc" id="L302">        this(config, epochInterval);</span>
<span class="fc" id="L303">        this.listener = listener;</span>
<span class="fc" id="L304">    }</span>

    /**
     * Constructor.
     *
     * @param c body-to-ECEF coordinate transformation defining the initial body
     *          attitude.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(final CoordinateTransformation c)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L316">        this();</span>
        try {
<span class="fc" id="L318">            setCoordinateTransformation(c);</span>
<span class="nc" id="L319">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L321">        }</span>
<span class="fc" id="L322">    }</span>

    /**
     * Constructor.
     *
     * @param config INS loosely Kalman filter configuration parameters (usually obtained
     *               through calibration).
     * @param c      body-to-ECEF coordinate transformation defining the initial body
     *               attitude.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config, final CoordinateTransformation c)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L337">        this(c);</span>
        try {
<span class="fc" id="L339">            insEstimator.setConfig(config);</span>
<span class="nc" id="L340">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L342">        }</span>
<span class="fc" id="L343">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @param c             body-to-ECEF coordinate transformation defining the initial body
     *                      attitude.
     * @throws IllegalArgumentException                      if provided epoch interval
     *                                                       is negative.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final double epochInterval, final CoordinateTransformation c)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L360">        this(epochInterval);</span>
        try {
<span class="fc" id="L362">            setCoordinateTransformation(c);</span>
<span class="nc" id="L363">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L365">        }</span>
<span class="fc" id="L366">    }</span>

    /**
     * Constructor.
     *
     * @param c        body-to-ECEF coordinate transformation defining the initial body
     *                 attitude.
     * @param listener listener to notify events raised by this instance.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final CoordinateTransformation c,
            final INSGNSSLooselyCoupledKalmanFilteredEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L381">        this(c);</span>
<span class="fc" id="L382">        this.listener = listener;</span>
<span class="fc" id="L383">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS loosely coupled Kalman filter configuration
     *                      parameters (usually obtained through calibration).
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @param c             body-to-ECEF coordinate transformation defining the initial body
     *                      attitude.
     * @throws IllegalArgumentException                      if provided epoch interval
     *                                                       is negative.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config, final double epochInterval,
            final CoordinateTransformation c) throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L402">        this(config, epochInterval);</span>
        try {
<span class="fc" id="L404">            setCoordinateTransformation(c);</span>
<span class="nc" id="L405">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L407">        }</span>
<span class="fc" id="L408">    }</span>

    /**
     * Constructor.
     *
     * @param config   INS loosely coupled Kalman filter configuration parameters
     *                 (usually obtained through calibration).
     * @param c        body-to-ECEF coordinate transformation defining the initial body
     *                 attitude.
     * @param listener listener to notify events raised by this instance.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config, final CoordinateTransformation c,
            final INSGNSSLooselyCoupledKalmanFilteredEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L425">        this(config, listener);</span>
        try {
<span class="fc" id="L427">            setCoordinateTransformation(c);</span>
<span class="nc" id="L428">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L430">        }</span>
<span class="fc" id="L431">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @param c             body-to-ECEF coordinate transformation defining the initial
     *                      body attitude.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException                      if provided epoch interval
     *                                                       is negative.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final double epochInterval, final CoordinateTransformation c,
            final INSGNSSLooselyCoupledKalmanFilteredEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L450">        this(epochInterval, listener);</span>
        try {
<span class="fc" id="L452">            setCoordinateTransformation(c);</span>
<span class="nc" id="L453">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L455">        }</span>
<span class="fc" id="L456">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS loosely coupled Kalman filter configuration
     *                      parameters (usually obtained through calibration).
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @param c             body-to-ECEF coordinate transformation defining the initial
     *                      body attitude.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException                      if provided epoch interval
     *                                                       is negative.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config, final double epochInterval,
            final CoordinateTransformation c, final INSGNSSLooselyCoupledKalmanFilteredEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L477">        this(config, epochInterval, listener);</span>
        try {
<span class="fc" id="L479">            setCoordinateTransformation(c);</span>
<span class="nc" id="L480">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L482">        }</span>
<span class="fc" id="L483">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval between consecutive propagations
     *                      or measurements.
     * @param c             body-to-ECEF coordinate transformation defining the initial
     *                      body attitude.
     * @throws IllegalArgumentException                      if provided epoch interval
     *                                                       is negative.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final Time epochInterval, final CoordinateTransformation c)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L500">        this(epochInterval);</span>
        try {
<span class="fc" id="L502">            setCoordinateTransformation(c);</span>
<span class="nc" id="L503">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L505">        }</span>
<span class="fc" id="L506">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS loosely coupled Kalman filter configuration
     *                      parameters (usually obtained through calibration).
     * @param epochInterval minimum epoch interval between consecutive
     *                      propagations or measurements.
     * @param c             body-to-ECEF coordinate transformation defining the
     *                      initial body attitude.
     * @throws IllegalArgumentException                      if provided epoch interval
     *                                                       is negative.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config, final Time epochInterval, final CoordinateTransformation c)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L525">        this(config, epochInterval);</span>
        try {
<span class="fc" id="L527">            setCoordinateTransformation(c);</span>
<span class="nc" id="L528">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L530">        }</span>
<span class="fc" id="L531">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval between consecutive propagations
     *                      or measurements.
     * @param c             body-to-ECEF coordinate transformation defining the initial
     *                      body attitude.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException                      if provided epoch interval
     *                                                       is negative.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final Time epochInterval, final CoordinateTransformation c,
            final INSGNSSLooselyCoupledKalmanFilteredEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L550">        this(epochInterval, listener);</span>
        try {
<span class="fc" id="L552">            setCoordinateTransformation(c);</span>
<span class="nc" id="L553">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L555">        }</span>
<span class="fc" id="L556">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS loosely coupled Kalman filter configuration parameters
     *                      (usually obtained through calibration).
     * @param epochInterval minimum epoch interval between consecutive
     *                      propagations or measurements.
     * @param c             body-to-ECEF coordinate transformation defining the initial
     *                      body attitude.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException                      if provided epoch interval
     *                                                       is negative.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config, final Time epochInterval, final CoordinateTransformation c,
            final INSGNSSLooselyCoupledKalmanFilteredEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L577">        this(config, epochInterval, listener);</span>
        try {
<span class="fc" id="L579">            setCoordinateTransformation(c);</span>
<span class="nc" id="L580">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L582">        }</span>
<span class="fc" id="L583">    }</span>

    /**
     * Constructor.
     *
     * @param initialConfig initial INS loosely coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(final INSLooselyCoupledKalmanInitializerConfig initialConfig) {
<span class="fc" id="L592">        this();</span>
        try {
<span class="fc" id="L594">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L595">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L597">        }</span>
<span class="fc" id="L598">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS loosely Kalman filter configuration parameters
     *                      (usually obtained through calibration).
     * @param initialConfig initial INS loosely coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config, final INSLooselyCoupledKalmanInitializerConfig initialConfig) {
<span class="fc" id="L610">        this(config);</span>
        try {
<span class="fc" id="L612">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L613">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L615">        }</span>
<span class="fc" id="L616">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @param initialConfig initial INS loosely coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final double epochInterval, final INSLooselyCoupledKalmanInitializerConfig initialConfig) {
<span class="fc" id="L629">        this(epochInterval);</span>
        try {
<span class="fc" id="L631">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L632">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L634">        }</span>
<span class="fc" id="L635">    }</span>

    /**
     * Constructor.
     *
     * @param initialConfig initial INS loosely coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @param listener      listener to notify events raised by this instance.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanInitializerConfig initialConfig,
            final INSGNSSLooselyCoupledKalmanFilteredEstimatorListener listener) {
<span class="fc" id="L647">        this(initialConfig);</span>
<span class="fc" id="L648">        this.listener = listener;</span>
<span class="fc" id="L649">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS loosely coupled Kalman filter configuration parameters
     *                      (usually obtained through calibration).
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @param initialConfig initial INS loosely coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config, final double epochInterval,
            final INSLooselyCoupledKalmanInitializerConfig initialConfig) {
<span class="fc" id="L665">        this(config, epochInterval);</span>
        try {
<span class="fc" id="L667">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L668">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L670">        }</span>
<span class="fc" id="L671">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS loosely coupled Kalman filter configuration parameters
     *                      (usually obtained through calibration).
     * @param initialConfig initial INS loosely coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @param listener      listener to notify events raised by this instance.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config, final INSLooselyCoupledKalmanInitializerConfig initialConfig,
            final INSGNSSLooselyCoupledKalmanFilteredEstimatorListener listener) {
<span class="fc" id="L685">        this(config, listener);</span>
        try {
<span class="fc" id="L687">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L688">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L690">        }</span>
<span class="fc" id="L691">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @param initialConfig initial INS loosely coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final double epochInterval, final INSLooselyCoupledKalmanInitializerConfig initialConfig,
            final INSGNSSLooselyCoupledKalmanFilteredEstimatorListener listener) {
<span class="fc" id="L706">        this(epochInterval, listener);</span>
        try {
<span class="fc" id="L708">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L709">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L711">        }</span>
<span class="fc" id="L712">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS loosely coupled Kalman filter configuration parameters
     *                      (usually obtained through calibration).
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @param initialConfig initial INS loosely coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config, final double epochInterval,
            final INSLooselyCoupledKalmanInitializerConfig initialConfig,
            final INSGNSSLooselyCoupledKalmanFilteredEstimatorListener listener) {
<span class="fc" id="L730">        this(config, epochInterval, listener);</span>
        try {
<span class="fc" id="L732">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L733">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L735">        }</span>
<span class="fc" id="L736">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval between consecutive propagations
     *                      or measurements.
     * @param initialConfig initial INS loosely coupled Kalman configuration to set
     *                      proper initial covariance during filter initialization.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final Time epochInterval, final INSLooselyCoupledKalmanInitializerConfig initialConfig) {
<span class="fc" id="L749">        this(epochInterval);</span>
        try {
<span class="fc" id="L751">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L752">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L754">        }</span>
<span class="fc" id="L755">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS loosely coupled Kalman filter configuration parameters
     *                      (usually obtained through calibration).
     * @param epochInterval minimum epoch interval between consecutive propagations
     *                      or measurements.
     * @param initialConfig initial INS loosely coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config, final Time epochInterval,
            final INSLooselyCoupledKalmanInitializerConfig initialConfig) {
<span class="fc" id="L771">        this(config, epochInterval);</span>
        try {
<span class="fc" id="L773">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L774">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L776">        }</span>
<span class="fc" id="L777">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval between consecutive propagations
     *                      or measurements.
     * @param initialConfig initial INS loosely coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final Time epochInterval, final INSLooselyCoupledKalmanInitializerConfig initialConfig,
            final INSGNSSLooselyCoupledKalmanFilteredEstimatorListener listener) {
<span class="fc" id="L792">        this(epochInterval, listener);</span>
        try {
<span class="fc" id="L794">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L795">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L797">        }</span>
<span class="fc" id="L798">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS loosely coupled Kalman filter configuration parameters
     *                      (usually obtained through calibration).
     * @param epochInterval minimum epoch interval between consecutive propagations
     *                      or measurements.
     * @param initialConfig initial INS loosely coupled Kalman configuration to set
     *                      proper initial covariance during filter initialization.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config, final Time epochInterval,
            final INSLooselyCoupledKalmanInitializerConfig initialConfig,
            final INSGNSSLooselyCoupledKalmanFilteredEstimatorListener listener) {
<span class="fc" id="L816">        this(config, epochInterval, listener);</span>
        try {
<span class="fc" id="L818">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L819">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L821">        }</span>
<span class="fc" id="L822">    }</span>

    /**
     * Constructor.
     *
     * @param initialConfig initial INS loosely coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @param c             body-to-ECEF coordinate transformation defining the initial body
     *                      attitude.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanInitializerConfig initialConfig, final CoordinateTransformation c)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L837">        this(c);</span>
        try {
<span class="fc" id="L839">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L840">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L842">        }</span>
<span class="fc" id="L843">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS loosely Kalman filter configuration parameters (usually
     *                      obtained through calibration).
     * @param initialConfig initial INS loosely coupled Kalman configuration to set
     *                      proper initial covariance during filter initialization.
     * @param c             body-to-ECEF coordinate transformation defining the initial
     *                      body attitude.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config, final INSLooselyCoupledKalmanInitializerConfig initialConfig,
            final CoordinateTransformation c) throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L860">        this(config, c);</span>
        try {
<span class="fc" id="L862">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L863">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L865">        }</span>
<span class="fc" id="L866">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @param initialConfig initial INS loosely coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @param c             body-to-ECEF coordinate transformation defining the initial
     *                      body attitude.
     * @throws IllegalArgumentException                      if provided epoch interval
     *                                                       is negative.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final double epochInterval, final INSLooselyCoupledKalmanInitializerConfig initialConfig,
            final CoordinateTransformation c) throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L885">        this(epochInterval, c);</span>
        try {
<span class="fc" id="L887">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L888">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L890">        }</span>
<span class="fc" id="L891">    }</span>

    /**
     * Constructor.
     *
     * @param initialConfig initial INS loosely coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @param c             body-to-ECEF coordinate transformation defining the initial
     *                      body attitude.
     * @param listener      listener to notify events raised by this instance.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanInitializerConfig initialConfig, final CoordinateTransformation c,
            final INSGNSSLooselyCoupledKalmanFilteredEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L908">        this(c, listener);</span>
        try {
<span class="fc" id="L910">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L911">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L913">        }</span>
<span class="fc" id="L914">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS loosely coupled Kalman filter configuration parameters
     *                      (usually obtained through calibration).
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @param initialConfig initial INS loosely coupled Kalman configuration to set
     *                      proper initial covariance during filter initialization.
     * @param c             body-to-ECEF coordinate transformation defining the initial
     *                      body attitude.
     * @throws IllegalArgumentException                      if provided epoch interval
     *                                                       is negative.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config, final double epochInterval,
            final INSLooselyCoupledKalmanInitializerConfig initialConfig, final CoordinateTransformation c)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L936">        this(config, epochInterval, c);</span>
        try {
<span class="fc" id="L938">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L939">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L941">        }</span>
<span class="fc" id="L942">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS loosely coupled Kalman filter configuration parameters
     *                      (usually obtained through calibration).
     * @param initialConfig initial INS loosely coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @param c             body-to-ECEF coordinate transformation defining the initial
     *                      body attitude.
     * @param listener      listener to notify events raised by this instance.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config, final INSLooselyCoupledKalmanInitializerConfig initialConfig,
            final CoordinateTransformation c, final INSGNSSLooselyCoupledKalmanFilteredEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L961">        this(config, c, listener);</span>
        try {
<span class="fc" id="L963">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L964">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L966">        }</span>
<span class="fc" id="L967">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @param initialConfig initial INS loosely coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @param c             body-to-ECEF coordinate transformation defining the initial
     *                      body attitude.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException                      if provided epoch interval
     *                                                       is negative.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final double epochInterval, final INSLooselyCoupledKalmanInitializerConfig initialConfig,
            final CoordinateTransformation c, final INSGNSSLooselyCoupledKalmanFilteredEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L988">        this(epochInterval, c, listener);</span>
        try {
<span class="fc" id="L990">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L991">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L993">        }</span>
<span class="fc" id="L994">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS loosely coupled Kalman filter configuration parameters
     *                      (usually obtained through calibration).
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @param initialConfig initial INS loosely coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @param c             body-to-ECEF coordinate transformation defining the initial
     *                      body attitude.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException                      if provided epoch interval
     *                                                       is negative.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config, final double epochInterval,
            final INSLooselyCoupledKalmanInitializerConfig initialConfig, final CoordinateTransformation c,
            final INSGNSSLooselyCoupledKalmanFilteredEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L1018">        this(config, epochInterval, c, listener);</span>
        try {
<span class="fc" id="L1020">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L1021">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L1023">        }</span>
<span class="fc" id="L1024">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval between consecutive propagations
     *                      or measurements.
     * @param initialConfig initial INS loosely coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @param c             body-to-ECEF coordinate transformation defining the initial
     *                      body attitude.
     * @throws IllegalArgumentException                      if provided epoch interval
     *                                                       is negative.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final Time epochInterval, final INSLooselyCoupledKalmanInitializerConfig initialConfig,
            final CoordinateTransformation c) throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L1043">        this(epochInterval, c);</span>
        try {
<span class="fc" id="L1045">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L1046">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L1048">        }</span>
<span class="fc" id="L1049">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS loosely coupled Kalman filter configuration parameters
     *                      (usually obtained through calibration).
     * @param epochInterval minimum epoch interval between consecutive propagations
     *                      or measurements.
     * @param initialConfig initial INS loosely coupled Kalman configuration to set
     *                      proper initial covariance during filter initialization.
     * @param c             body-to-ECEF coordinate transformation defining the initial
     *                      body attitude.
     * @throws IllegalArgumentException                      if provided epoch interval
     *                                                       is negative.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config, final Time epochInterval,
            final INSLooselyCoupledKalmanInitializerConfig initialConfig, final CoordinateTransformation c)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L1071">        this(config, epochInterval, c);</span>
        try {
<span class="fc" id="L1073">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L1074">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L1076">        }</span>
<span class="fc" id="L1077">    }</span>

    /**
     * Constructor.
     *
     * @param epochInterval minimum epoch interval between consecutive
     *                      propagations or measurements.
     * @param initialConfig initial INS loosely coupled Kalman configuration to
     *                      set proper initial covariance during filter initialization.
     * @param c             body-to-ECEF coordinate transformation defining the initial
     *                      body attitude.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException                      if provided epoch interval
     *                                                       is negative.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final Time epochInterval, final INSLooselyCoupledKalmanInitializerConfig initialConfig,
            final CoordinateTransformation c, final INSGNSSLooselyCoupledKalmanFilteredEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L1098">        this(epochInterval, c, listener);</span>
        try {
<span class="fc" id="L1100">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L1101">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L1103">        }</span>
<span class="fc" id="L1104">    }</span>

    /**
     * Constructor.
     *
     * @param config        INS loosely coupled Kalman filter configuration parameters
     *                      (usually obtained through calibration).
     * @param epochInterval minimum epoch interval between consecutive propagations
     *                      or measurements.
     * @param initialConfig initial INS loosely coupled Kalman configuration to set
     *                      proper initial covariance during filter initialization.
     * @param c             body-to-ECEF coordinate transformation defining the initial
     *                      body attitude.
     * @param listener      listener to notify events raised by this instance.
     * @throws IllegalArgumentException                      if provided epoch interval
     *                                                       is negative.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimator(
            final INSLooselyCoupledKalmanConfig config, final Time epochInterval,
            final INSLooselyCoupledKalmanInitializerConfig initialConfig, final CoordinateTransformation c,
            final INSGNSSLooselyCoupledKalmanFilteredEstimatorListener listener)
            throws InvalidSourceAndDestinationFrameTypeException {
<span class="fc" id="L1128">        this(config, epochInterval, c, listener);</span>
        try {
<span class="fc" id="L1130">            setInitialConfig(initialConfig);</span>
<span class="nc" id="L1131">        } catch (final LockedException ignore) {</span>
            // never happens
<span class="fc" id="L1133">        }</span>
<span class="fc" id="L1134">    }</span>

    /**
     * Gets listener to notify events raised by this instance.
     *
     * @return listener to notify events raised by this instance.
     */
    public INSGNSSLooselyCoupledKalmanFilteredEstimatorListener getListener() {
<span class="fc" id="L1142">        return listener;</span>
    }

    /**
     * Sets listener to notify events raised by this instance.
     *
     * @param listener listener to notify events raised by this instance.
     * @throws LockedException if this estimator is already running.
     */
    public void setListener(final INSGNSSLooselyCoupledKalmanFilteredEstimatorListener listener)
            throws LockedException {
<span class="fc bfc" id="L1153" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L1154">            throw new LockedException();</span>
        }

<span class="fc" id="L1157">        this.listener = listener;</span>
<span class="fc" id="L1158">    }</span>

    /**
     * Gets minimum epoch interval expressed in seconds (s) between consecutive
     * propagations or measurements expressed in seconds.
     * Attempting to propagate results using Kalman filter or updating measurements
     * when intervals are less than this value, will be ignored.
     *
     * @return minimum epoch interval between consecutive propagations or
     * measurements.
     */
    public double getEpochInterval() {
<span class="fc" id="L1170">        return insEstimator.getEpochInterval();</span>
    }

    /**
     * Sets minimum epoch interval expressed in seconds (s) between consecutive
     * propagations or measurements expressed in seconds.
     * Attempting to propagate results using Kalman filter or updating measurements
     * when intervals are less than this value, will be ignored.
     *
     * @param epochInterval minimum epoch interval expressed in seconds (s) between
     *                      consecutive propagations or measurements.
     * @throws LockedException          if this estimator is already running.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public void setEpochInterval(final double epochInterval) throws LockedException {
<span class="fc bfc" id="L1185" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L1186">            throw new LockedException();</span>
        }

<span class="fc" id="L1189">        insEstimator.setEpochInterval(epochInterval);</span>
<span class="fc" id="L1190">    }</span>

    /**
     * Gets minimum epoch interval between consecutive propagations or measurements.
     * Attempting to propagate results using Kalman filter or updating measurements
     * when intervals are less than this value, will be ignored.
     *
     * @param result instance where minimum epoch interval will be stored.
     */
    public void getEpochIntervalAsTime(final Time result) {
<span class="fc" id="L1200">        insEstimator.getEpochIntervalAsTime(result);</span>
<span class="fc" id="L1201">    }</span>

    /**
     * Gets minimum epoch interval between consecutive propagations or measurements.
     * Attempting to propagate results using Kalman filter or updating measurements
     * when intervals are less than this value, will be ignored.
     *
     * @return minimum epoch interval.
     */
    public Time getEpochIntervalAsTime() {
<span class="fc" id="L1211">        return insEstimator.getEpochIntervalAsTime();</span>
    }

    /**
     * Sets minimum epoch interval between consecutive propagations or measurements.
     * Attempting to propagate results using Kalman filter or updating measurements
     * when intervals are less than this value, will be ignored.
     *
     * @param epochInterval minimum epoch interval.
     * @throws LockedException          if this estimator is already running.
     * @throws IllegalArgumentException if provided epoch interval is negative.
     */
    public void setEpochInterval(final Time epochInterval) throws LockedException {
<span class="fc bfc" id="L1224" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L1225">            throw new LockedException();</span>
        }

<span class="fc" id="L1228">        insEstimator.setEpochInterval(epochInterval);</span>
<span class="fc" id="L1229">    }</span>

    /**
     * Gets INS loosely coupled Kalman configuration parameters (usually
     * obtained through calibration).
     *
     * @param result instance where INS loosely coupled Kalman configuration
     *               parameters will be stored.
     * @return true if result instance is updated, false otherwise.
     */
    public boolean getConfig(final INSLooselyCoupledKalmanConfig result) {
<span class="fc" id="L1240">        return insEstimator.getConfig(result);</span>
    }

    /**
     * Gets INS loosely coupled Kalman configuration parameters (usually obtained
     * through calibration).
     *
     * @return INS loosely coupled Kalman configuration parameters.
     */
    public INSLooselyCoupledKalmanConfig getConfig() {
<span class="fc" id="L1250">        return insEstimator.getConfig();</span>
    }

    /**
     * Sets INS loosely coupled Kalman configuration parameters (usually obtained
     * through calibration).
     *
     * @param config INS loosely coupled Kalman configuration parameters to be
     *               set.
     * @throws LockedException if this estimator is already running.
     */
    public void setConfig(final INSLooselyCoupledKalmanConfig config) throws LockedException {
<span class="fc bfc" id="L1262" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L1263">            throw new LockedException();</span>
        }

<span class="fc" id="L1266">        insEstimator.setConfig(config);</span>
<span class="fc" id="L1267">    }</span>

    /**
     * Gets body-to-ECEF coordinate transformation defining the body attitude.
     * This can be used to set the initial body attitude before starting the
     * estimator, or to update body attitude between INS/GNSS measurement updates.
     *
     * @return body-to-ECEF coordinate transformation.
     */
    public CoordinateTransformation getCoordinateTransformation() {
<span class="fc bfc" id="L1277" title="All 2 branches covered.">        return frame != null ? frame.getCoordinateTransformation() : null;</span>
    }

    /**
     * Gets body-to-ECEF coordinate transformation defining the body attitude.
     * This can be used to set the initial body attitude before starting the
     * estimator, or to update body attitude between INS/GNSS measurement updates.
     *
     * @param result instance where body-to-ECEF data will be stored.
     * @return true if result instance was updated, false otherwise.
     */
    public boolean getCoordinateTransformation(final CoordinateTransformation result) {
<span class="fc bfc" id="L1289" title="All 2 branches covered.">        if (frame != null) {</span>
<span class="fc" id="L1290">            frame.getCoordinateTransformation(result);</span>
<span class="fc" id="L1291">            return true;</span>
        } else {
<span class="fc" id="L1293">            return false;</span>
        }
    }

    /**
     * Sets body-to-ECEF coordinate transformation defining the body attitude.
     * This can be used to set the initial body attitude before starting the
     * estimator, or to update body attitude between INS/GNSS measurement updates.
     *
     * @param c body-to-ECEF coordinate transformation to be set.
     * @throws InvalidSourceAndDestinationFrameTypeException if provided coordinate
     *                                                       transformation is not valid (is not a
     *                                                       body-to-ECEF transformation).
     * @throws LockedException                               if this estimator is already running.
     */
    public void setCoordinateTransformation(final CoordinateTransformation c)
            throws InvalidSourceAndDestinationFrameTypeException, LockedException {
<span class="fc bfc" id="L1310" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L1311">            throw new LockedException();</span>
        }

<span class="fc" id="L1314">        initFrame();</span>
<span class="fc" id="L1315">        frame.setCoordinateTransformation(c);</span>
<span class="fc" id="L1316">        insEstimator.setFrame(frame);</span>
<span class="fc" id="L1317">    }</span>

    /**
     * Gets initial INS loosely coupled Kalman configuration to set a proper
     * initial covariance matrix during the first Kalman filter propagation.
     * Once this estimator is initialized, covariance will be updated with new provided
     * GNSS and INS measurements until convergence is reached.
     *
     * @param result instance where configuration data will be stored.
     * @return true if result instance was updated, false otherwise.
     */
    public boolean getInitialConfig(final INSLooselyCoupledKalmanInitializerConfig result) {
<span class="fc" id="L1329">        return insEstimator.getInitialConfig(result);</span>
    }

    /**
     * Gets initial INS loosely coupled Kalman configuration te set a proper
     * initial covariance matrix during the first Kalman filter propagation.
     * Once this estimator is initialized, covariance will be updated with new provided
     * GNSS and INS measurements until convergence is reached.
     *
     * @return initial INS loosely coupled Kalman configuration.
     */
    public INSLooselyCoupledKalmanInitializerConfig getInitialConfig() {
<span class="fc" id="L1341">        return insEstimator.getInitialConfig();</span>
    }

    /**
     * Sets initial INS loosely coupled Kalman configuration to set a proper
     * initial covariance matrix during the first Kalman filter propagation.
     * Once this estimator is initialized, covariance will be updated with new provided
     * GNSS and INS measurements until convergence is reached.
     *
     * @param initialConfig initial configuration to be set.
     * @throws LockedException if this estimator is already running.
     */
    public void setInitialConfig(final INSLooselyCoupledKalmanInitializerConfig initialConfig) throws LockedException {
<span class="fc bfc" id="L1354" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L1355">            throw new LockedException();</span>
        }

<span class="fc" id="L1358">        insEstimator.setInitialConfig(initialConfig);</span>
<span class="fc" id="L1359">    }</span>

    /**
     * Gets last updated GNSS measurements of a collection of satellites.
     *
     * @return last updated GNSS measurements of a collection of satellites.
     */
    public Collection&lt;GNSSMeasurement&gt; getMeasurements() {
<span class="fc bfc" id="L1367" title="All 2 branches covered.">        if (measurements == null) {</span>
<span class="fc" id="L1368">            return null;</span>
        }

<span class="fc" id="L1371">        final var result = new ArrayList&lt;GNSSMeasurement&gt;();</span>
<span class="fc bfc" id="L1372" title="All 2 branches covered.">        for (final var measurement : measurements) {</span>
<span class="fc" id="L1373">            result.add(new GNSSMeasurement(measurement));</span>
<span class="fc" id="L1374">        }</span>
<span class="fc" id="L1375">        return result;</span>
    }

    /**
     * Gets last provided user kinematics containing applied specific force and
     * angular rates resolved in body axes.
     *
     * @return last provided user kinematics.
     */
    public BodyKinematics getKinematics() {
<span class="fc" id="L1385">        final var result = insEstimator.getKinematics();</span>
<span class="fc bfc" id="L1386" title="All 2 branches covered.">        if (result != null) {</span>
<span class="fc" id="L1387">            return result;</span>
        } else {
<span class="pc bpc" id="L1389" title="1 of 2 branches missed.">            if (kinematics != null) {</span>
<span class="nc" id="L1390">                return new BodyKinematics(kinematics);</span>
            } else {
<span class="fc" id="L1392">                return null;</span>
            }
        }
    }

    /**
     * Gets last provided user kinematics containing applied specific force and
     * angular rates resolved in body axes.
     *
     * @param result instance where last provided body kinematics will be stored.
     * @return true if provided result instance was updated, false otherwise.
     */
    public boolean getKinematics(final BodyKinematics result) {
<span class="fc bfc" id="L1405" title="All 2 branches covered.">        if (!insEstimator.getKinematics(result)) {</span>
<span class="pc bpc" id="L1406" title="1 of 2 branches missed.">            if (kinematics != null) {</span>
<span class="nc" id="L1407">                result.copyFrom(kinematics);</span>
<span class="nc" id="L1408">                return true;</span>
            } else {
<span class="fc" id="L1410">                return false;</span>
            }
        } else {
<span class="fc" id="L1413">            return true;</span>
        }
    }

    /**
     * Gets corrected kinematics which are the last provided user kinematics after
     * removal of the biases estimated by the Kalman filter.
     *
     * @return corrected kinematics.
     * @see #getKinematics()
     */
    public BodyKinematics getCorrectedKinematics() {
<span class="fc" id="L1425">        final var result = insEstimator.getCorrectedKinematics();</span>
<span class="fc bfc" id="L1426" title="All 2 branches covered.">        if (result != null) {</span>
<span class="fc" id="L1427">            return result;</span>
        } else {
<span class="pc bpc" id="L1429" title="1 of 2 branches missed.">            if (correctedKinematics != null) {</span>
<span class="nc" id="L1430">                return new BodyKinematics(correctedKinematics);</span>
            } else {
<span class="fc" id="L1432">                return null;</span>
            }
        }
    }

    /**
     * Gets corrected kinematics which are the last provided user kinematics after
     * removal of the biases estimated by the Kalman filter.
     *
     * @param result instance where corrected body kinematics will be stored.
     * @return true if provided result instance was updated, false otherwise.
     */
    public boolean getCorrectedKinematics(final BodyKinematics result) {
<span class="fc bfc" id="L1445" title="All 2 branches covered.">        if (!insEstimator.getCorrectedKinematics(result)) {</span>
<span class="pc bpc" id="L1446" title="1 of 2 branches missed.">            if (correctedKinematics != null) {</span>
<span class="nc" id="L1447">                result.copyFrom(correctedKinematics);</span>
<span class="nc" id="L1448">                return true;</span>
            } else {
<span class="fc" id="L1450">                return false;</span>
            }
        } else {
<span class="fc" id="L1453">            return true;</span>
        }
    }

    /**
     * Gets current estimation containing user ECEF position, user ECEF velocity,
     * clock offset and clock drift.
     *
     * @return current estimation containing user ECEF position, user ECEF velocity,
     * clock offset and clock drift.
     */
    public GNSSEstimation getEstimation() {
<span class="fc bfc" id="L1465" title="All 2 branches covered.">        return estimation != null ? new GNSSEstimation(estimation) : null;</span>
    }

    /**
     * Gets current estimation containing user ECEF position, user ECEF velocity,
     * clock offset and clock drift.
     * This method does not update result instance if no estimation is available.
     *
     * @param result instance where estimation will be stored.
     * @return true if result estimation was updated, false otherwise.
     */
    public boolean getEstimation(final GNSSEstimation result) {
<span class="fc bfc" id="L1477" title="All 2 branches covered.">        if (estimation != null) {</span>
<span class="fc" id="L1478">            result.copyFrom(estimation);</span>
<span class="fc" id="L1479">            return true;</span>
        } else {
<span class="fc" id="L1481">            return false;</span>
        }
    }

    /**
     * Gets current Kalman filter state containing current user position,
     * velocity, attitude and IMU biases along with Kalman filter
     * covariance error matrix.
     *
     * @return current Kalman filter state.
     */
    public INSLooselyCoupledKalmanState getState() {
<span class="fc bfc" id="L1493" title="All 2 branches covered.">        return state != null ? new INSLooselyCoupledKalmanState(state) : null;</span>
    }

    /**
     * Gets current Kalman filter state containing current user position,
     * velocity, attitude and IMU biases along with Kalman filter
     * covariance error matrix.
     *
     * @param result instance where state will be stored.
     * @return true if result state was updated, false otherwise.
     */
    public boolean getState(final INSLooselyCoupledKalmanState result) {
<span class="fc bfc" id="L1505" title="All 2 branches covered.">        if (state != null) {</span>
<span class="fc" id="L1506">            result.copyFrom(state);</span>
<span class="fc" id="L1507">            return true;</span>
        } else {
<span class="fc" id="L1509">            return false;</span>
        }
    }

    /**
     * Gets timestamp expressed in seconds since epoch time when Kalman filter state
     * was last propagated.
     *
     * @return timestamp expressed in seconds since epoch time when Kalman filter
     * state was last propagated.
     */
    public Double getLastStateTimestamp() {
<span class="fc" id="L1521">        return insEstimator.getLastStateTimestamp();</span>
    }

    /**
     * Gets timestamp since epoch time when Kalman filter state was las propagated.
     *
     * @param result instance where timestamp since epoch time when Kalman filter
     *               state was last propagated will be stored.
     * @return true if result instance is updated, false otherwise.
     */
    public boolean getLastStateTimestampAsTime(final Time result) {
<span class="fc" id="L1532">        return insEstimator.getLastStateTimestampAsTime(result);</span>
    }

    /**
     * Gets timestamp since epoch time when Kalman filter state was last propagated.
     *
     * @return timestamp since epoch time when Kalman filter state was last
     * propagated.
     */
    public Time getLastStateTimestampAsTime() {
<span class="fc" id="L1542">        return insEstimator.getLastStateTimestampAsTime();</span>
    }

    /**
     * Indicates whether this estimator is running or not.
     *
     * @return true if this estimator is running, false otherwise.
     */
    public boolean isRunning() {
<span class="pc bpc" id="L1551" title="1 of 4 branches missed.">        return running || insEstimator.isRunning();</span>
    }

    /**
     * Indicates whether provided measurements are ready to be
     * used for an update.
     *
     * @param measurements measurements to be checked.
     * @return true if estimator is ready, false otherwise.
     */
    public static boolean isUpdateMeasurementsReady(final Collection&lt;GNSSMeasurement&gt; measurements) {
<span class="fc" id="L1562">        return GNSSLeastSquaresPositionAndVelocityEstimator.isValidMeasurements(measurements);</span>
    }

    /**
     * Updates GNSS measurements of this estimator when new satellite measurements
     * are available.
     * Calls to this method will be ignored if interval between provided timestamp
     * and last timestamp when Kalman filter was updated is less than epoch interval.
     *
     * @param measurements GNSS measurements to be updated.
     * @param timestamp    timestamp since epoch time when GNSS measurements were
     *                     updated.
     * @return true if measurements were updated, false otherwise.
     * @throws LockedException   if this estimator is already running.
     * @throws NotReadyException if estimator is not ready for measurements updates.
     * @throws INSGNSSException  if estimation fails due to numerical instabilities.
     */
    public boolean updateMeasurements(final Collection&lt;GNSSMeasurement&gt; measurements, final Time timestamp)
            throws LockedException, NotReadyException, INSGNSSException {
<span class="fc" id="L1581">        return updateMeasurements(measurements, TimeConverter.convert(timestamp.getValue().doubleValue(),</span>
<span class="fc" id="L1582">                timestamp.getUnit(), TimeUnit.SECOND));</span>
    }

    /**
     * Updates GNSS measurements of this estimator when new satellite measurements
     * are available.
     * Call to this method will be ignored if interval between provided timestamp
     * and last timestamp when Kalman filter was updated is less than epoch interval.
     *
     * @param measurements GNSS measurements to be updated.
     * @param timestamp    timestamp expressed in seconds since epoch time when
     *                     GNSS measurements were updated.
     * @return true if measurements were updated, false otherwise.
     * @throws LockedException   if this estimator is already running.
     * @throws NotReadyException if estimator is not ready for measurements updates.
     * @throws INSGNSSException  if estimation fails due to numerical instabilities.
     */
    public boolean updateMeasurements(final Collection&lt;GNSSMeasurement&gt; measurements, final double timestamp)
            throws LockedException, NotReadyException, INSGNSSException {

<span class="fc bfc" id="L1602" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L1603">            throw new LockedException();</span>
        }

<span class="fc bfc" id="L1606" title="All 2 branches covered.">        if (!isUpdateMeasurementsReady(measurements)) {</span>
<span class="fc" id="L1607">            throw new NotReadyException();</span>
        }

<span class="fc" id="L1610">        final var lastStateTimestamp = insEstimator.getLastStateTimestamp();</span>
<span class="fc bfc" id="L1611" title="All 4 branches covered.">        if (lastStateTimestamp != null &amp;&amp; timestamp - lastStateTimestamp &lt;= insEstimator.getEpochInterval()) {</span>
<span class="fc" id="L1612">            return false;</span>
        }

        try {
<span class="fc" id="L1616">            running = true;</span>

<span class="pc bpc" id="L1618" title="1 of 2 branches missed.">            if (listener != null) {</span>
<span class="fc" id="L1619">                listener.onUpdateGNSSMeasurementsStart(this);</span>
            }

<span class="fc" id="L1622">            this.measurements = new ArrayList&lt;&gt;(measurements);</span>

<span class="fc" id="L1624">            lsEstimator.setMeasurements(this.measurements);</span>
<span class="fc" id="L1625">            lsEstimator.setPriorPositionAndVelocityFromEstimation(estimation);</span>
<span class="pc bpc" id="L1626" title="1 of 2 branches missed.">            if (estimation != null) {</span>
<span class="nc" id="L1627">                lsEstimator.estimate(estimation);</span>
            } else {
<span class="fc" id="L1629">                estimation = lsEstimator.estimate();</span>
            }

<span class="pc bpc" id="L1632" title="1 of 2 branches missed.">            if (listener != null) {</span>
<span class="fc" id="L1633">                listener.onUpdateGNSSMeasurementsEnd(this);</span>
            }
<span class="fc" id="L1635">        } catch (final GNSSException e) {</span>
<span class="fc" id="L1636">            throw new INSGNSSException(e);</span>
        } finally {
<span class="fc" id="L1638">            running = false;</span>
        }

<span class="fc bfc" id="L1641" title="All 2 branches covered.">        if (kinematics == null) {</span>
<span class="fc" id="L1642">            kinematics = insEstimator.getKinematics();</span>
        } else {
<span class="fc" id="L1644">            insEstimator.getKinematics(kinematics);</span>
        }

<span class="fc" id="L1647">        updateBodyKinematics(kinematics, timestamp);</span>

<span class="fc" id="L1649">        return true;</span>
    }

    /**
     * Updates specific force and angular rate applied to the user's
     * body expressed in coordinates resolved along body-frame axes.
     *
     * @param kinematics kinematics applied to body (specific force and angular rate)
     *                   during last period of time. These measures are obtained from
     *                   an inertial unit (IMU).
     * @param timestamp  timestamp since epoch time when specific force and
     *                   angular rate values were updated.
     * @return true if body kinematics values were updated, false otherwise.
     * @throws LockedException  if this estimator is already running.
     * @throws INSGNSSException if estimation fails due to numerical instabilities.
     */
    public boolean updateBodyKinematics(final BodyKinematics kinematics, final Time timestamp) throws LockedException,
            INSGNSSException {
<span class="fc" id="L1667">        return updateBodyKinematics(kinematics, TimeConverter.convert(timestamp.getValue().doubleValue(),</span>
<span class="fc" id="L1668">                timestamp.getUnit(), TimeUnit.SECOND));</span>
    }

    /**
     * Updates specific force and angular rate applied to the user's
     * body expressed in coordinates resolved along body-frame axes.
     *
     * @param kinematics kinematics applied to body (specific force and angular rate)
     *                   during last period of time. These measures are obtained from
     *                   an inertial unit (IMU).
     * @param timestamp  timestamp expressed in seconds since epoch time when specific
     *                   force and angular rate values were updated.
     * @return true if body kinematics values were updated, false otherwise.
     * @throws LockedException  if this estimator is already running.
     * @throws INSGNSSException if estimation fails due to numerical instabilities.
     */
    public boolean updateBodyKinematics(final BodyKinematics kinematics, final double timestamp) throws LockedException,
            INSGNSSException {

<span class="fc bfc" id="L1687" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L1688">            throw new LockedException();</span>
        }

        try {
<span class="fc" id="L1692">            running = true;</span>

<span class="fc" id="L1694">            initFrame();</span>
<span class="fc bfc" id="L1695" title="All 2 branches covered.">            if (estimation != null) {</span>
<span class="fc" id="L1696">                frame.setCoordinates(estimation.getX(), estimation.getY(), estimation.getZ());</span>
<span class="fc" id="L1697">                frame.setVelocityCoordinates(estimation.getVx(), estimation.getVy(), estimation.getVz());</span>
            }
<span class="fc" id="L1699">            insEstimator.setFrame(frame);</span>

<span class="fc" id="L1701">            var result = false;</span>
<span class="pc bpc" id="L1702" title="1 of 2 branches missed.">            if (insEstimator.isUpdateReady()) {</span>
<span class="fc" id="L1703">                result = insEstimator.update(kinematics, timestamp);</span>
<span class="fc bfc" id="L1704" title="All 2 branches covered.">                if (result) {</span>
<span class="fc bfc" id="L1705" title="All 2 branches covered.">                    if (this.kinematics == null) {</span>
<span class="fc" id="L1706">                        this.kinematics = insEstimator.getKinematics();</span>
                    } else {
<span class="fc" id="L1708">                        insEstimator.getKinematics(this.kinematics);</span>
                    }

<span class="fc bfc" id="L1711" title="All 2 branches covered.">                    if (estimation != null) {</span>
<span class="fc" id="L1712">                        initState();</span>
<span class="fc" id="L1713">                        insEstimator.getState(state);</span>
                    }
                }
            } else {
<span class="nc" id="L1717">                this.kinematics = kinematics;</span>
            }

<span class="fc bfc" id="L1720" title="All 2 branches covered.">            if (kinematics != null) {</span>
<span class="fc" id="L1721">                correctKinematics(kinematics);</span>
            }

<span class="fc" id="L1724">            return result;</span>

<span class="nc" id="L1726">        } catch (final INSException | NotReadyException e) {</span>
<span class="nc" id="L1727">            throw new INSGNSSException(e);</span>
        } finally {
<span class="fc" id="L1729">            running = false;</span>
        }
    }

    /**
     * Indicates whether this estimator is ready for state propagations.
     *
     * @return true if estimator is ready, false otherwise.
     */
    public boolean isPropagateReady() {
<span class="fc bfc" id="L1739" title="All 4 branches covered.">        return insEstimator.isPropagateReady() &amp;&amp; estimation != null;</span>
    }

    /**
     * Propagates Kalman filter state held by this estimator at provided
     * timestamp.
     * Call to this method will be ignored if interval between provided timestamp
     * and last timestamp when Kalman filter was updated is less than epoch interval.
     *
     * @param timestamp timestamp since epoch to propagate state.
     * @return true if state was propagated, false otherwise.
     * @throws LockedException  if this estimator is already running.
     * @throws INSGNSSException if estimation fails due to numerical instabilities.
     */
    public boolean propagate(final Time timestamp) throws LockedException, INSGNSSException {
<span class="fc" id="L1754">        return propagate(TimeConverter.convert(timestamp.getValue().doubleValue(), timestamp.getUnit(),</span>
                TimeUnit.SECOND));
    }

    /**
     * Propagates Kalman filter state held by this estimator at provided
     * timestamp.
     * Call to this method will be ignored if interval between provided timestamp
     * and last timestamp when Kalman filter was updated is less than epoch interval.
     *
     * @param timestamp timestamp expressed in seconds since epoch to propagate state.
     * @return true if state was propagated, false otherwise.
     * @throws LockedException  if this estimator is already running.
     * @throws INSGNSSException if estimation fails due to numerical instabilities.
     */
    public boolean propagate(final double timestamp) throws LockedException, INSGNSSException {

<span class="fc bfc" id="L1771" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L1772">            throw new LockedException();</span>
        }

<span class="fc bfc" id="L1775" title="All 2 branches covered.">        if (!isPropagateReady()) {</span>
<span class="fc" id="L1776">            return false;</span>
        }

        try {
<span class="fc" id="L1780">            running = true;</span>

<span class="pc bpc" id="L1782" title="1 of 2 branches missed.">            if (initFrame()) {</span>
<span class="nc" id="L1783">                frame.setCoordinates(estimation.getX(), estimation.getY(), estimation.getZ());</span>
<span class="nc" id="L1784">                frame.setVelocityCoordinates(estimation.getVx(), estimation.getVy(), estimation.getVz());</span>
<span class="nc" id="L1785">                insEstimator.setFrame(frame);</span>
            }

<span class="fc" id="L1788">            final var result = insEstimator.propagate(timestamp);</span>
<span class="fc bfc" id="L1789" title="All 2 branches covered.">            if (result) {</span>
<span class="fc" id="L1790">                insEstimator.getFrame(frame);</span>
<span class="fc" id="L1791">                estimation.setPositionCoordinates(frame.getX(), frame.getY(), frame.getZ());</span>
<span class="fc" id="L1792">                estimation.setVelocityCoordinates(frame.getVx(), frame.getVy(), frame.getVz());</span>

<span class="fc" id="L1794">                initState();</span>
<span class="fc" id="L1795">                insEstimator.getState(state);</span>
            }

<span class="fc" id="L1798">            return result;</span>

<span class="nc" id="L1800">        } catch (final INSException | NotReadyException e) {</span>
<span class="nc" id="L1801">            throw new INSGNSSException(e);</span>
        } finally {
<span class="fc" id="L1803">            running = false;</span>
        }
    }

    /**
     * Resets this estimator.
     *
     * @throws LockedException if this estimator is already running.
     */
    public void reset() throws LockedException {
<span class="fc bfc" id="L1813" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L1814">            throw new LockedException();</span>
        }

<span class="fc" id="L1817">        running = true;</span>
<span class="fc" id="L1818">        measurements = null;</span>
<span class="fc" id="L1819">        estimation = null;</span>
<span class="fc" id="L1820">        state = null;</span>
<span class="fc" id="L1821">        kinematics = null;</span>
<span class="fc" id="L1822">        correctedKinematics = null;</span>
<span class="fc" id="L1823">        frame = null;</span>

<span class="fc" id="L1825">        insEstimator.reset();</span>

<span class="pc bpc" id="L1827" title="1 of 2 branches missed.">        if (listener != null) {</span>
<span class="fc" id="L1828">            listener.onReset(this);</span>
        }

<span class="fc" id="L1831">        running = false;</span>
<span class="fc" id="L1832">    }</span>

    /**
     * Initializes current ECEF frame containing user position, velocity and
     * orientation expressed and resolved in ECEF coordinates.
     * This method makes no action if an initial frame already exists.
     *
     * @return true if frame was initialized, false otherwise.
     */
    private boolean initFrame() {
<span class="fc bfc" id="L1842" title="All 2 branches covered.">        if (frame == null) {</span>
<span class="fc" id="L1843">            frame = new ECEFFrame();</span>
<span class="fc" id="L1844">            frame.setCoordinates(Constants.EARTH_EQUATORIAL_RADIUS_WGS84, 0.0, 0.0);</span>
<span class="fc" id="L1845">            return true;</span>
        } else {
<span class="fc" id="L1847">            return false;</span>
        }
    }

    /**
     * Initializes state.
     */
    private void initState() {
<span class="fc bfc" id="L1855" title="All 2 branches covered.">        if (state == null) {</span>
<span class="fc" id="L1856">            state = new INSLooselyCoupledKalmanState();</span>
        }
<span class="fc" id="L1858">    }</span>

    /**
     * Corrects provided kinematics by taking into account currently estimated
     * specific force and angular rate biases.
     * This method stores the result into the variable member containing corrected
     * kinematics values.
     *
     * @param kinematics kinematics instance to be corrected.
     */
    private void correctKinematics(final BodyKinematics kinematics) {
<span class="fc bfc" id="L1869" title="All 2 branches covered.">        if (correctedKinematics == null) {</span>
<span class="fc" id="L1870">            correctedKinematics = new BodyKinematics();</span>
        }

        final double accelBiasX;
        final double accelBiasY;
        final double accelBiasZ;
        final double gyroBiasX;
        final double gyroBiasY;
        final double gyroBiasZ;
<span class="fc bfc" id="L1879" title="All 2 branches covered.">        if (state != null) {</span>
<span class="fc" id="L1880">            accelBiasX = getValueOrZero(state.getAccelerationBiasX());</span>
<span class="fc" id="L1881">            accelBiasY = getValueOrZero(state.getAccelerationBiasY());</span>
<span class="fc" id="L1882">            accelBiasZ = getValueOrZero(state.getAccelerationBiasZ());</span>
<span class="fc" id="L1883">            gyroBiasX = getValueOrZero(state.getGyroBiasX());</span>
<span class="fc" id="L1884">            gyroBiasY = getValueOrZero(state.getGyroBiasY());</span>
<span class="fc" id="L1885">            gyroBiasZ = getValueOrZero(state.getGyroBiasZ());</span>
        } else {
<span class="fc" id="L1887">            accelBiasX = 0.0;</span>
<span class="fc" id="L1888">            accelBiasY = 0.0;</span>
<span class="fc" id="L1889">            accelBiasZ = 0.0;</span>
<span class="fc" id="L1890">            gyroBiasX = 0.0;</span>
<span class="fc" id="L1891">            gyroBiasY = 0.0;</span>
<span class="fc" id="L1892">            gyroBiasZ = 0.0;</span>
        }

<span class="fc" id="L1895">        final var fx = kinematics.getFx();</span>
<span class="fc" id="L1896">        final var fy = kinematics.getFy();</span>
<span class="fc" id="L1897">        final var fz = kinematics.getFz();</span>
<span class="fc" id="L1898">        final var angularRateX = kinematics.getAngularRateX();</span>
<span class="fc" id="L1899">        final var angularRateY = kinematics.getAngularRateY();</span>
<span class="fc" id="L1900">        final var angularRateZ = kinematics.getAngularRateZ();</span>

<span class="fc" id="L1902">        correctedKinematics.setSpecificForceCoordinates(fx - accelBiasX, fy - accelBiasY, fz - accelBiasZ);</span>
<span class="fc" id="L1903">        correctedKinematics.setAngularRateCoordinates(</span>
                angularRateX - gyroBiasX,
                angularRateY - gyroBiasY,
                angularRateZ - gyroBiasZ);
<span class="fc" id="L1907">    }</span>

    /**
     * Returns provided value if not infinity and not NaN.
     *
     * @param value value to be returned.
     * @return value or 0.0.
     */
    private double getValueOrZero(final double value) {
<span class="pc bpc" id="L1916" title="2 of 4 branches missed.">        if (Double.isNaN(value) || Double.isInfinite(value)) {</span>
<span class="nc" id="L1917">            return 0.0;</span>
        } else {
<span class="fc" id="L1919">            return value;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>