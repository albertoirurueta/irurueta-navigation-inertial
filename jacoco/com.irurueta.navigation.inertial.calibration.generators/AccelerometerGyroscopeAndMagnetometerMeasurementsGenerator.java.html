<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AccelerometerGyroscopeAndMagnetometerMeasurementsGenerator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-navigation-inertial</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.navigation.inertial.calibration.generators</a> &gt; <span class="el_source">AccelerometerGyroscopeAndMagnetometerMeasurementsGenerator.java</span></div><h1>AccelerometerGyroscopeAndMagnetometerMeasurementsGenerator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2020 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.navigation.inertial.calibration.generators;

import com.irurueta.navigation.LockedException;
import com.irurueta.navigation.inertial.calibration.AccelerometerNoiseRootPsdSource;
import com.irurueta.navigation.inertial.calibration.AngularSpeedTriad;
import com.irurueta.navigation.inertial.calibration.BodyKinematicsSequence;
import com.irurueta.navigation.inertial.calibration.GyroscopeNoiseRootPsdSource;
import com.irurueta.navigation.inertial.calibration.StandardDeviationBodyKinematics;
import com.irurueta.navigation.inertial.calibration.StandardDeviationBodyMagneticFluxDensity;
import com.irurueta.navigation.inertial.calibration.StandardDeviationTimedBodyKinematics;
import com.irurueta.navigation.inertial.calibration.TimedBodyKinematics;
import com.irurueta.navigation.inertial.calibration.TimedBodyKinematicsAndMagneticFluxDensity;
import com.irurueta.navigation.inertial.calibration.intervals.TriadStaticIntervalDetector;
import com.irurueta.units.Acceleration;
import com.irurueta.units.AngularSpeed;
import com.irurueta.units.Time;
import com.irurueta.units.TimeConverter;
import com.irurueta.units.TimeUnit;

/**
 * Generates measurements for the calibration of accelerometers and gyroscopes by alternating
 * static and dynamic intervals where device is kept static or moved.
 * Generated measurements must be used with accelerometer calibrators based
 * on the knowledge of gravity norm (or Earth position) when the device orientation
 * is unknown, with easy gyroscope calibrators and with magnetometer calibrators based
 * on the knowledge of position on Earth and time instant.
 * Notice that accuracy of the gyroscope calibration is very sensitive to the
 * accuracy of detected dynamic intervals respect the average specific forces
 * during static intervals.
 * In order to increase the accuracy, calibration should be repeated trying different
 * threshold factors {@link #getThresholdFactor()}.
 *
 * @see AccelerometerMeasurementsGenerator
 * @see GyroscopeMeasurementsGenerator
 * @see MagnetometerMeasurementsGenerator
 */
public class AccelerometerGyroscopeAndMagnetometerMeasurementsGenerator implements
        AccelerometerNoiseRootPsdSource, GyroscopeNoiseRootPsdSource {

    /**
     * Listener to handle generated events.
     */
    private AccelerometerGyroscopeAndMagnetometerMeasurementsGeneratorListener listener;

    /**
     * Listener for internal accelerometer measurements generator.
     */
<span class="fc" id="L63">    private final AccelerometerMeasurementsGeneratorListener accelerometerListener =</span>
<span class="fc" id="L64">            new AccelerometerMeasurementsGeneratorListener() {</span>
                @Override
                public void onInitializationStarted(final AccelerometerMeasurementsGenerator generator) {
                    // no action required
<span class="fc" id="L68">                }</span>

                @Override
                public void onInitializationCompleted(
                        final AccelerometerMeasurementsGenerator generator, final double baseNoiseLevel) {
                    // no action required
<span class="fc" id="L74">                }</span>

                @Override
                public void onError(
                        final AccelerometerMeasurementsGenerator generator,
                        final TriadStaticIntervalDetector.ErrorReason reason) {
<span class="pc bpc" id="L80" title="1 of 2 branches missed.">                    if (listener != null) {</span>
<span class="fc" id="L81">                        listener.onError(</span>
                                AccelerometerGyroscopeAndMagnetometerMeasurementsGenerator.this, reason);
                    }
<span class="fc" id="L84">                }</span>

                @Override
                public void onStaticIntervalDetected(final AccelerometerMeasurementsGenerator generator) {
                    // no action required
<span class="fc" id="L89">                }</span>

                @Override
                public void onDynamicIntervalDetected(final AccelerometerMeasurementsGenerator generator) {
                    // no action required
<span class="fc" id="L94">                }</span>

                @Override
                public void onStaticIntervalSkipped(final AccelerometerMeasurementsGenerator generator) {
                    // no action required
<span class="fc" id="L99">                }</span>

                @Override
                public void onDynamicIntervalSkipped(final AccelerometerMeasurementsGenerator generator) {
                    // no action required
<span class="fc" id="L104">                }</span>

                @Override
                public void onGeneratedMeasurement(
                        final AccelerometerMeasurementsGenerator generator,
                        final StandardDeviationBodyKinematics measurement) {
<span class="pc bpc" id="L110" title="1 of 2 branches missed.">                    if (listener != null) {</span>
<span class="fc" id="L111">                        listener.onGeneratedAccelerometerMeasurement(</span>
                                AccelerometerGyroscopeAndMagnetometerMeasurementsGenerator.this,
                                measurement);
                    }
<span class="fc" id="L115">                }</span>

                @Override
                public void onReset(final AccelerometerMeasurementsGenerator generator) {
                    // no action required
<span class="fc" id="L120">                }</span>
            };

    /**
     * Listener for internal gyroscope measurements generator.
     */
<span class="fc" id="L126">    private final GyroscopeMeasurementsGeneratorListener gyroscopeListener =</span>
<span class="fc" id="L127">            new GyroscopeMeasurementsGeneratorListener() {</span>
                @Override
                public void onInitializationStarted(final GyroscopeMeasurementsGenerator generator) {
                    // no action required
<span class="fc" id="L131">                }</span>

                @Override
                public void onInitializationCompleted(
                        final GyroscopeMeasurementsGenerator generator, final double baseNoiseLevel) {
                    // no action required
<span class="fc" id="L137">                }</span>

                @Override
                public void onError(
                        final GyroscopeMeasurementsGenerator generator,
                        final TriadStaticIntervalDetector.ErrorReason reason) {
                    // no action required
<span class="fc" id="L144">                }</span>

                @Override
                public void onStaticIntervalDetected(final GyroscopeMeasurementsGenerator generator) {
                    // no action required
<span class="fc" id="L149">                }</span>

                @Override
                public void onDynamicIntervalDetected(final GyroscopeMeasurementsGenerator generator) {
                    // no action required
<span class="fc" id="L154">                }</span>

                @Override
                public void onStaticIntervalSkipped(final GyroscopeMeasurementsGenerator generator) {
                    // no action required
<span class="fc" id="L159">                }</span>

                @Override
                public void onDynamicIntervalSkipped(final GyroscopeMeasurementsGenerator generator) {
                    // no action required
<span class="fc" id="L164">                }</span>

                @Override
                public void onGeneratedMeasurement(
                        final GyroscopeMeasurementsGenerator generator,
                        final BodyKinematicsSequence&lt;StandardDeviationTimedBodyKinematics&gt; measurement) {
<span class="pc bpc" id="L170" title="1 of 2 branches missed.">                    if (listener != null) {</span>
<span class="fc" id="L171">                        listener.onGeneratedGyroscopeMeasurement(</span>
                                AccelerometerGyroscopeAndMagnetometerMeasurementsGenerator.this, measurement);
                    }
<span class="fc" id="L174">                }</span>

                @Override
                public void onReset(final GyroscopeMeasurementsGenerator generator) {
                    // no action required
<span class="fc" id="L179">                }</span>
            };

    /**
     * Listener for internal magnetometer measurements generator.
     */
<span class="fc" id="L185">    private final MagnetometerMeasurementsGeneratorListener magnetometerListener =</span>
<span class="fc" id="L186">            new MagnetometerMeasurementsGeneratorListener() {</span>
                @Override
                public void onInitializationStarted(final MagnetometerMeasurementsGenerator generator) {
<span class="pc bpc" id="L189" title="1 of 2 branches missed.">                    if (listener != null) {</span>
<span class="fc" id="L190">                        listener.onInitializationStarted(</span>
                                AccelerometerGyroscopeAndMagnetometerMeasurementsGenerator.this);
                    }
<span class="fc" id="L193">                }</span>

                @Override
                public void onInitializationCompleted(
                        final MagnetometerMeasurementsGenerator generator, final double baseNoiseLevel) {
<span class="pc bpc" id="L198" title="1 of 2 branches missed.">                    if (listener != null) {</span>
<span class="fc" id="L199">                        listener.onInitializationCompleted(</span>
                                AccelerometerGyroscopeAndMagnetometerMeasurementsGenerator.this,
                                baseNoiseLevel);
                    }
<span class="fc" id="L203">                }</span>

                @Override
                public void onError(final MagnetometerMeasurementsGenerator generator,
                                    final TriadStaticIntervalDetector.ErrorReason reason) {
                    // no action required
<span class="fc" id="L209">                }</span>

                @Override
                public void onStaticIntervalDetected(final MagnetometerMeasurementsGenerator generator) {
<span class="pc bpc" id="L213" title="1 of 2 branches missed.">                    if (listener != null) {</span>
<span class="fc" id="L214">                        listener.onStaticIntervalDetected(</span>
                                AccelerometerGyroscopeAndMagnetometerMeasurementsGenerator.this);
                    }
<span class="fc" id="L217">                }</span>

                @Override
                public void onDynamicIntervalDetected(final MagnetometerMeasurementsGenerator generator) {
<span class="pc bpc" id="L221" title="1 of 2 branches missed.">                    if (listener != null) {</span>
<span class="fc" id="L222">                        listener.onDynamicIntervalDetected(</span>
                                AccelerometerGyroscopeAndMagnetometerMeasurementsGenerator.this);
                    }
<span class="fc" id="L225">                }</span>

                @Override
                public void onStaticIntervalSkipped(final MagnetometerMeasurementsGenerator generator) {
<span class="pc bpc" id="L229" title="1 of 2 branches missed.">                    if (listener != null) {</span>
<span class="fc" id="L230">                        listener.onStaticIntervalSkipped(</span>
                                AccelerometerGyroscopeAndMagnetometerMeasurementsGenerator.this);
                    }
<span class="fc" id="L233">                }</span>

                @Override
                public void onDynamicIntervalSkipped(final MagnetometerMeasurementsGenerator generator) {
<span class="pc bpc" id="L237" title="1 of 2 branches missed.">                    if (listener != null) {</span>
<span class="fc" id="L238">                        listener.onDynamicIntervalSkipped(</span>
                                AccelerometerGyroscopeAndMagnetometerMeasurementsGenerator.this);
                    }
<span class="fc" id="L241">                }</span>

                @Override
                public void onGeneratedMeasurement(
                        final MagnetometerMeasurementsGenerator generator,
                        final StandardDeviationBodyMagneticFluxDensity measurement) {
<span class="pc bpc" id="L247" title="1 of 2 branches missed.">                    if (listener != null) {</span>
<span class="fc" id="L248">                        listener.onGeneratedMagnetometerMeasurement(</span>
                                AccelerometerGyroscopeAndMagnetometerMeasurementsGenerator.this, measurement);
                    }
<span class="fc" id="L251">                }</span>

                @Override
                public void onReset(final MagnetometerMeasurementsGenerator generator) {
                    // no action required
<span class="fc" id="L256">                }</span>
            };

    /**
     * Internal accelerometer measurements generator.
     */
<span class="fc" id="L262">    private final AccelerometerMeasurementsGenerator accelerometerMeasurementsGenerator =</span>
            new AccelerometerMeasurementsGenerator(accelerometerListener);

    /**
     * Internal gyroscope measurements generator.
     */
<span class="fc" id="L268">    private final GyroscopeMeasurementsGenerator gyroscopeMeasurementsGenerator =</span>
            new GyroscopeMeasurementsGenerator(gyroscopeListener);

    /**
     * Internal magnetometer measurements generator.
     */
<span class="fc" id="L274">    private final MagnetometerMeasurementsGenerator magnetometerMeasurementsGenerator =</span>
            new MagnetometerMeasurementsGenerator(magnetometerListener);

    /**
     * Indicates whether generator is running or not.
     */
    private boolean running;

    /**
     * Timed body kinematics instance to be reused.
     */
<span class="fc" id="L285">    private final TimedBodyKinematics timedKinematics = new TimedBodyKinematics();</span>

    /**
     * Constructor.
     */
<span class="fc" id="L290">    public AccelerometerGyroscopeAndMagnetometerMeasurementsGenerator() {</span>
<span class="fc" id="L291">    }</span>

    /**
     * Constructor.
     *
     * @param listener listener to handle events raised by this generator.
     */
    public AccelerometerGyroscopeAndMagnetometerMeasurementsGenerator(
            final AccelerometerGyroscopeAndMagnetometerMeasurementsGeneratorListener listener) {
<span class="fc" id="L300">        this();</span>
<span class="fc" id="L301">        this.listener = listener;</span>
<span class="fc" id="L302">    }</span>

    /**
     * Gets time interval between input samples expressed in seconds (s).
     *
     * @return time interval between input samples.
     */
    public double getTimeInterval() {
<span class="fc" id="L310">        return accelerometerMeasurementsGenerator.getTimeInterval();</span>
    }

    /**
     * Sets time interval between input samples expressed in seconds (s).
     *
     * @param timeInterval time interval between input samples.
     * @throws IllegalArgumentException if provided value is negative.
     * @throws LockedException          if generator is currently running.
     */
    public void setTimeInterval(final double timeInterval) throws LockedException {
<span class="fc bfc" id="L321" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L322">            throw new LockedException();</span>
        }

<span class="fc bfc" id="L325" title="All 2 branches covered.">        if (timeInterval &lt; 0.0) {</span>
<span class="fc" id="L326">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L329">        accelerometerMeasurementsGenerator.setTimeInterval(timeInterval);</span>
<span class="fc" id="L330">        gyroscopeMeasurementsGenerator.setTimeInterval(timeInterval);</span>
<span class="fc" id="L331">        magnetometerMeasurementsGenerator.setTimeInterval(timeInterval);</span>
<span class="fc" id="L332">    }</span>

    /**
     * Gets time interval between input samples.
     *
     * @return time interval between input samples.
     */
    public Time getTimeIntervalAsTime() {
<span class="fc" id="L340">        return new Time(getTimeInterval(), TimeUnit.SECOND);</span>
    }

    /**
     * Gets time interval between input samples.
     *
     * @param result instance where time interval will be stored.
     */
    public void getTimeIntervalAsTime(final Time result) {
<span class="fc" id="L349">        result.setValue(getTimeInterval());</span>
<span class="fc" id="L350">        result.setUnit(TimeUnit.SECOND);</span>
<span class="fc" id="L351">    }</span>

    /**
     * Sets time interval between input samples.
     *
     * @param timeInterval time interval between input samples.
     * @throws IllegalArgumentException if provided value is negative.
     * @throws LockedException          if estimator is currently running.
     */
    public void setTimeInterval(final Time timeInterval) throws LockedException {
<span class="fc" id="L361">        setTimeInterval(TimeConverter.convert(timeInterval.getValue().doubleValue(), timeInterval.getUnit(),</span>
                TimeUnit.SECOND));
<span class="fc" id="L363">    }</span>

    /**
     * Gets minimum number of samples required in a static interval to be taken into account.
     * Smaller static intervals will be discarded.
     *
     * @return minimum number of samples required in a static interval to be taken into account.
     */
    public int getMinStaticSamples() {
<span class="fc" id="L372">        return accelerometerMeasurementsGenerator.getMinStaticSamples();</span>
    }

    /**
     * Sets minimum number of samples required in a static interval to be taken into account.
     * Smaller static intervals will be discarded.
     *
     * @param minStaticSamples minimum number of samples required in a static interval to be
     *                         taken into account.
     * @throws LockedException          if generator is busy.
     * @throws IllegalArgumentException if provided value is less than 2.
     */
    public void setMinStaticSamples(final int minStaticSamples) throws LockedException {
<span class="fc bfc" id="L385" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L386">            throw new LockedException();</span>
        }

<span class="fc" id="L389">        accelerometerMeasurementsGenerator.setMinStaticSamples(minStaticSamples);</span>
<span class="fc" id="L390">        gyroscopeMeasurementsGenerator.setMinStaticSamples(minStaticSamples);</span>
<span class="fc" id="L391">        magnetometerMeasurementsGenerator.setMinStaticSamples(minStaticSamples);</span>
<span class="fc" id="L392">    }</span>

    /**
     * Gets maximum number of samples allowed in dynamic intervals.
     *
     * @return maximum number of samples allowed in dynamic intervals.
     */
    public int getMaxDynamicSamples() {
<span class="fc" id="L400">        return accelerometerMeasurementsGenerator.getMaxDynamicSamples();</span>
    }

    /**
     * Sets maximum number of samples allowed in dynamic intervals.
     *
     * @param maxDynamicSamples maximum number of samples allowed in dynamic intervals.
     * @throws LockedException          if generator is busy.
     * @throws IllegalArgumentException if provided value is less than 2.
     */
    public void setMaxDynamicSamples(final int maxDynamicSamples) throws LockedException {
<span class="fc bfc" id="L411" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L412">            throw new LockedException();</span>
        }

<span class="fc" id="L415">        accelerometerMeasurementsGenerator.setMaxDynamicSamples(maxDynamicSamples);</span>
<span class="fc" id="L416">        gyroscopeMeasurementsGenerator.setMaxDynamicSamples(maxDynamicSamples);</span>
<span class="fc" id="L417">        magnetometerMeasurementsGenerator.setMaxDynamicSamples(maxDynamicSamples);</span>
<span class="fc" id="L418">    }</span>

    /**
     * Gets listener to handle generated events.
     *
     * @return listener to handle generated events.
     */
    public AccelerometerGyroscopeAndMagnetometerMeasurementsGeneratorListener getListener() {
<span class="fc" id="L426">        return listener;</span>
    }

    /**
     * Sets listener to handle generated events.
     *
     * @param listener listener to handle generated events.
     * @throws LockedException if generator is busy.
     */
    public void setListener(final AccelerometerGyroscopeAndMagnetometerMeasurementsGeneratorListener listener)
            throws LockedException {
<span class="fc bfc" id="L437" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L438">            throw new LockedException();</span>
        }

<span class="fc" id="L441">        this.listener = listener;</span>
<span class="fc" id="L442">    }</span>

    /**
     * Gets length of number of samples to keep within the window being processed
     * to determine instantaneous accelerometer noise level.
     *
     * @return length of number of samples to keep within the window.
     */
    public int getWindowSize() {
<span class="fc" id="L451">        return accelerometerMeasurementsGenerator.getWindowSize();</span>
    }

    /**
     * Sets length of number of samples to keep within the window being processed
     * to determine instantaneous accelerometer noise level.
     * Window size must always be larger than allowed minimum value, which is 2 and
     * must have an odd value.
     *
     * @param windowSize length of number of samples to keep within the window.
     * @throws LockedException          if detector is busy processing a previous sample.
     * @throws IllegalArgumentException if provided value is not valid.
     */
    public void setWindowSize(final int windowSize) throws LockedException {
<span class="fc bfc" id="L465" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L466">            throw new LockedException();</span>
        }

<span class="fc" id="L469">        accelerometerMeasurementsGenerator.setWindowSize(windowSize);</span>
<span class="fc" id="L470">        gyroscopeMeasurementsGenerator.setWindowSize(windowSize);</span>
<span class="fc" id="L471">        magnetometerMeasurementsGenerator.setWindowSize(windowSize);</span>
<span class="fc" id="L472">    }</span>

    /**
     * Gets number of samples to be processed initially while keeping the sensor static in order
     * to find the base noise level when device is static.
     *
     * @return number of samples to be processed initially.
     */
    public int getInitialStaticSamples() {
<span class="fc" id="L481">        return accelerometerMeasurementsGenerator.getInitialStaticSamples();</span>
    }

    /**
     * Sets number of samples to be processed initially while keeping the sensor static in order
     * to find the base noise level when device is static.
     *
     * @param initialStaticSamples number of samples to be processed initially.
     * @throws LockedException          if detector is busy.
     * @throws IllegalArgumentException if provided value is less than
     *                                  {@link TriadStaticIntervalDetector#MINIMUM_INITIAL_STATIC_SAMPLES}
     */
    public void setInitialStaticSamples(final int initialStaticSamples) throws LockedException {
<span class="fc bfc" id="L494" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L495">            throw new LockedException();</span>
        }

<span class="fc" id="L498">        accelerometerMeasurementsGenerator.setInitialStaticSamples(initialStaticSamples);</span>
<span class="fc" id="L499">        gyroscopeMeasurementsGenerator.setInitialStaticSamples(initialStaticSamples);</span>
<span class="fc" id="L500">        magnetometerMeasurementsGenerator.setInitialStaticSamples(initialStaticSamples);</span>
<span class="fc" id="L501">    }</span>

    /**
     * Gets factor to be applied to detected base noise level in order to
     * determine threshold for static/dynamic period changes. This factor is
     * unit-less.
     *
     * @return factor to be applied to detected base noise level.
     */
    public double getThresholdFactor() {
<span class="fc" id="L511">        return accelerometerMeasurementsGenerator.getThresholdFactor();</span>
    }

    /**
     * Sets factor to be applied to detected base noise level in order to
     * determine threshold for static/dynamic period changes. This factor is
     * unit-less.
     *
     * @param thresholdFactor factor to be applied to detected base noise level.
     * @throws LockedException          if detector is busy.
     * @throws IllegalArgumentException if provided value is zero or negative.
     */
    public void setThresholdFactor(final double thresholdFactor) throws LockedException {
<span class="fc bfc" id="L524" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L525">            throw new LockedException();</span>
        }

<span class="fc" id="L528">        accelerometerMeasurementsGenerator.setThresholdFactor(thresholdFactor);</span>
<span class="fc" id="L529">        gyroscopeMeasurementsGenerator.setThresholdFactor(thresholdFactor);</span>
<span class="fc" id="L530">        magnetometerMeasurementsGenerator.setThresholdFactor(thresholdFactor);</span>
<span class="fc" id="L531">    }</span>

    /**
     * Gets factor to determine that a sudden movement has occurred during
     * initialization if instantaneous noise level exceeds accumulated noise
     * level by this factor amount.
     * This factor is unit-less.
     *
     * @return factor to determine that a sudden movement has occurred.
     */
    public double getInstantaneousNoiseLevelFactor() {
<span class="fc" id="L542">        return accelerometerMeasurementsGenerator.getInstantaneousNoiseLevelFactor();</span>
    }

    /**
     * Sets factor to determine that a sudden movement has occurred during
     * initialization if instantaneous noise level exceeds accumulated noise
     * level by this factor amount.
     * This factor is unit-less.
     *
     * @param instantaneousNoiseLevelFactor factor to determine that a sudden
     *                                      movement has occurred during
     *                                      initialization.
     * @throws LockedException          if detector is busy.
     * @throws IllegalArgumentException if provided value is zero or negative.
     */
    public void setInstantaneousNoiseLevelFactor(final double instantaneousNoiseLevelFactor) throws LockedException {
<span class="fc bfc" id="L558" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L559">            throw new LockedException();</span>
        }

<span class="fc" id="L562">        accelerometerMeasurementsGenerator.setInstantaneousNoiseLevelFactor(instantaneousNoiseLevelFactor);</span>
<span class="fc" id="L563">        gyroscopeMeasurementsGenerator.setInstantaneousNoiseLevelFactor(instantaneousNoiseLevelFactor);</span>
<span class="fc" id="L564">        magnetometerMeasurementsGenerator.setInstantaneousNoiseLevelFactor(instantaneousNoiseLevelFactor);</span>
<span class="fc" id="L565">    }</span>

    /**
     * Gets overall absolute threshold to determine whether there has been
     * excessive motion during the whole initialization phase.
     * Failure will be detected if estimated base noise level exceeds this
     * threshold when initialization completes.
     * This threshold is expressed in meters per squared second (m/s^2).
     *
     * @return overall absolute threshold to determine whether there has
     * been excessive motion.
     */
    public double getBaseNoiseLevelAbsoluteThreshold() {
<span class="fc" id="L578">        return accelerometerMeasurementsGenerator.getBaseNoiseLevelAbsoluteThreshold();</span>
    }

    /**
     * Sets overall absolute threshold to determine whether there has been
     * excessive motion during the whole initialization phase.
     * Failure will be detected if estimated base noise level exceeds this
     * threshold when initialization completes.
     * This threshold is expressed in meters per squared second (m/s^2).
     *
     * @param baseNoiseLevelAbsoluteThreshold overall absolute threshold to
     *                                        determine whether there has been
     *                                        excessive motion.
     * @throws LockedException          if detector is busy.
     * @throws IllegalArgumentException if provided value is zero or negative.
     */
    public void setBaseNoiseLevelAbsoluteThreshold(final double baseNoiseLevelAbsoluteThreshold)
            throws LockedException {
<span class="fc bfc" id="L596" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L597">            throw new LockedException();</span>
        }

<span class="fc" id="L600">        accelerometerMeasurementsGenerator.setBaseNoiseLevelAbsoluteThreshold(baseNoiseLevelAbsoluteThreshold);</span>
<span class="fc" id="L601">        gyroscopeMeasurementsGenerator.setBaseNoiseLevelAbsoluteThreshold(baseNoiseLevelAbsoluteThreshold);</span>
<span class="fc" id="L602">        magnetometerMeasurementsGenerator.setBaseNoiseLevelAbsoluteThreshold(baseNoiseLevelAbsoluteThreshold);</span>
<span class="fc" id="L603">    }</span>

    /**
     * Gets overall absolute threshold to determine whether there has been
     * excessive motion during the whole initialization phase.
     * Failure will be detected if estimated base noise level exceeds this
     * threshold when initialization completes.
     *
     * @return overall absolute threshold to determine whether there has been
     * excessive motion.
     */
    public Acceleration getBaseNoiseLevelAbsoluteThresholdAsMeasurement() {
<span class="fc" id="L615">        return accelerometerMeasurementsGenerator.getBaseNoiseLevelAbsoluteThresholdAsMeasurement();</span>
    }

    /**
     * Gets overall absolute threshold to determine whether there has been
     * excessive motion during the whole initialization phase.
     * Failure will be detected if estimated base noise level exceeds this
     * threshold when initialization completes.
     *
     * @param result instance where result will be stored.
     */
    public void getBaseNoiseLevelAbsoluteThresholdAsMeasurement(final Acceleration result) {
<span class="fc" id="L627">        accelerometerMeasurementsGenerator.getBaseNoiseLevelAbsoluteThresholdAsMeasurement(result);</span>
<span class="fc" id="L628">    }</span>

    /**
     * Sets overall absolute threshold to determine whether there has been
     * excessive motion during the whole initialization phase.
     * Failure will be detected if estimated base noise level exceeds this
     * threshold when initialization completes.
     *
     * @param baseNoiseLevelAbsoluteThreshold overall absolute threshold to
     *                                        determine whether there has been
     *                                        excessive motion.
     * @throws LockedException          if detector is busy.
     * @throws IllegalArgumentException if provided value is zero or negative.
     */
    public void setBaseNoiseLevelAbsoluteThreshold(final Acceleration baseNoiseLevelAbsoluteThreshold)
            throws LockedException {
<span class="fc bfc" id="L644" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L645">            throw new LockedException();</span>
        }

<span class="fc" id="L648">        accelerometerMeasurementsGenerator.setBaseNoiseLevelAbsoluteThreshold(baseNoiseLevelAbsoluteThreshold);</span>
<span class="fc" id="L649">        gyroscopeMeasurementsGenerator.setBaseNoiseLevelAbsoluteThreshold(baseNoiseLevelAbsoluteThreshold);</span>
<span class="fc" id="L650">        magnetometerMeasurementsGenerator.setBaseNoiseLevelAbsoluteThreshold(baseNoiseLevelAbsoluteThreshold);</span>
<span class="fc" id="L651">    }</span>

    /**
     * Gets internal status of this generator.
     *
     * @return internal status of this generator.
     */
    public TriadStaticIntervalDetector.Status getStatus() {
<span class="fc" id="L659">        return accelerometerMeasurementsGenerator.getStatus();</span>
    }

    /**
     * Gets accelerometer base noise level that has been detected during
     * initialization expressed in meters per squared second (m/s^2).
     * This is equal to the standard deviation of the accelerometer measurements
     * during initialization phase.
     *
     * @return accelerometer base noise level.
     */
    public double getAccelerometerBaseNoiseLevel() {
<span class="fc" id="L671">        return accelerometerMeasurementsGenerator.getAccelerometerBaseNoiseLevel();</span>
    }

    /**
     * Gets accelerometer base noise level that has been detected during
     * initialization.
     * This is equal to the standard deviation of the accelerometer measurements
     * during initialization phase.
     *
     * @return measurement base noise level.
     */
    public Acceleration getAccelerometerBaseNoiseLevelAsMeasurement() {
<span class="fc" id="L683">        return accelerometerMeasurementsGenerator.getAccelerometerBaseNoiseLevelAsMeasurement();</span>
    }

    /**
     * Gets accelerometer base noise level that has been detected during
     * initialization.
     *
     * @param result instance where result will be stored.
     */
    public void getAccelerometerBaseNoiseLevelAsMeasurement(final Acceleration result) {
<span class="fc" id="L693">        accelerometerMeasurementsGenerator.getAccelerometerBaseNoiseLevelAsMeasurement(result);</span>
<span class="fc" id="L694">    }</span>

    /**
     * Gets accelerometer base noise level PSD (Power Spectral Density)
     * expressed in (m^2 * s^-3).
     *
     * @return accelerometer base noise level PSD.
     */
    public double getAccelerometerBaseNoiseLevelPsd() {
<span class="fc" id="L703">        return accelerometerMeasurementsGenerator.getAccelerometerBaseNoiseLevelPsd();</span>
    }

    /**
     * Gets accelerometer base noise level root PSD (Power Spectral Density)
     * expressed in (m * s^-1.5).
     *
     * @return accelerometer base noise level root PSD.
     */
    @Override
    public double getAccelerometerBaseNoiseLevelRootPsd() {
<span class="fc" id="L714">        return accelerometerMeasurementsGenerator.getAccelerometerBaseNoiseLevelRootPsd();</span>
    }

    /**
     * Gets threshold to determine static/dynamic period changes expressed in
     * meters per squared second (m/s^2).
     *
     * @return threshold to determine static/dynamic period changes.
     */
    public double getThreshold() {
<span class="fc" id="L724">        return accelerometerMeasurementsGenerator.getThreshold();</span>
    }

    /**
     * Gets threshold to determine static/dynamic period changes.
     *
     * @return threshold to determine static/dynamic period changes.
     */
    public Acceleration getThresholdAsMeasurement() {
<span class="fc" id="L733">        return accelerometerMeasurementsGenerator.getThresholdAsMeasurement();</span>
    }

    /**
     * Gets threshold to determine static/dynamic period changes.
     *
     * @param result instance where result will be stored.
     */
    public void getThresholdAsMeasurement(final Acceleration result) {
<span class="fc" id="L742">        accelerometerMeasurementsGenerator.getThresholdAsMeasurement(result);</span>
<span class="fc" id="L743">    }</span>

    /**
     * Gets number of samples that have been processed in a static period so far.
     *
     * @return number of samples that have been processed in a static period so far.
     */
    public int getProcessedStaticSamples() {
<span class="fc" id="L751">        return accelerometerMeasurementsGenerator.getProcessedStaticSamples();</span>
    }

    /**
     * Gets number of samples that have been processed in a dynamic period so far.
     *
     * @return number of samples that have been processed in a dynamic period so far.
     */
    public int getProcessedDynamicSamples() {
<span class="fc" id="L760">        return accelerometerMeasurementsGenerator.getProcessedDynamicSamples();</span>
    }

    /**
     * Indicates whether last static interval must be skipped.
     *
     * @return true if last static interval must be skipped.
     */
    public boolean isStaticIntervalSkipped() {
<span class="fc" id="L769">        return accelerometerMeasurementsGenerator.isStaticIntervalSkipped();</span>
    }

    /**
     * Indicates whether last dynamic interval must be skipped.
     *
     * @return true if last dynamic interval must be skipped.
     */
    public boolean isDynamicIntervalSkipped() {
<span class="fc" id="L778">        return accelerometerMeasurementsGenerator.isDynamicIntervalSkipped();</span>
    }

    /**
     * Indicates whether generator is running or not.
     *
     * @return true if generator is running, false otherwise.
     */
    public boolean isRunning() {
<span class="fc" id="L787">        return running;</span>
    }

    /**
     * Processes a sample of data.
     *
     * @param sample sample of data to be processed.
     * @return true if provided samples has been processed, false if provided triad has been skipped because
     * generator previously failed. If generator previously failed, it will need to be reset before
     * processing additional samples.
     * @throws LockedException if generator is busy processing a previous sample.
     */
    public boolean process(final TimedBodyKinematicsAndMagneticFluxDensity sample) throws LockedException {
<span class="fc bfc" id="L800" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L801">            throw new LockedException();</span>
        }

        try {
<span class="fc" id="L805">            running = true;</span>

<span class="fc" id="L807">            sample.getTimedKinematics(timedKinematics);</span>

<span class="fc bfc" id="L809" title="All 2 branches covered.">            return accelerometerMeasurementsGenerator.process(sample.getKinematics())</span>
<span class="pc bpc" id="L810" title="1 of 2 branches missed.">                    &amp;&amp; gyroscopeMeasurementsGenerator.process(timedKinematics)</span>
<span class="pc bpc" id="L811" title="1 of 2 branches missed.">                    &amp;&amp; magnetometerMeasurementsGenerator.process(sample);</span>
        } finally {
<span class="fc" id="L813">            running = false;</span>
        }
    }

    /**
     * Resets this generator.
     *
     * @throws LockedException if generator is busy.
     */
    public void reset() throws LockedException {
<span class="fc bfc" id="L823" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L824">            throw new LockedException();</span>
        }

<span class="fc" id="L827">        accelerometerMeasurementsGenerator.reset();</span>
<span class="fc" id="L828">        gyroscopeMeasurementsGenerator.reset();</span>
<span class="fc" id="L829">        magnetometerMeasurementsGenerator.reset();</span>

<span class="pc bpc" id="L831" title="1 of 2 branches missed.">        if (listener != null) {</span>
<span class="fc" id="L832">            listener.onReset(this);</span>
        }
<span class="fc" id="L834">    }</span>

    /**
     * Gets estimated average angular rate during initialization phase.
     *
     * @return estimated average angular rate during initialization phase.
     */
    public AngularSpeedTriad getInitialAvgAngularSpeedTriad() {
<span class="fc" id="L842">        return gyroscopeMeasurementsGenerator.getInitialAvgAngularSpeedTriad();</span>
    }

    /**
     * Gets estimated average angular rate during initialization phase.
     *
     * @param result instance where result will be stored.
     */
    public void getInitialAvgAngularSpeedTriad(final AngularSpeedTriad result) {
<span class="fc" id="L851">        gyroscopeMeasurementsGenerator.getInitialAvgAngularSpeedTriad(result);</span>
<span class="fc" id="L852">    }</span>

    /**
     * Gets estimated standard deviation of angular rate during initialization phase.
     *
     * @return estimated standard deviation of angular rate during initialization phase.
     */
    public AngularSpeedTriad getInitialAngularSpeedTriadStandardDeviation() {
<span class="fc" id="L860">        return gyroscopeMeasurementsGenerator.getInitialAngularSpeedTriadStandardDeviation();</span>
    }

    /**
     * Gets estimated standard deviation of angular rate during initialization phase.
     *
     * @param result instance where result will be stored.
     */
    public void getInitialAngularSpeedTriadStandardDeviation(final AngularSpeedTriad result) {
<span class="fc" id="L869">        gyroscopeMeasurementsGenerator.getInitialAngularSpeedTriadStandardDeviation(result);</span>
<span class="fc" id="L870">    }</span>

    /**
     * Gets gyroscope base noise level that has been detected during
     * initialization expressed in radians per second (rad/s).
     * This is equal to the standard deviation of the gyroscope measurements
     * during initialization phase.
     *
     * @return gyroscope base noise level.
     */
    public double getGyroscopeBaseNoiseLevel() {
<span class="fc" id="L881">        return gyroscopeMeasurementsGenerator.getGyroscopeBaseNoiseLevel();</span>
    }

    /**
     * Gets gyroscope base noise level that has been detected during
     * initialization.
     * This is equal to the standard deviation of the gyroscope measurements
     * during initialization phase.
     *
     * @return gyroscope base noise level.
     */
    public AngularSpeed getGyroscopeBaseNoiseLevelAsMeasurement() {
<span class="fc" id="L893">        return gyroscopeMeasurementsGenerator.getGyroscopeBaseNoiseLevelAsMeasurement();</span>
    }

    /**
     * Gets gyroscope base noise level that has been detected during
     * initialization.
     * This is equal to the standard deviation of the gyroscope measurements
     * during initialization phase.
     *
     * @param result instance where result will be stored.
     */
    public void getGyroscopeBaseNoiseLevelAsMeasurement(final AngularSpeed result) {
<span class="fc" id="L905">        gyroscopeMeasurementsGenerator.getGyroscopeBaseNoiseLevelAsMeasurement(result);</span>
<span class="fc" id="L906">    }</span>

    /**
     * Gets gyroscope base noise level PSD (Power Spectral Density)
     * expressed in (rad^2/s).
     *
     * @return gyroscope base noise level PSD.
     */
    public double getGyroscopeBaseNoiseLevelPsd() {
<span class="fc" id="L915">        return gyroscopeMeasurementsGenerator.getGyroscopeBaseNoiseLevelPsd();</span>
    }

    /**
     * Gets gyroscope base noise level root PSD (Power Spectral Density)
     * expressed in (rad * s^-0.5)
     *
     * @return gyroscope base noise level root PSD.
     */
    @Override
    public double getGyroscopeBaseNoiseLevelRootPsd() {
<span class="fc" id="L926">        return gyroscopeMeasurementsGenerator.getGyroscopeBaseNoiseLevelRootPsd();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>