<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GyroscopeMeasurementsGenerator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-navigation-inertial</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.navigation.inertial.calibration.generators</a> &gt; <span class="el_source">GyroscopeMeasurementsGenerator.java</span></div><h1>GyroscopeMeasurementsGenerator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2020 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.navigation.inertial.calibration.generators;

import com.irurueta.navigation.LockedException;
import com.irurueta.navigation.inertial.BodyKinematics;
import com.irurueta.navigation.inertial.calibration.AngularSpeedTriad;
import com.irurueta.navigation.inertial.calibration.BodyKinematicsSequence;
import com.irurueta.navigation.inertial.calibration.GyroscopeNoiseRootPsdSource;
import com.irurueta.navigation.inertial.calibration.StandardDeviationTimedBodyKinematics;
import com.irurueta.navigation.inertial.calibration.TimedBodyKinematics;
import com.irurueta.navigation.inertial.calibration.intervals.TriadStaticIntervalDetector;
import com.irurueta.navigation.inertial.calibration.noise.AccumulatedAngularSpeedTriadNoiseEstimator;
import com.irurueta.units.AngularSpeed;
import com.irurueta.units.AngularSpeedUnit;

import java.util.ArrayList;
import java.util.List;

/**
 * Generates measurements for the calibration of gyroscopes by alternating
 * static and dynamic intervals where device is kept static or moved.
 * Generated measurements must be used with easy gyroscope calibrators.
 * Notice that accuracy of the gyroscope calibration is very sensitive to the
 * accuracy of detected dynamic intervals respect the average specific forces
 * during static intervals.
 * In order to increase the accuracy, calibration should be repeated trying different
 * threshold factors {@link #getThresholdFactor()}.
 * Such calibrators are the following ones:
 * - {@link com.irurueta.navigation.inertial.calibration.gyroscope.EasyGyroscopeCalibrator}
 * - {@link com.irurueta.navigation.inertial.calibration.gyroscope.KnownBiasEasyGyroscopeCalibrator}
 * - {@link com.irurueta.navigation.inertial.calibration.gyroscope.RobustEasyGyroscopeCalibrator} and all its
 * implementations.
 * - {@link com.irurueta.navigation.inertial.calibration.gyroscope.RobustKnownBiasEasyGyroscopeCalibrator} and all its
 * implementations.
 */
public class GyroscopeMeasurementsGenerator extends
        MeasurementsGenerator&lt;BodyKinematicsSequence&lt;StandardDeviationTimedBodyKinematics&gt;,
                GyroscopeMeasurementsGenerator, GyroscopeMeasurementsGeneratorListener, TimedBodyKinematics&gt;
        implements GyroscopeNoiseRootPsdSource {

    /**
     * An angular speed triad.
     * This is reused for memory efficiency.
     */
<span class="fc" id="L59">    protected final AngularSpeedTriad angularSpeedTriad = new AngularSpeedTriad();</span>

    /**
     * Items to be added to a generated sequence when next static period occurs.
     */
    private List&lt;StandardDeviationTimedBodyKinematics&gt; currentSequenceItems;

    /**
     * Accumulated noise estimator for angular speed measurements.
     */
<span class="fc" id="L69">    private final AccumulatedAngularSpeedTriadNoiseEstimator accumulatedEstimator =</span>
            new AccumulatedAngularSpeedTriadNoiseEstimator();

    /**
     * Estimated acceleration standard deviation during initialization expressed
     * in meters per squared second (m/s^2).
     */
    private double accelerationStandardDeviation;

    /**
     * Estimated angular speed standard deviation during initialization expressed
     * in radians per second (rad/s).
     */
    private double angularSpeedStandardDeviation;

    /**
     * Estimated norm of gyroscope noise root PSD (Power Spectral Density)
     * expressed as (rad * s^-0.5).
     */
    private double angularSpeedNoiseRootPsd;

    /**
     * Previous average x-coordinate of measurements expressed in meters
     * per squared second (m/s^2).
     */
    private Double previousAvgX;

    /**
     * Previous average y-coordinate of measurements expressed in meters
     * per squared second (m/s^2).
     */
    private Double previousAvgY;

    /**
     * Previous average z-coordinate of measurements expressed in meters
     * per squared second (m/s^2).
     */
    private Double previousAvgZ;

    /**
     * Current average x-coordinate of measurements expressed in meters
     * per squared second (m/s^2).
     */
    private Double currentAvgX;

    /**
     * Current average y-coordinate of measurements expressed in meters
     * per squared second (m/s^2).
     */
    private Double currentAvgY;

    /**
     * Current average z-coordinate of measurements expressed in meters
     * per squared second (m/s^2).
     */
    private Double currentAvgZ;

    /**
     * Contains previous status while processing samples.
     */
    private TriadStaticIntervalDetector.Status previousStatus;

    /**
     * Constructor.
     */
    public GyroscopeMeasurementsGenerator() {
<span class="fc" id="L135">        super();</span>
<span class="fc" id="L136">    }</span>

    /**
     * Constructor.
     *
     * @param listener listener to handle events raised by this generator.
     */
    public GyroscopeMeasurementsGenerator(final GyroscopeMeasurementsGeneratorListener listener) {
<span class="fc" id="L144">        super(listener);</span>
<span class="fc" id="L145">    }</span>

    /**
     * Sets time interval between input samples expressed in seconds (s).
     *
     * @param timeInterval time interval between input samples.
     * @throws IllegalArgumentException if provided value is negative.
     * @throws LockedException          if generator is currently running.
     */
    @Override
    public void setTimeInterval(final double timeInterval) throws LockedException {
<span class="fc" id="L156">        super.setTimeInterval(timeInterval);</span>
<span class="fc" id="L157">        accumulatedEstimator.setTimeInterval(timeInterval);</span>
<span class="fc" id="L158">    }</span>

    /**
     * Resets this generator.
     *
     * @throws LockedException if generator is busy.
     */
    @Override
    public void reset() throws LockedException {
<span class="fc" id="L167">        super.reset();</span>

<span class="fc" id="L169">        currentSequenceItems = null;</span>

<span class="fc" id="L171">        accelerationStandardDeviation = 0.0;</span>
<span class="fc" id="L172">        angularSpeedStandardDeviation = 0.0;</span>

<span class="fc" id="L174">        previousAvgX = null;</span>
<span class="fc" id="L175">        previousAvgY = null;</span>
<span class="fc" id="L176">        previousAvgZ = null;</span>

<span class="fc" id="L178">        currentAvgX = null;</span>
<span class="fc" id="L179">        currentAvgY = null;</span>
<span class="fc" id="L180">        currentAvgZ = null;</span>

<span class="fc" id="L182">        accumulatedEstimator.reset();</span>

<span class="fc" id="L184">        previousStatus = null;</span>
<span class="fc" id="L185">    }</span>

    /**
     * Gets estimated average angular rate during initialization phase.
     *
     * @return estimated average angular rate during initialization phase.
     */
    public AngularSpeedTriad getInitialAvgAngularSpeedTriad() {
<span class="fc" id="L193">        return accumulatedEstimator.getAvgTriad();</span>
    }

    /**
     * Gets estimated average angular rate during initialization phase.
     *
     * @param result instance where result will be stored.
     */
    public void getInitialAvgAngularSpeedTriad(final AngularSpeedTriad result) {
<span class="fc" id="L202">        accumulatedEstimator.getAvgTriad(result);</span>
<span class="fc" id="L203">    }</span>

    /**
     * Gets estimated standard deviation of angular rate during initialization phase.
     *
     * @return estimated standard deviation of angular rate during initialization phase.
     */
    public AngularSpeedTriad getInitialAngularSpeedTriadStandardDeviation() {
<span class="fc" id="L211">        return accumulatedEstimator.getStandardDeviationTriad();</span>
    }

    /**
     * Gets estimated standard deviation of angular rate during initialization phase.
     *
     * @param result instance where result will be stored.
     */
    public void getInitialAngularSpeedTriadStandardDeviation(final AngularSpeedTriad result) {
<span class="fc" id="L220">        accumulatedEstimator.getStandardDeviationTriad(result);</span>
<span class="fc" id="L221">    }</span>

    /**
     * Gets gyroscope base noise level that has been detected during
     * initialization expressed in radians per second (rad/s).
     * This is equal to the standard deviation of the gyroscope measurements
     * during initialization phase.
     *
     * @return gyroscope base noise level.
     */
    public double getGyroscopeBaseNoiseLevel() {
<span class="fc" id="L232">        return angularSpeedStandardDeviation;</span>
    }

    /**
     * Gets gyroscope base noise level that has been detected during
     * initialization.
     * This is equal to the standard deviation of the gyroscope measurements
     * during initialization phase.
     *
     * @return gyroscope base noise level.
     */
    public AngularSpeed getGyroscopeBaseNoiseLevelAsMeasurement() {
<span class="fc" id="L244">        return new AngularSpeed(angularSpeedStandardDeviation, AngularSpeedUnit.RADIANS_PER_SECOND);</span>
    }

    /**
     * Gets gyroscope base noise level that has been detected during
     * initialization.
     * This is equal to the standard deviation of the gyroscope measurements
     * during initialization phase.
     *
     * @param result instance where result will be stored.
     */
    public void getGyroscopeBaseNoiseLevelAsMeasurement(final AngularSpeed result) {
<span class="fc" id="L256">        result.setValue(angularSpeedStandardDeviation);</span>
<span class="fc" id="L257">        result.setUnit(AngularSpeedUnit.RADIANS_PER_SECOND);</span>
<span class="fc" id="L258">    }</span>

    /**
     * Gets gyroscope base noise level PSD (Power Spectral Density)
     * expressed in (rad^2/s).
     *
     * @return gyroscope base noise level PSD.
     */
    public double getGyroscopeBaseNoiseLevelPsd() {
<span class="fc" id="L267">        return angularSpeedNoiseRootPsd * angularSpeedNoiseRootPsd;</span>
    }

    /**
     * Gets gyroscope base noise level root PSD (Power Spectral Density)
     * expressed in (rad * s^-0.5)
     *
     * @return gyroscope base noise level root PSD.
     */
    @Override
    public double getGyroscopeBaseNoiseLevelRootPsd() {
<span class="fc" id="L278">        return angularSpeedNoiseRootPsd;</span>
    }

    /**
     * Post process provided input sample.
     *
     * @param sample an input sample.
     * @throws LockedException if generator is busy.
     */
    @Override
    protected void postProcess(final TimedBodyKinematics sample) throws LockedException {
<span class="fc" id="L289">        final var status = staticIntervalDetector.getStatus();</span>

<span class="fc bfc" id="L291" title="All 2 branches covered.">        if (status == TriadStaticIntervalDetector.Status.INITIALIZING) {</span>
<span class="fc" id="L292">            sample.getKinematics().getAngularRateTriad(angularSpeedTriad);</span>
<span class="fc" id="L293">            accumulatedEstimator.addTriad(angularSpeedTriad);</span>
        }

        // while we are in a dynamic interval, we must record all timed kinematics
        // along with accelerometer and gyroscope standard deviations
<span class="fc bfc" id="L298" title="All 2 branches covered.">        if (status == TriadStaticIntervalDetector.Status.DYNAMIC_INTERVAL) {</span>
<span class="fc bfc" id="L299" title="All 2 branches covered.">            if (isDynamicIntervalSkipped()) {</span>
                // dynamic interval has been skipped because there were too many
                // items in the sequence.
<span class="fc" id="L302">                currentSequenceItems = null;</span>
            } else {
<span class="pc bpc" id="L304" title="1 of 2 branches missed.">                if (previousStatus == TriadStaticIntervalDetector.Status.STATIC_INTERVAL) {</span>
<span class="fc" id="L305">                    previousAvgX = staticIntervalDetector.getAccumulatedAvgX();</span>
<span class="fc" id="L306">                    previousAvgY = staticIntervalDetector.getAccumulatedAvgY();</span>
<span class="fc" id="L307">                    previousAvgZ = staticIntervalDetector.getAccumulatedAvgZ();</span>
                }

<span class="fc" id="L310">                addSequenceItem(sample);</span>
            }
<span class="pc bpc" id="L312" title="1 of 6 branches missed.">        } else if (status == TriadStaticIntervalDetector.Status.STATIC_INTERVAL</span>
                &amp;&amp; previousStatus == TriadStaticIntervalDetector.Status.DYNAMIC_INTERVAL
<span class="pc bpc" id="L314" title="1 of 2 branches missed.">                &amp;&amp; currentSequenceItems != null &amp;&amp; !currentSequenceItems.isEmpty()) {</span>

<span class="fc" id="L316">            currentAvgX = staticIntervalDetector.getInstantaneousAvgX();</span>
<span class="fc" id="L317">            currentAvgY = staticIntervalDetector.getInstantaneousAvgY();</span>
<span class="fc" id="L318">            currentAvgZ = staticIntervalDetector.getInstantaneousAvgZ();</span>

            // we have all required data to generate a sequence
<span class="fc" id="L321">            BodyKinematicsSequence&lt;StandardDeviationTimedBodyKinematics&gt; sequence = null;</span>
<span class="pc bpc" id="L322" title="1 of 2 branches missed.">            if (listener != null) {</span>
<span class="fc" id="L323">                sequence = new BodyKinematicsSequence&lt;&gt;();</span>
<span class="fc" id="L324">                sequence.setBeforeMeanSpecificForceCoordinates(previousAvgX, previousAvgY, previousAvgZ);</span>
<span class="fc" id="L325">                sequence.setItems(currentSequenceItems);</span>
<span class="fc" id="L326">                sequence.setAfterMeanSpecificForceCoordinates(currentAvgX, currentAvgY, currentAvgZ);</span>
            }

<span class="fc" id="L329">            currentSequenceItems = null;</span>

<span class="pc bpc" id="L331" title="1 of 2 branches missed.">            if (listener != null) {</span>
<span class="fc" id="L332">                listener.onGeneratedMeasurement(this, sequence);</span>
            }
        }
<span class="fc" id="L335">    }</span>

    /**
     * Gets corresponding acceleration triad from provided input sample.
     * This method must store the result into {@link #triad}.
     *
     * @param sample input sample.
     */
    @Override
    protected void getAccelerationTriadFromInputSample(final TimedBodyKinematics sample) {
<span class="fc" id="L345">        sample.getKinematics().getSpecificForceTriad(triad);</span>
<span class="fc" id="L346">    }</span>

    /**
     * Handles a static-to-dynamic interval change.
     *
     * @param accumulatedAvgX average x-coordinate of measurements during last
     *                        static period expressed in meters per squared
     *                        second (m/s^2).
     * @param accumulatedAvgY average y-coordinate of specific force during last
     *                        static period expressed in meters per squared
     *                        second (m/s^2).
     * @param accumulatedAvgZ average z-coordinate of specific force during last
     *                        static period expressed in meters per squared
     *                        second (m/s^2).
     * @param accumulatedStdX standard deviation of x-coordinate of measurements
     *                        during last static period expressed in meters per
     *                        squared second (m/s^2).
     * @param accumulatedStdY standard deviation of y-coordinate of measurements
     *                        during last static period expressed in meters per
     *                        squared second (m/s^2).
     * @param accumulatedStdZ standard deviation of z-coordinate of measurements
     *                        during last static period expressed in meters per
     *                        squared second (m/s^2).
     */
    @Override
    protected void handleStaticToDynamicChange(
            final double accumulatedAvgX, final double accumulatedAvgY, final double accumulatedAvgZ,
            final double accumulatedStdX, final double accumulatedStdY, final double accumulatedStdZ) {
<span class="fc" id="L374">        previousStatus = TriadStaticIntervalDetector.Status.STATIC_INTERVAL;</span>
<span class="fc" id="L375">    }</span>

    /**
     * Handles a dynamic-to-static interval change.
     */
    @Override
    protected void handleDynamicToStaticChange() {
<span class="fc" id="L382">        previousStatus = TriadStaticIntervalDetector.Status.DYNAMIC_INTERVAL;</span>
<span class="fc" id="L383">    }</span>

    /**
     * Handles an initialization completion.
     */
    @Override
    protected void handleInitializationCompleted() {
<span class="fc" id="L390">        accelerationStandardDeviation = staticIntervalDetector.getBaseNoiseLevel();</span>
<span class="fc" id="L391">        angularSpeedStandardDeviation = accumulatedEstimator.getStandardDeviationNorm();</span>
<span class="fc" id="L392">        angularSpeedNoiseRootPsd = accumulatedEstimator.getNoiseRootPsdNorm();</span>

<span class="fc" id="L394">        previousStatus = staticIntervalDetector.getStatus();</span>
<span class="fc" id="L395">    }</span>

    /**
     * Handles an error during initialization.
     */
    @Override
    protected void handleInitializationFailed() {
<span class="fc" id="L402">        previousStatus = null;</span>

        try {
<span class="fc" id="L405">            accumulatedEstimator.reset();</span>
<span class="nc" id="L406">        } catch (final LockedException ignore) {</span>
            // no action needed
<span class="fc" id="L408">        }</span>
<span class="fc" id="L409">    }</span>

    /**
     * Adds an item to current sequence items.
     *
     * @param sample sample to generate a sequence item from.
     */
    private void addSequenceItem(final TimedBodyKinematics sample) {
<span class="fc bfc" id="L417" title="All 2 branches covered.">        if (currentSequenceItems == null) {</span>
<span class="fc" id="L418">            currentSequenceItems = new ArrayList&lt;&gt;();</span>
        }

<span class="fc" id="L421">        final var kinematics = new BodyKinematics(sample.getKinematics());</span>
<span class="fc" id="L422">        final var timestampSeconds = sample.getTimestampSeconds();</span>
<span class="fc" id="L423">        final var stdTimedKinematics = new StandardDeviationTimedBodyKinematics(kinematics, timestampSeconds,</span>
                accelerationStandardDeviation, angularSpeedStandardDeviation);
<span class="fc" id="L425">        currentSequenceItems.add(stdTimedKinematics);</span>
<span class="fc" id="L426">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>