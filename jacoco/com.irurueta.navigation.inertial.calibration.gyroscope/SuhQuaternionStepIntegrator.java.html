<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SuhQuaternionStepIntegrator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-navigation-inertial</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.navigation.inertial.calibration.gyroscope</a> &gt; <span class="el_source">SuhQuaternionStepIntegrator.java</span></div><h1>SuhQuaternionStepIntegrator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2023 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.navigation.inertial.calibration.gyroscope;

import com.irurueta.algebra.AlgebraException;
import com.irurueta.algebra.FrobeniusNormComputer;
import com.irurueta.algebra.Matrix;
import com.irurueta.geometry.Quaternion;
import com.irurueta.geometry.Rotation3D;
import com.irurueta.geometry.RotationException;

/**
 * Computes an integration step of a quaternion using Suh's method.
 * More information available here:
 * Young Soo Suh. &quot;Orientation estimation using a quaternion-based indirect Kalman filter with adaptive estimation of
 * external acceleration&quot;. 2010.
 */
public class SuhQuaternionStepIntegrator extends QuaternionStepIntegrator {

    /**
     * Precomputed 3/4 factor
     */
    private static final double THREE_FOURTHS = 3.0 / 4.0;

    /**
     * Angular speed at initial timestamp t0 to be reused.
     */
    private Matrix omega0;

    /**
     * Angular speed at end timestamp t1 to be reused.
     */
    private Matrix omega1;

    /**
     * Initial attitude to be reused.
     */
    private Matrix quat;

    /**
     * Skew matrix of omega0 to be reused.
     */
    private Matrix omegaSkew0;

    /**
     * Skew matrix of omega1 to be reused.
     */
    private Matrix omegaSkew1;

    /**
     * Constant matrix to be reused.
     */
    private Matrix constant;

    /**
     * Temporary matrix to be reused.
     */
    private Matrix omegaSkew10;

    /**
     * Identity matrix to be reused.
     */
    private Matrix identity;

    /**
     * Temporary matrix to be reused.
     */
    private Matrix omegaSkew1A;

    /**
     * Temporary matrix to be reused.
     */
    private Matrix omegaSkew0A;

    /**
     * Temporary matrix to be reused.
     */
    private Matrix omegaSkew1B;

    /**
     * Temporary matrix to be reused.
     */
    private Matrix tmp;

    /**
     * Instance where result of integration is stored in matrix form being reused.
     */
    private Matrix quatResult;

    /**
     * Constructor.
     * Initializes matrices being reused.
     */
<span class="fc" id="L107">    public SuhQuaternionStepIntegrator() {</span>
        try {
<span class="fc" id="L109">            omega0 = new Matrix(Rotation3D.INHOM_COORDS, 1);</span>
<span class="fc" id="L110">            omega1 = new Matrix(Rotation3D.INHOM_COORDS, 1);</span>
<span class="fc" id="L111">            quat = new Matrix(Quaternion.N_PARAMS, 1);</span>
<span class="fc" id="L112">            omegaSkew0 = new Matrix(Quaternion.N_PARAMS, Quaternion.N_PARAMS);</span>
<span class="fc" id="L113">            omegaSkew1 = new Matrix(Quaternion.N_PARAMS, Quaternion.N_PARAMS);</span>
<span class="fc" id="L114">            constant = new Matrix(Quaternion.N_PARAMS, Quaternion.N_PARAMS);</span>
<span class="fc" id="L115">            omegaSkew10 = new Matrix(Quaternion.N_PARAMS, Quaternion.N_PARAMS);</span>
<span class="fc" id="L116">            identity = Matrix.identity(Quaternion.N_PARAMS, Quaternion.N_PARAMS);</span>
<span class="fc" id="L117">            omegaSkew1A = new Matrix(Quaternion.N_PARAMS, Quaternion.N_PARAMS);</span>
<span class="fc" id="L118">            omegaSkew0A = new Matrix(Quaternion.N_PARAMS, Quaternion.N_PARAMS);</span>
<span class="fc" id="L119">            omegaSkew1B = new Matrix(Quaternion.N_PARAMS, Quaternion.N_PARAMS);</span>
<span class="fc" id="L120">            tmp = new Matrix(Quaternion.N_PARAMS, Quaternion.N_PARAMS);</span>
<span class="fc" id="L121">            quatResult = new Matrix(Quaternion.N_PARAMS, 1);</span>
<span class="nc" id="L122">        } catch (final AlgebraException ignore) {</span>
            // never happens
<span class="fc" id="L124">        }</span>
<span class="fc" id="L125">    }</span>

    /**
     * Gets type of this integrator.
     *
     * @return indicates type of this integrator.
     */
    @Override
    public QuaternionStepIntegratorType getType() {
<span class="fc" id="L134">        return QuaternionStepIntegratorType.SUH;</span>
    }

    /**
     * Performs Suh's integration step.
     * More information available here:
     * Young Soo Suh. &quot;Orientation estimation using a quaternion-based indirect Kalman filter with adaptive estimation
     * of external acceleration&quot;. 2010.
     *
     * @param initialAttitude initial attitude.
     * @param initialWx       initial x-coordinate rotation velocity at initial timestamp expressed
     *                        in radians per second (rad/s).
     * @param initialWy       initial y-coordinate rotation velocity at initial timestamp expressed
     *                        in radians per second (rad/s).
     * @param initialWz       initial z-coordinate rotation velocity at initial timestamp expressed
     *                        in radians per second (rad/s).*
     * @param currentWx       end x-coordinate rotation velocity at current timestamp expressed in
     *                        radians per second (rad/s).
     * @param currentWy       end y-coordinate rotation velocity at current timestamp expressed in
     *                        radians per second (rad/s).
     * @param currentWz       end z-coordinate rotation velocity at current timestamp expressed in
     *                        radians per second (rad/s).
     * @param dt              time step expressed in seconds.
     * @param result          instance where result of integration will be stored.
     * @throws RotationException if a numerical error occurs.
     */
    @Override
    public void integrate(
            final Quaternion initialAttitude,
            final double initialWx, final double initialWy, final double initialWz,
            final double currentWx, final double currentWy, final double currentWz,
            final double dt, final Quaternion result) throws RotationException {
<span class="fc" id="L166">        integrationStep(initialAttitude, initialWx, initialWy, initialWz,</span>
                currentWx, currentWy, currentWz, dt, result, omega0, omega1, quat, omegaSkew0,
                omegaSkew1, constant, omegaSkew10, identity, omegaSkew1A, omegaSkew0A,
                omegaSkew1B, tmp, quatResult);
<span class="fc" id="L170">    }</span>

    /**
     * Performs Suh's integration step.
     * More information available here:
     * Young Soo Suh. &quot;Orientation estimation using a quaternion-based indirect Kalman filter with adaptive estimation
     * of external acceleration&quot;. 2010.
     *
     * @param initialAttitude initial attitude.
     * @param initialWx       initial x-coordinate rotation velocity at initial timestamp expressed
     *                        in radians per second (rad/s).
     * @param initialWy       initial y-coordinate rotation velocity at initial timestamp expressed
     *                        in radians per second (rad/s).
     * @param initialWz       initial z-coordinate rotation velocity at initial timestamp expressed
     *                        in radians per second (rad/s).
     * @param currentWx       end x-coordinate rotation velocity at end timestamp expressed in
     *                        radians per second (rad/s).
     * @param currentWy       end y-coordinate rotation velocity at end timestamp expressed in
     *                        radians per second (rad/s).
     * @param currentWz       end z-coordinate rotation velocity at end timestamp expressed in
     *                        radians per second (rad/s).
     * @param dt              time step expressed in seconds (t1 - t0).
     * @param result          instance where result of integration will be stored.
     * @throws RotationException if a numerical error occurs.
     */
    public static void integrationStep(
            final Quaternion initialAttitude,
            final double initialWx, final double initialWy, final double initialWz,
            final double currentWx, final double currentWy, final double currentWz,
            final double dt, final Quaternion result) throws RotationException {
        try {
<span class="fc" id="L201">            final var omega0 = new Matrix(Rotation3D.INHOM_COORDS, 1);</span>
<span class="fc" id="L202">            final var omega1 = new Matrix(Rotation3D.INHOM_COORDS, 1);</span>
<span class="fc" id="L203">            final var quat = new Matrix(Quaternion.N_PARAMS, 1);</span>
<span class="fc" id="L204">            final var omegaSkew0 = new Matrix(Quaternion.N_PARAMS, Quaternion.N_PARAMS);</span>
<span class="fc" id="L205">            final var omegaSkew1 = new Matrix(Quaternion.N_PARAMS, Quaternion.N_PARAMS);</span>
<span class="fc" id="L206">            final var constant = new Matrix(Quaternion.N_PARAMS, Quaternion.N_PARAMS);</span>
<span class="fc" id="L207">            final var omegaSkew10 = new Matrix(Quaternion.N_PARAMS, Quaternion.N_PARAMS);</span>
<span class="fc" id="L208">            final var identity = Matrix.identity(Quaternion.N_PARAMS, Quaternion.N_PARAMS);</span>
<span class="fc" id="L209">            final var omegaSkew1A = new Matrix(Quaternion.N_PARAMS, Quaternion.N_PARAMS);</span>
<span class="fc" id="L210">            final var omegaSkew0A = new Matrix(Quaternion.N_PARAMS, Quaternion.N_PARAMS);</span>
<span class="fc" id="L211">            final var omegaSkew1B = new Matrix(Quaternion.N_PARAMS, Quaternion.N_PARAMS);</span>
<span class="fc" id="L212">            final var tmp = new Matrix(Quaternion.N_PARAMS, Quaternion.N_PARAMS);</span>
<span class="fc" id="L213">            final var quatResult = new Matrix(Quaternion.N_PARAMS, 1);</span>
<span class="fc" id="L214">            integrationStep(initialAttitude, initialWx, initialWy, initialWz,</span>
                    currentWx, currentWy, currentWz, dt, result, omega0, omega1, quat, omegaSkew0,
                    omegaSkew1, constant, omegaSkew10, identity, omegaSkew1A, omegaSkew0A,
                    omegaSkew1B, tmp, quatResult);
<span class="nc" id="L218">        } catch (final AlgebraException ignore) {</span>
            // never happens
<span class="fc" id="L220">        }</span>
<span class="fc" id="L221">    }</span>

    /**
     * Internal method computing an integration step using Suh's algorithm.
     * This method is used internally so that reusable instances can be provided as parameters.
     *
     * @param initialAttitude initial attitude.
     * @param initialWx       initial x-coordinate rotation velocity at initial timestamp expressed
     *                        in radians per second (rad/s).
     * @param initialWy       initial y-coordinate rotation velocity at initial timestamp expressed
     *                        in radians per second (rad/s).
     * @param initialWz       initial z-coordinate rotation velocity at initial timestamp expressed
     *                        in radians per second (rad/s).
     * @param currentWx       end x-coordinate rotation velocity at end timestamp expressed in
     *                        radians per second (rad/s).
     * @param currentWy       end y-coordinate rotation velocity at end timestamp expressed in
     *                        radians per second (rad/s).
     * @param currentWz       end z-coordinate rotation velocity at end timestamp expressed in
     *                        radians per second (rad/s).
     * @param dt              time step expressed in seconds (t1 - t0).
     * @param result          instance where result of integration will be stored.
     * @param omega0          angular speed at initial timestamp t0 to be reused. Must be 3x1.
     * @param omega1          angular speed at end timestamp t1 to be reused. Must be 3x1.
     * @param quat            initial attitude to be reused. Must be 4x1.
     * @param omegaSkew0      skew matrix of omega0 to be reused. Must be 4x4.
     * @param omegaSkew1      skew matrix of omega1 to be reused. Must be 4x4.
     * @param constant        constant matrix to be reused. Must be 4x4.
     * @param omegaSkew10     temporary matrix to be reused. Must be 4x4.
     * @param identity        identity matrix to be reused. Must be 4x4.
     * @param omegaSkew1A     temporary matrix to be reused. Must be 4x4.
     * @param omegaSkew0A     temporary matrix to be reused. Must be 4x4.
     * @param omegaSkew1B     temporary matrix to be reused. Must be 4x4.
     * @param tmp             temporary matrix to be reused. Must be 4x4.
     * @param quatResult      instance where result of integration is stored in matrix form being
     *                        reused. Must be 4x1.
     * @throws RotationException if a numerical error occurs.
     */
    private static void integrationStep(
            final Quaternion initialAttitude,
            final double initialWx, final double initialWy, final double initialWz,
            final double currentWx, final double currentWy, final double currentWz,
            final double dt, final Quaternion result, final Matrix omega0, final Matrix omega1,
            final Matrix quat, final Matrix omegaSkew0, final Matrix omegaSkew1,
            final Matrix constant, final Matrix omegaSkew10, final Matrix identity,
            final Matrix omegaSkew1A, final Matrix omegaSkew0A, final Matrix omegaSkew1B,
            final Matrix tmp, final Matrix quatResult) throws RotationException {
        try {
            // normalize and copy initial attitude into matrix form
<span class="fc" id="L269">            initialAttitude.normalize();</span>
<span class="fc" id="L270">            initialAttitude.values(quat.getBuffer());</span>

            // angular speed at initial timestamp t0
<span class="fc" id="L273">            copyAngularSpeedToMatrix(initialWx, initialWy, initialWz, omega0);</span>

            // angular speed at end timestamp t1
<span class="fc" id="L276">            copyAngularSpeedToMatrix(currentWx, currentWy, currentWz, omega1);</span>

<span class="fc" id="L278">            final var norm1 = FrobeniusNormComputer.norm(omega1);</span>
<span class="fc" id="L279">            final var sqrNorm1 = norm1 * norm1;</span>

<span class="fc" id="L281">            computeOmegaSkew(omega0, omegaSkew0);</span>
<span class="fc" id="L282">            computeOmegaSkew(omega1, omegaSkew1);</span>

<span class="fc" id="L284">            final var dt2 = dt * dt;</span>
<span class="fc" id="L285">            final var dt3 = dt * dt2;</span>

<span class="fc" id="L287">            constant.initialize(sqrNorm1 * dt2 / 6.0);</span>

<span class="fc" id="L289">            omegaSkew1.multiply(omegaSkew0, omegaSkew10);</span>
<span class="fc" id="L290">            omegaSkew10.multiplyByScalar(dt2 / 24.0);</span>

<span class="fc" id="L292">            omegaSkew1A.copyFrom(omegaSkew1);</span>
<span class="fc" id="L293">            omegaSkew1A.multiplyByScalar(THREE_FOURTHS * dt);</span>

<span class="fc" id="L295">            omegaSkew0A.copyFrom(omegaSkew0);</span>
<span class="fc" id="L296">            omegaSkew0A.multiplyByScalar(dt / 4.0);</span>

<span class="fc" id="L298">            omegaSkew1B.copyFrom(omegaSkew1);</span>
<span class="fc" id="L299">            omegaSkew1B.multiplyByScalar(sqrNorm1 * dt3 / 48.0);</span>

<span class="fc" id="L301">            tmp.copyFrom(identity);</span>
<span class="fc" id="L302">            tmp.add(omegaSkew1A);</span>
<span class="fc" id="L303">            tmp.subtract(omegaSkew0A);</span>
<span class="fc" id="L304">            tmp.subtract(constant);</span>
<span class="fc" id="L305">            tmp.subtract(omegaSkew10);</span>
<span class="fc" id="L306">            tmp.subtract(omegaSkew1B);</span>

<span class="fc" id="L308">            tmp.multiply(quat, quatResult);</span>

<span class="fc" id="L310">            result.setValues(quatResult.getBuffer());</span>
<span class="fc" id="L311">            result.normalize();</span>
<span class="nc" id="L312">        } catch (final AlgebraException e) {</span>
<span class="nc" id="L313">            throw new RotationException(e);</span>
<span class="fc" id="L314">        }</span>
<span class="fc" id="L315">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>