<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>WindowedTriadNoiseEstimator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-navigation-inertial</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.navigation.inertial.calibration.noise</a> &gt; <span class="el_source">WindowedTriadNoiseEstimator.java</span></div><h1>WindowedTriadNoiseEstimator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2020 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.navigation.inertial.calibration.noise;

import com.irurueta.navigation.LockedException;
import com.irurueta.navigation.inertial.calibration.TimeIntervalEstimator;
import com.irurueta.navigation.inertial.calibration.Triad;
import com.irurueta.units.Measurement;
import com.irurueta.units.Time;
import com.irurueta.units.TimeConverter;
import com.irurueta.units.TimeUnit;

import java.util.LinkedList;

/**
 * Base class to estimate measurement noise variances and PSD's (Power Spectral Densities)
 * along with average values for a windowed amount of samples.
 * Implementations of this estimator must be used when the body where the measurement device
 * is attached to remains static on the same position with zero velocity while capturing data.
 * To compute PSD's, this estimator assumes that measurement samples are obtained
 * at a constant provided rate equal to {@link #getTimeInterval()} seconds.
 * If not available, accelerometer sampling rate average can be estimated using
 * {@link TimeIntervalEstimator}.
 * This estimator does NOT require the knowledge of current location and body
 * orientation.
 * Because body location and orientation is not known, estimated average values
 * cannot be used to determine biases. Only norm of noise estimations
 * (variance or standard deviation) can be safely used.
 * Notice that if there are less than {@link #getWindowSize()} processed
 * samples in the window, this estimator will assume that the remaining ones
 * until the window is completed have zero values.
 *
 * @param &lt;U&gt; a measurement unit type.
 * @param &lt;M&gt; a measurement type.
 * @param &lt;T&gt; a triad type.
 * @param &lt;E&gt; an estimator type.
 * @param &lt;L&gt; a listener type.
 */
@SuppressWarnings(&quot;DuplicatedCode&quot;)
public abstract class WindowedTriadNoiseEstimator&lt;U extends Enum&lt;?&gt;,
        M extends Measurement&lt;U&gt;, T extends Triad&lt;U, M&gt;,
        E extends WindowedTriadNoiseEstimator&lt;U, M, T, E, L&gt;,
        L extends WindowedTriadNoiseEstimatorListener&lt;U, M, T, E&gt;&gt; {

    /**
     * Number of samples to keep within the window by default.
     * For an accelerometer generating 100 samples/second, this is equivalent to
     * 1 second.
     * For an accelerometer generating 50 samples/second, this is equivalent to
     * 2 seconds.
     */
    public static final int DEFAULT_WINDOW_SIZE = 101;

    /**
     * Minimum allowed window size.
     */
    public static final int MIN_WINDOW_SIZE = 3;

    /**
     * Default time interval between accelerometer samples expressed in seconds
     * (s).
     */
    public static final double DEFAULT_TIME_INTERVAL_SECONDS = 0.02;

    /**
     * Length of number of samples to keep within the window being processed.
     * Window size must always be larger than allowed minimum value and must have
     * an odd value.
     */
<span class="fc" id="L83">    private int windowSize = DEFAULT_WINDOW_SIZE;</span>

    /**
     * Time interval expressed in seconds (s) between consecutive triad
     * samples.
     */
<span class="fc" id="L89">    private double timeInterval = DEFAULT_TIME_INTERVAL_SECONDS;</span>

    /**
     * Keeps the list of triad samples that remain within the window.
     */
<span class="fc" id="L94">    private final LinkedList&lt;T&gt; windowedSamples = new LinkedList&lt;&gt;();</span>

    /**
     * Listener to handle events raised by this estimator.
     */
    private L listener;

    /**
     * Contains estimated average of x coordinate of measurement expressed in its default
     * unit (m/s^2 for acceleration, rad/s for angular speed or T for magnetic flux density).
     */
    private double avgX;

    /**
     * Contains estimated average of y coordinate of measurement expressed in its default
     * unit (m/s^2 for acceleration, rad/s for angular speed or T for magnetic flux density).
     */
    private double avgY;

    /**
     * Contains estimated average of z coordinate of measurement expressed in its default
     * unit (m/s^2 for acceleration, rad/s for angular speed or T for magnetic flux density).
     */
    private double avgZ;

    /**
     * Contains estimated variance of x coordinate of measurement expressed in its default
     * squared unit (m^2/s^4 for acceleration, rad^2/s^2 for angular speed or T^2 for magnetic
     * flux density).
     */
    private double varianceX;

    /**
     * Contains estimated variance of y coordinate of measurement expressed in its default
     * squared unit (m^2/s^4 for acceleration, rad^2/s^2 for angular speed or T^2 for magnetic
     * flux density).
     */
    private double varianceY;

    /**
     * Contains estimated variance of x coordinate of measurement expressed in its default
     * squared unit (m^2/s^4 for acceleration, rad^2/s^2 for angular speed or T^2 for magnetic
     * flux density).
     */
    private double varianceZ;

    /**
     * Number of processed acceleration triad samples.
     */
    private int numberOfProcessedSamples;

    /**
     * Indicates whether estimator is running or not.
     */
    private boolean running;

    /**
     * Constructor.
     */
<span class="fc" id="L153">    protected WindowedTriadNoiseEstimator() {</span>
<span class="fc" id="L154">    }</span>

    /**
     * Constructor.
     *
     * @param listener listener to handle events raised by this estimator.
     */
<span class="fc" id="L161">    protected WindowedTriadNoiseEstimator(final L listener) {</span>
<span class="fc" id="L162">        this.listener = listener;</span>
<span class="fc" id="L163">    }</span>

    /**
     * Gets length of number of samples to keep within the window being processed.
     * Window size must always be larger than allowed minimum value and must
     * have an odd value.
     *
     * @return length of number of samples to keep within the window.
     */
    public int getWindowSize() {
<span class="fc" id="L173">        return windowSize;</span>
    }

    /**
     * Sets length of number of samples to keep within the window being processed.
     * Window size must always be larger than allowed minimum value and must have
     * an odd value.
     * When window size is modified, instance state is reset.
     *
     * @param windowSize length of number of samples to keep within the window.
     * @throws IllegalArgumentException if provided value is not valid.
     * @throws LockedException          if estimator is currently running.
     */
    public void setWindowSize(final int windowSize) throws LockedException {
<span class="fc bfc" id="L187" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L188">            throw new LockedException();</span>
        }

        // check that window is larger than minimum allowed value
<span class="fc bfc" id="L192" title="All 2 branches covered.">        if (windowSize &lt; MIN_WINDOW_SIZE) {</span>
<span class="fc" id="L193">            throw new IllegalArgumentException();</span>
        }

        // check that window size is not even
<span class="pc bpc" id="L197" title="1 of 2 branches missed.">        if (windowSize % 2 == 0) {</span>
<span class="nc" id="L198">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L201">        this.windowSize = windowSize;</span>
<span class="fc" id="L202">        reset();</span>
<span class="fc" id="L203">    }</span>

    /**
     * Gets time interval between triad samples expressed in
     * seconds (s).
     *
     * @return time interval between triad samples.
     */
    public double getTimeInterval() {
<span class="fc" id="L212">        return timeInterval;</span>
    }

    /**
     * Sets time interval between triad samples expressed in
     * seconds (s).
     *
     * @param timeInterval time interval between triad samples.
     * @throws IllegalArgumentException if provided value is negative.
     * @throws LockedException          if estimator is currently running.
     */
    public void setTimeInterval(final double timeInterval) throws LockedException {
<span class="fc bfc" id="L224" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L225">            throw new LockedException();</span>
        }

<span class="fc bfc" id="L228" title="All 2 branches covered.">        if (timeInterval &lt; 0.0) {</span>
<span class="fc" id="L229">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L232">        this.timeInterval = timeInterval;</span>
<span class="fc" id="L233">    }</span>

    /**
     * Gets time interval between triad samples.
     *
     * @return time interval between triad samples.
     */
    public Time getTimeIntervalAsTime() {
<span class="fc" id="L241">        return new Time(timeInterval, TimeUnit.SECOND);</span>
    }

    /**
     * Gets time interval between triad samples.
     *
     * @param result instance where time interval will be stored.
     */
    public void getTimeIntervalAsTime(final Time result) {
<span class="fc" id="L250">        result.setValue(timeInterval);</span>
<span class="fc" id="L251">        result.setUnit(TimeUnit.SECOND);</span>
<span class="fc" id="L252">    }</span>

    /**
     * Sets time interval between triad samples.
     *
     * @param timeInterval time interval between triad samples.
     * @throws LockedException if estimator is currently running.
     */
    public void setTimeInterval(final Time timeInterval) throws LockedException {
<span class="fc" id="L261">        setTimeInterval(TimeConverter.convert(timeInterval.getValue().doubleValue(), timeInterval.getUnit(),</span>
                TimeUnit.SECOND));
<span class="fc" id="L263">    }</span>

    /**
     * Gets listener to handle events raised by this estimator.
     *
     * @return listener to handle events raised by this estimator.
     */
    public L getListener() {
<span class="fc" id="L271">        return listener;</span>
    }

    /**
     * Sets listener to handle events raised by this estimator.
     *
     * @param listener listener to handle events raised by this estimator.
     * @throws LockedException if this estimator is running.
     */
    public void setListener(final L listener) throws LockedException {
<span class="fc bfc" id="L281" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L282">            throw new LockedException();</span>
        }

<span class="fc" id="L285">        this.listener = listener;</span>
<span class="fc" id="L286">    }</span>

    /**
     * Gets first provided measurement triad within the window.
     *
     * @return first provided measurement triad within the window or null if not
     * available.
     */
    public T getFirstWindowedTriad() {
<span class="fc bfc" id="L295" title="All 2 branches covered.">        return windowedSamples.isEmpty() ? null : windowedSamples.getFirst();</span>
    }

    /**
     * Gets first provided measurement triad within the window.
     *
     * @param result instance where first provided measurement triad will be stored.
     * @return true if result instance was updated, false otherwise.
     */
    public boolean getFirstWindowedTriad(final T result) {
<span class="fc bfc" id="L305" title="All 2 branches covered.">        if (windowedSamples.isEmpty()) {</span>
<span class="fc" id="L306">            return false;</span>
        } else {
<span class="fc" id="L308">            result.copyFrom(windowedSamples.getFirst());</span>
<span class="fc" id="L309">            return true;</span>
        }
    }

    /**
     * Gets last provided measurement triad within the window.
     *
     * @return last provided measurement triad within the window or null if not
     * available.
     */
    public T getLastWindowedTriad() {
<span class="fc bfc" id="L320" title="All 2 branches covered.">        return windowedSamples.isEmpty() ? null : windowedSamples.getLast();</span>
    }

    /**
     * Gets last provided measurement triad within the window.
     *
     * @param result instance where last provided measurement triad will be stored.
     * @return true if result instance was updated, false otherwise.
     */
    public boolean getLastWindowedTriad(final T result) {
<span class="fc bfc" id="L330" title="All 2 branches covered.">        if (windowedSamples.isEmpty()) {</span>
<span class="fc" id="L331">            return false;</span>
        } else {
<span class="fc" id="L333">            result.copyFrom(windowedSamples.getLast());</span>
<span class="fc" id="L334">            return true;</span>
        }
    }

    /**
     * Gets estimated average of x coordinate of measurement expressed in its default
     * unit (m/s^2 for acceleration, rad/s for angular speed or T for magnetic flux density).
     * This value will depend of body location and orientation, hence it should never
     * be used as a calibration bias.
     *
     * @return average of x coordinate of measurement in current window.
     */
    public double getAvgX() {
<span class="fc" id="L347">        return avgX;</span>
    }

    /**
     * Gets estimated average of x coordinate of measurement within current window.
     * This value will depend of body location and orientation, hence it should never
     * be used as a calibration bias.
     *
     * @return average of x coordinate of measurement in current window.
     */
    public M getAvgXAsMeasurement() {
<span class="fc" id="L358">        return createMeasurement(avgX, getDefaultUnit());</span>
    }

    /**
     * Gets estimated average of x coordinate of measurement within current window.
     * This value will depend of body location and orientation, hence it should never
     * be used as a calibration bias.
     *
     * @param result instance where average of x coordinate of measurement will be stored.
     */
    public void getAvgXAsMeasurement(final M result) {
<span class="fc" id="L369">        result.setValue(avgX);</span>
<span class="fc" id="L370">        result.setUnit(getDefaultUnit());</span>
<span class="fc" id="L371">    }</span>

    /**
     * Gets estimated average of y coordinate of measurement expressed in its default
     * unit (m/s^2 for acceleration, rad/s for angular speed or T for magnetic flux density).
     * This value will depend of body location and orientation, hence it should never
     * be used as a calibration bias.
     *
     * @return average of y coordinate of measurement in current window.
     */
    public double getAvgY() {
<span class="fc" id="L382">        return avgY;</span>
    }

    /**
     * Gets estimated average of y coordinate of measurement within current window.
     * This value will depend of body location and orientation, hence it should never
     * be used as a calibration bias.
     *
     * @return average of y coordinate of measurement in current window.
     */
    public M getAvgYAsMeasurement() {
<span class="fc" id="L393">        return createMeasurement(avgY, getDefaultUnit());</span>
    }

    /**
     * Gets estimated average of y coordinate of measurement within current window.
     * This value will depend of body location and orientation, hence it should never
     * be used as a calibration bias.
     *
     * @param result instance where average of y coordinate of measurement will be stored.
     */
    public void getAvgYAsMeasurement(final M result) {
<span class="fc" id="L404">        result.setValue(avgY);</span>
<span class="fc" id="L405">        result.setUnit(getDefaultUnit());</span>
<span class="fc" id="L406">    }</span>

    /**
     * Gets estimated average of z coordinate of measurement expressed in its default
     * unit (m/s^2 for acceleration, rad/s for angular speed or T for magnetic flux density).
     * This value will depend of body location and orientation, hence it should never
     * be used as a calibration bias.
     *
     * @return average of z coordinate of measurement in current window.
     */
    public double getAvgZ() {
<span class="fc" id="L417">        return avgZ;</span>
    }

    /**
     * Gets estimated average of z coordinate of measurement within current window.
     * This value will depend of body location and orientation, hence it should never
     * be used as a calibration bias.
     *
     * @return average of z coordinate of measurement in current window.
     */
    public M getAvgZAsMeasurement() {
<span class="fc" id="L428">        return createMeasurement(avgZ, getDefaultUnit());</span>
    }

    /**
     * Gets estimated average of z coordinate of measurement within current window.
     * This value will depend of body location and orientation, hence it should never
     * be used as a calibration bias.
     *
     * @param result instance where average of z coordinate of measurement will be stored.
     */
    public void getAvgZAsMeasurement(final M result) {
<span class="fc" id="L439">        result.setValue(avgZ);</span>
<span class="fc" id="L440">        result.setUnit(getDefaultUnit());</span>
<span class="fc" id="L441">    }</span>

    /**
     * Gets estimated average as a measurement triad.
     *
     * @return average measurement triad.
     */
    public T getAvgTriad() {
<span class="fc" id="L449">        return createTriad(avgX, avgY, avgZ, getDefaultUnit());</span>
    }

    /**
     * Gets estimated average as a measurement triad.
     *
     * @param result instance where average values and unit will be stored.
     */
    public void getAvgTriad(final T result) {
<span class="fc" id="L458">        result.setValueCoordinatesAndUnit(avgX, avgY, avgZ, getDefaultUnit());</span>
<span class="fc" id="L459">    }</span>

    /**
     * Gets norm of estimated average measurement within current window expressed in its default
     * unit (m/s^2 for acceleration, rad/s for angular speed or T for magnetic flux density).
     * This value is independent of body orientation.
     *
     * @return norm of estimated average specific force.
     */
    public double getAvgNorm() {
<span class="fc" id="L469">        return Math.sqrt(avgX * avgX + avgY * avgY + avgZ * avgZ);</span>
    }

    /**
     * Gets norm of estimated average measurement within current window.
     *
     * @return norm of estimated average measurement.
     */
    public M getAvgNormAsMeasurement() {
<span class="fc" id="L478">        return createMeasurement(getAvgNorm(), getDefaultUnit());</span>
    }

    /**
     * Gets norm of estimated average measurement within current window.
     *
     * @param result instance where norm of estimated average measurement will be stored.
     */
    public void getAvgNormAsMeasurement(final M result) {
<span class="fc" id="L487">        result.setValue(getAvgNorm());</span>
<span class="fc" id="L488">        result.setUnit(getDefaultUnit());</span>
<span class="fc" id="L489">    }</span>

    /**
     * Gets estimated variance of x coordinate of measurement within current window
     * expressed in its default squared unit (m^2/s^4 for acceleration,
     * rad^2/s^2 for angular speed or T^2 for magnetic flux density).
     *
     * @return estimated variance of x coordinate of measurement within current
     * window.
     */
    public double getVarianceX() {
<span class="fc" id="L500">        return varianceX;</span>
    }

    /**
     * Gets estimated variance of y coordinate of measurement within current window
     * expressed in its default squared unit (m^2/s^4 for acceleration,
     * rad^2/s^2 for angular speed or T^2 for magnetic flux density).
     *
     * @return estimated variance of y coordinate of measurement within current
     * window.
     */
    public double getVarianceY() {
<span class="fc" id="L512">        return varianceY;</span>
    }

    /**
     * Gets estimated variance of z coordinate of measurement within current window
     * expressed in its default squared unit (m^2/s^4 for acceleration,
     * rad^2/s^2 for angular speed or T^2 for magnetic flux density).
     *
     * @return estimated variance of z coordinate of measurement within current
     * window.
     */
    public double getVarianceZ() {
<span class="fc" id="L524">        return varianceZ;</span>
    }

    /**
     * Gets estimated standard deviation of x coordinate of measurement within current
     * window and expressed in its default unit (m/s^2 for acceleration, rad/s for
     * angular speed or T for magnetic flux density).
     *
     * @return estimated standard deviation of x coordinate of measurement within
     * current window.
     */
    public double getStandardDeviationX() {
<span class="fc" id="L536">        return Math.sqrt(varianceX);</span>
    }

    /**
     * Gets estimated standard deviation of x coordinate of measurement within current
     * window.
     *
     * @return estimated standard deviation of x coordinate of measurement.
     */
    public M getStandardDeviationXAsMeasurement() {
<span class="fc" id="L546">        return createMeasurement(getStandardDeviationX(), getDefaultUnit());</span>
    }

    /**
     * Gets estimated standard deviation of x coordinate of measurement within current
     * window.
     *
     * @param result instance where estimated standard deviation of x coordinate of
     *               measurement will be stored.
     */
    public void getStandardDeviationXAsMeasurement(final M result) {
<span class="fc" id="L557">        result.setValue(getStandardDeviationX());</span>
<span class="fc" id="L558">        result.setUnit(getDefaultUnit());</span>
<span class="fc" id="L559">    }</span>

    /**
     * Gets estimated standard deviation of y coordinate of measurement within current
     * window and expressed in its default unit (m/s^2 for acceleration, rad/s for
     * angular speed or T for magnetic flux density).
     *
     * @return estimated standard deviation of y coordinate of measurement within
     * current window.
     */
    public double getStandardDeviationY() {
<span class="fc" id="L570">        return Math.sqrt(varianceY);</span>
    }

    /**
     * Gets estimated standard deviation of y coordinate of measurement within current
     * window.
     *
     * @return estimated standard deviation of y coordinate of measurement.
     */
    public M getStandardDeviationYAsMeasurement() {
<span class="fc" id="L580">        return createMeasurement(getStandardDeviationY(), getDefaultUnit());</span>
    }

    /**
     * Gets estimated standard deviation of y coordinate of measurement within current
     * window.
     *
     * @param result instance where estimated standard deviation of y coordinate of
     *               measurement will be stored.
     */
    public void getStandardDeviationYAsMeasurement(final M result) {
<span class="fc" id="L591">        result.setValue(getStandardDeviationY());</span>
<span class="fc" id="L592">        result.setUnit(getDefaultUnit());</span>
<span class="fc" id="L593">    }</span>

    /**
     * Gets estimated standard deviation of z coordinate of measurement within current
     * window and expressed in its default unit (m/s^2 for acceleration, rad/s for
     * angular speed or T for magnetic flux density).
     *
     * @return estimated standard deviation of z coordinate of measurement within
     * current window.
     */
    public double getStandardDeviationZ() {
<span class="fc" id="L604">        return Math.sqrt(varianceZ);</span>
    }

    /**
     * Gets estimated standard deviation of z coordinate of measurement within current
     * window.
     *
     * @return estimated standard deviation of z coordinate of measurement.
     */
    public M getStandardDeviationZAsMeasurement() {
<span class="fc" id="L614">        return createMeasurement(getStandardDeviationZ(), getDefaultUnit());</span>
    }

    /**
     * Gets estimated standard deviation of z coordinate of measurement within current
     * window.
     *
     * @param result instance where estimated standard deviation of z coordinate of
     *               measurement will be stored.
     */
    public void getStandardDeviationZAsMeasurement(final M result) {
<span class="fc" id="L625">        result.setValue(getStandardDeviationZ());</span>
<span class="fc" id="L626">        result.setUnit(getDefaultUnit());</span>
<span class="fc" id="L627">    }</span>

    /**
     * Gets estimated standard deviation of measurement within current window.
     *
     * @return estimated standard deviation triad of measurement.
     */
    public T getStandardDeviationTriad() {
<span class="fc" id="L635">        return createTriad(getStandardDeviationX(), getStandardDeviationY(), getStandardDeviationZ(), getDefaultUnit());</span>
    }

    /**
     * Gets estimated standard deviation of measurement within current window.
     *
     * @param result instance where estimated standard deviation triad of
     *               measurement will be stored.
     */
    public void getStandardDeviationTriad(final T result) {
<span class="fc" id="L645">        result.setValueCoordinatesAndUnit(getStandardDeviationX(), getStandardDeviationY(), getStandardDeviationZ(),</span>
<span class="fc" id="L646">                getDefaultUnit());</span>
<span class="fc" id="L647">    }</span>

    /**
     * Gets norm of estimated standard deviation of measurement within current
     * window expressed in its default unit (m/s^2 for acceleration, rad/s for
     * angular speed or T for magnetic flux density).
     *
     * @return norm of estimated standard deviation of measurement.
     */
    public double getStandardDeviationNorm() {
<span class="fc" id="L657">        final var fx = getStandardDeviationX();</span>
<span class="fc" id="L658">        final var fy = getStandardDeviationY();</span>
<span class="fc" id="L659">        final var fz = getStandardDeviationZ();</span>
<span class="fc" id="L660">        return Math.sqrt(fx * fx + fy * fy + fz * fz);</span>
    }

    /**
     * Gets norm of estimated standard deviation of measurement within current window.
     *
     * @return norm of estimated standard deviation of measurement.
     */
    public M getStandardDeviationNormAsMeasurement() {
<span class="fc" id="L669">        return createMeasurement(getStandardDeviationNorm(), getDefaultUnit());</span>
    }

    /**
     * Gets norm of estimated standard deviation of measurement within current window.
     *
     * @param result instance where norm of estimated standard deviation will be stored.
     */
    public void getStandardDeviationNormAsMeasurement(final M result) {
<span class="fc" id="L678">        result.setValue(getStandardDeviationNorm());</span>
<span class="fc" id="L679">        result.setUnit(getDefaultUnit());</span>
<span class="fc" id="L680">    }</span>

    /**
     * Gets average of estimated standard deviation coordinates of measurement within
     * current window expressed in its default unit (m/s^2 for acceleration, rad/s for
     * angular speed or T for magnetic flux density).
     *
     * @return average of estimated standard deviation coordinates.
     */
    public double getAverageStandardDeviation() {
<span class="fc" id="L690">        final var fx = getStandardDeviationX();</span>
<span class="fc" id="L691">        final var fy = getStandardDeviationY();</span>
<span class="fc" id="L692">        final var fz = getStandardDeviationZ();</span>
<span class="fc" id="L693">        return (fx + fy + fz) / 3.0;</span>
    }

    /**
     * Gets average of estimated standard deviation coordinates of measurement within
     * current window.
     *
     * @return average of estimated standard deviation coordinates.
     */
    public M getAverageStandardDeviationAsMeasurement() {
<span class="fc" id="L703">        return createMeasurement(getAverageStandardDeviation(), getDefaultUnit());</span>
    }

    /**
     * Gets average of estimated standard deviation coordinates of measurement within
     * current window.
     *
     * @param result instance where average of estimated standard deviation coordinates
     *               will be stored.
     */
    public void getAverageStandardDeviationAsMeasurement(final M result) {
<span class="fc" id="L714">        result.setValue(getAverageStandardDeviation());</span>
<span class="fc" id="L715">        result.setUnit(getDefaultUnit());</span>
<span class="fc" id="L716">    }</span>

    /**
     * Gets measurement noise PSD (Power Spectral Density) on x axis expressed
     * in (m^2 * s^-3) for accelerometer, (rad^2/s) for gyroscope or (T^2 * s) for
     * magnetometer.
     *
     * @return measurement noise PSD on x axis.
     */
    public double getPsdX() {
<span class="fc" id="L726">        return varianceX * timeInterval;</span>
    }

    /**
     * Gets measurement noise PSD (Power Spectral Density) on y axis expressed
     * in (m^2 * s^-3) for accelerometer, (rad^2/s) for gyroscope or (T^2 * s) for
     * magnetometer.
     *
     * @return measurement noise PSD on y axis.
     */
    public double getPsdY() {
<span class="fc" id="L737">        return varianceY * timeInterval;</span>
    }

    /**
     * Gets measurement noise PSD (Power Spectral Density) on z axis expressed
     * in (m^2 * s^-3) for accelerometer, (rad^2/s) for gyroscope or (T^2 * s) for
     * magnetometer.
     *
     * @return measurement noise PSD on z axis.
     */
    public double getPsdZ() {
<span class="fc" id="L748">        return varianceZ * timeInterval;</span>
    }

    /**
     * Gets measurement noise root PSD (Power Spectral Density) on x axis expressed in
     * (m * s^-1.5) for accelerometer, (rad * s^-0.5) for gyroscope or (T * s^0.5) for
     * magnetometer.
     *
     * @return measurement noise root PSD on x axis.
     */
    public double getRootPsdX() {
<span class="fc" id="L759">        return Math.sqrt(getPsdX());</span>
    }

    /**
     * Gets measurement noise root PSD (Power Spectral Density) on y axis expressed in
     * (m * s^-1.5) for accelerometer, (rad * s^-0.5) for gyroscope or (T * s^0.5) for
     * magnetometer.
     *
     * @return measurement noise root PSD on y axis.
     */
    public double getRootPsdY() {
<span class="fc" id="L770">        return Math.sqrt(getPsdY());</span>
    }

    /**
     * Gets measurement noise root PSD (Power Spectral Density) on z axis expressed in
     * (m * s^-1.5) for accelerometer, (rad * s^-0.5) for gyroscope or (T * s^0.5) for
     * magnetometer.
     *
     * @return measurement noise root PSD on z axis.
     */
    public double getRootPsdZ() {
<span class="fc" id="L781">        return Math.sqrt(getPsdZ());</span>
    }

    /**
     * Gets average measurement noise PSD (Power Spectral Density) among
     * x,y,z components expressed as (m^2 * s^-3) for accelerometer,
     * (rad^2/s) for gyroscope or (T^2 * s) for magnetometer.
     *
     * @return average measurement noise PSD.
     */
    public double getAvgNoisePsd() {
<span class="fc" id="L792">        return (getPsdX() + getPsdY() + getPsdZ()) / 3.0;</span>
    }

    /**
     * Gets norm of noise root PSD (Power Spectral Density) among x,y,z
     * components expressed as (m * s^-1.5) for accelerometer,
     * (rad * s^-0.5) for gyroscope or (T * s^0.5) for magnetometer.
     *
     * @return norm of measurement noise root PSD.
     */
    public double getNoiseRootPsdNorm() {
<span class="fc" id="L803">        return Math.sqrt(getPsdX() + getPsdY() + getPsdZ());</span>
    }

    /**
     * Gets number of samples that have been processed so far.
     *
     * @return number of samples that have been processed so far.
     */
    public int getNumberOfProcessedSamples() {
<span class="fc" id="L812">        return numberOfProcessedSamples;</span>
    }

    /**
     * Gets number of currently windowed samples.
     *
     * @return number of samples within the window.
     */
    public int getNumberOfSamplesInWindow() {
<span class="fc" id="L821">        return windowedSamples.size();</span>
    }

    /**
     * Indicates whether estimator is currently running or not.
     *
     * @return true if estimator is running, false otherwise.
     */
    public boolean isRunning() {
<span class="fc" id="L830">        return running;</span>
    }

    /**
     * Indicates whether window of samples is filled or not.
     *
     * @return true if window is filled, false otherwise.
     */
    public boolean isWindowFilled() {
<span class="fc bfc" id="L839" title="All 2 branches covered.">        return getNumberOfSamplesInWindow() == windowSize;</span>
    }

    /**
     * Adds a triad of measurement samples and processes current window.
     * Notice that if there are less than {@link #getWindowSize()} processed
     * samples in the window, the remaining ones are considered to be zero
     * when average values and standard deviation is estimated.
     *
     * @param triad measurement triad to be added and processed.
     * @throws LockedException if estimator is currently running.
     */
    public void addTriadAndProcess(final T triad) throws LockedException {
<span class="fc" id="L852">        internalAdd(triad, true);</span>
<span class="fc" id="L853">    }</span>

    /**
     * Adds a triad of measurement samples and processes current window.
     * Values are expressed in measurement default unit (m/s^2 for acceleration, rad/s for
     * angular speed or T for magnetic flux density).
     * Notice that if there are less than {@link #getWindowSize()} processed
     * samples in the window, the remaining ones are considered to be zero
     * when average values and standard deviation is estimated.
     *
     * @param valueX x coordinate of measurement to be added and processed.
     * @param valueY y coordinate of measurement to be added and processed.
     * @param valueZ z coordinate of measurement to be added and processed.
     * @throws LockedException if estimator is currently running.
     */
    public void addTriadAndProcess(final double valueX, final double valueY, final double valueZ)
            throws LockedException {
<span class="fc" id="L870">        addTriadAndProcess(createTriad(valueX, valueY, valueZ, getDefaultUnit()));</span>
<span class="fc" id="L871">    }</span>

    /**
     * Adds a triad of measurement samples and processes current window.
     * Notice that if there are less than {@link #getWindowSize()} processed
     * samples in the window, the remaining ones are considered to be zero
     * when average values and standard deviation is estimated.
     *
     * @param valueX x coordinate of measurement to be added and processed.
     * @param valueY y coordinate of measurement to be added and processed.
     * @param valueZ z coordinate of measurement to be added and processed.
     * @throws LockedException if estimator is currently running.
     */
    public void addTriadAndProcess(final M valueX, final M valueY, final M valueZ) throws LockedException {
<span class="fc" id="L885">        addTriadAndProcess(createTriad(valueX, valueY, valueZ));</span>
<span class="fc" id="L886">    }</span>

    /**
     * Adds a triad of measurement samples without processing current window or updating
     * result values.
     * Notice that if there are less than {@link #getWindowSize()} processed
     * samples in the window, the remaining ones are considered to be zero
     * when average values and standard deviation is estimated.
     *
     * @param triad measurement triad to be added.
     * @throws LockedException if estimator is currently running.
     */
    public void addTriad(final T triad) throws LockedException {
<span class="fc" id="L899">        internalAdd(triad, false);</span>
<span class="fc" id="L900">    }</span>

    /**
     * Adds a triad of measurement samples without processing current window or updating
     * result values.
     * Values are expressed in measurement default unit (m/s^2 for acceleration, rad/s for
     * angular speed or T for magnetic flux density).
     * Notice that if there are less than {@link #getWindowSize()} processed
     * samples in the window, the remaining ones are considered to be zero
     * when average values and standard deviation is estimated.
     *
     * @param valueX x coordinate of measurement to be added.
     * @param valueY y coordinate of measurement to be added.
     * @param valueZ z coordinate of measurement to be added.
     * @throws LockedException if estimator is currently running.
     */
    public void addTriad(final double valueX, final double valueY, final double valueZ) throws LockedException {
<span class="fc" id="L917">        addTriad(createTriad(valueX, valueY, valueZ, getDefaultUnit()));</span>
<span class="fc" id="L918">    }</span>

    /**
     * Adds a triad of measurement samples without processing current window or updating
     * result values.
     * Notice that if there are less than {@link #getWindowSize()} processed
     * samples in the window, the remaining ones are considered to be zero
     * when average values and standard deviation is estimated.
     *
     * @param valueX x coordinate of measurement to be added.
     * @param valueY y coordinate of measurement to be added.
     * @param valueZ z coordinate of measurement to be added.
     * @throws LockedException if estimator is currently running.
     */
    public void addTriad(final M valueX, final M valueY, final M valueZ) throws LockedException {
<span class="fc" id="L933">        addTriad(createTriad(valueX, valueY, valueZ));</span>
<span class="fc" id="L934">    }</span>

    /**
     * Resets current estimator.
     *
     * @return true if estimator was successfully reset, false if no reset was needed.
     * @throws LockedException if estimator is currently running.
     */
    public boolean reset() throws LockedException {
<span class="fc bfc" id="L943" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L944">            throw new LockedException();</span>
        }

<span class="fc bfc" id="L947" title="All 2 branches covered.">        if (numberOfProcessedSamples == 0) {</span>
<span class="fc" id="L948">            return false;</span>
        }

<span class="fc" id="L951">        windowedSamples.clear();</span>
<span class="fc" id="L952">        avgX = 0.0;</span>
<span class="fc" id="L953">        avgY = 0.0;</span>
<span class="fc" id="L954">        avgZ = 0.0;</span>
<span class="fc" id="L955">        varianceX = 0.0;</span>
<span class="fc" id="L956">        varianceY = 0.0;</span>
<span class="fc" id="L957">        varianceZ = 0.0;</span>
<span class="fc" id="L958">        numberOfProcessedSamples = 0;</span>

<span class="fc bfc" id="L960" title="All 2 branches covered.">        if (listener != null) {</span>
            //noinspection unchecked
<span class="fc" id="L962">            listener.onReset((E) this);</span>
        }

<span class="fc" id="L965">        return true;</span>
    }

    /**
     * Creates a copy of a triad.
     *
     * @param input triad to be copied.
     * @return copy of a triad.
     */
    protected abstract T copyTriad(final T input);

    /**
     * Creates a triad with provided values and unit.
     *
     * @param valueX x coordinate value.
     * @param valueY y coordinate value.
     * @param valueZ z coordinate value.
     * @param unit   unit.
     * @return created triad.
     */
    protected abstract T createTriad(final double valueX, final double valueY, final double valueZ, final U unit);

    /**
     * Creates a triad with provided values.
     *
     * @param valueX x coordinate value.
     * @param valueY y coordinate value.
     * @param valueZ z coordinate value.
     * @return created triad.
     */
    protected abstract T createTriad(final M valueX, final M valueY, final M valueZ);

    /**
     * Gets default unit for a measurement.
     *
     * @return default unit for a measurement.
     */
    protected abstract U getDefaultUnit();

    /**
     * Creates a measurement with provided value and unit.
     *
     * @param value value to be set.
     * @param unit  unit to be set.
     * @return created measurement.
     */
    protected abstract M createMeasurement(final double value, final U unit);

    /**
     * Internally adds a triad of measurement samples and processes current window if indicated.
     *
     * @param triad   measurement triad to be added.
     * @param process true if window of samples must also be processed, false otherwise.
     * @throws LockedException if estimator is currently running.
     */
    private void internalAdd(final T triad, final boolean process) throws LockedException {
<span class="fc bfc" id="L1021" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L1022">            throw new LockedException();</span>
        }

<span class="fc" id="L1025">        running = true;</span>

<span class="fc bfc" id="L1027" title="All 4 branches covered.">        if (windowedSamples.isEmpty() &amp;&amp; listener != null) {</span>
            //noinspection unchecked
<span class="fc" id="L1029">            listener.onStart((E) this);</span>
        }

<span class="fc" id="L1032">        final var wasFilled = isWindowFilled();</span>
<span class="fc bfc" id="L1033" title="All 2 branches covered.">        if (wasFilled) {</span>
            // remove first sample
<span class="fc" id="L1035">            windowedSamples.removeFirst();</span>
        }

<span class="fc" id="L1038">        windowedSamples.addLast(copyTriad(triad));</span>

        // process window
<span class="fc bfc" id="L1041" title="All 2 branches covered.">        if (process) {</span>
<span class="fc" id="L1042">            processWindow();</span>
        }

<span class="fc" id="L1045">        running = false;</span>

<span class="fc bfc" id="L1047" title="All 2 branches covered.">        if (listener != null) {</span>
            //noinspection unchecked
<span class="fc" id="L1049">            listener.onTriadAdded((E) this);</span>

<span class="fc bfc" id="L1051" title="All 4 branches covered.">            if (!wasFilled &amp;&amp; isWindowFilled()) {</span>
                //noinspection unchecked
<span class="fc" id="L1053">                listener.onWindowFilled((E) this);</span>
            }
        }
<span class="fc" id="L1056">    }</span>

    /**
     * Processes current windowed samples.
     */
    private void processWindow() {

<span class="fc" id="L1063">        numberOfProcessedSamples++;</span>

        // compute averages
<span class="fc" id="L1066">        var averageX = 0.0;</span>
<span class="fc" id="L1067">        var averageY = 0.0;</span>
<span class="fc" id="L1068">        var averageZ = 0.0;</span>
<span class="fc bfc" id="L1069" title="All 2 branches covered.">        for (final var triad : windowedSamples) {</span>
<span class="fc" id="L1070">            final var valueX = triad.getValueX();</span>
<span class="fc" id="L1071">            final var valueY = triad.getValueY();</span>
<span class="fc" id="L1072">            final var valueZ = triad.getValueZ();</span>

<span class="fc" id="L1074">            averageX += valueX;</span>
<span class="fc" id="L1075">            averageY += valueY;</span>
<span class="fc" id="L1076">            averageZ += valueZ;</span>
<span class="fc" id="L1077">        }</span>

<span class="fc" id="L1079">        averageX /= windowSize;</span>
<span class="fc" id="L1080">        averageY /= windowSize;</span>
<span class="fc" id="L1081">        averageZ /= windowSize;</span>

        // compute variances
<span class="fc" id="L1084">        var varX = 0.0;</span>
<span class="fc" id="L1085">        var varY = 0.0;</span>
<span class="fc" id="L1086">        var varZ = 0.0;</span>
<span class="fc bfc" id="L1087" title="All 2 branches covered.">        for (final var triad : windowedSamples) {</span>
<span class="fc" id="L1088">            final var fx = triad.getValueX();</span>
<span class="fc" id="L1089">            final var fy = triad.getValueY();</span>
<span class="fc" id="L1090">            final var fz = triad.getValueZ();</span>

<span class="fc" id="L1092">            final var diffX = fx - averageX;</span>
<span class="fc" id="L1093">            final var diffY = fy - averageY;</span>
<span class="fc" id="L1094">            final var diffZ = fz - averageZ;</span>

<span class="fc" id="L1096">            final var diffX2 = diffX * diffX;</span>
<span class="fc" id="L1097">            final var diffY2 = diffY * diffY;</span>
<span class="fc" id="L1098">            final var diffZ2 = diffZ * diffZ;</span>

<span class="fc" id="L1100">            varX += diffX2;</span>
<span class="fc" id="L1101">            varY += diffY2;</span>
<span class="fc" id="L1102">            varZ += diffZ2;</span>
<span class="fc" id="L1103">        }</span>

<span class="fc" id="L1105">        final var m = windowSize - 1;</span>

<span class="fc" id="L1107">        varX /= m;</span>
<span class="fc" id="L1108">        varY /= m;</span>
<span class="fc" id="L1109">        varZ /= m;</span>

<span class="fc" id="L1111">        this.avgX = averageX;</span>
<span class="fc" id="L1112">        this.avgY = averageY;</span>
<span class="fc" id="L1113">        this.avgZ = averageZ;</span>

<span class="fc" id="L1115">        varianceX = varX;</span>
<span class="fc" id="L1116">        varianceY = varY;</span>
<span class="fc" id="L1117">        varianceZ = varZ;</span>
<span class="fc" id="L1118">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>