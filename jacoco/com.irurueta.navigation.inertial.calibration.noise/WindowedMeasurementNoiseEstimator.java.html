<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>WindowedMeasurementNoiseEstimator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-navigation-inertial</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.navigation.inertial.calibration.noise</a> &gt; <span class="el_source">WindowedMeasurementNoiseEstimator.java</span></div><h1>WindowedMeasurementNoiseEstimator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2020 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.navigation.inertial.calibration.noise;

import com.irurueta.navigation.LockedException;
import com.irurueta.navigation.inertial.calibration.TimeIntervalEstimator;
import com.irurueta.units.Measurement;
import com.irurueta.units.Time;
import com.irurueta.units.TimeConverter;
import com.irurueta.units.TimeUnit;

import java.util.Arrays;

/**
 * Base class to estimate measurement noise variances and PSD's (Power Spectral Densities)
 * along with average values for a windowed amount of samples.
 * Implementations of this estimator may use norms of measurement triads to estimate noise
 * levels.
 * To compute PSD's, this estimator assumes that measurement samples are obtained
 * at a constant provided rate equal to {@link #getTimeInterval()} seconds.
 * If not available, accelerometer sampling rate average can be estimated using
 * {@link TimeIntervalEstimator}.
 * Notice that if there are less than {@link #getWindowSize()} processed
 * samples in the window, this estimator will assume that the remaining ones
 * until the window is completed have zero values.
 *
 * @param &lt;U&gt; a measurement unit type.
 * @param &lt;M&gt; a measurement type.
 * @param &lt;E&gt; an estimator type.
 * @param &lt;L&gt; a listener type.
 */
public abstract class WindowedMeasurementNoiseEstimator&lt;U extends Enum&lt;?&gt;,
        M extends Measurement&lt;U&gt;, E extends WindowedMeasurementNoiseEstimator&lt;U, M, E, L&gt;,
        L extends WindowedMeasurementNoiseEstimatorListener&lt;U, M, E&gt;&gt; {

    /**
     * Number of samples to keep within the window by default.
     * For an accelerometer generating 100 samples/second, this is equivalent to
     * 1 second.
     * For an accelerometer generating 50 samples/second, this is equivalent to
     * 2 seconds.
     */
    public static final int DEFAULT_WINDOW_SIZE = 101;

    /**
     * Minimum allowed window size.
     */
    public static final int MIN_WINDOW_SIZE = 3;

    /**
     * Default time interval between accelerometer samples expressed in seconds
     * (s).
     */
    public static final double DEFAULT_TIME_INTERVAL_SECONDS = 0.02;

    /**
     * Length of number of samples to keep within the window being processed.
     * Window size must always be larger than allowed minimum value and must
     * have and odd value.
     */
<span class="fc" id="L74">    private int windowSize = DEFAULT_WINDOW_SIZE;</span>

    /**
     * Time interval expressed in seconds (s) between consecutive measurements.
     */
<span class="fc" id="L79">    private double timeInterval = DEFAULT_TIME_INTERVAL_SECONDS;</span>

    /**
     * Keeps the window of measurements expressed in their default units.
     * (m/s^2 for acceleration, rad/s for angular speed or T for magnetic flux density).
     */
<span class="fc" id="L85">    private double[] windowedMeasurements = new double[DEFAULT_WINDOW_SIZE];</span>

    /**
     * Listener to handle events raised by this estimator.
     */
    private L listener;

    /**
     * Contains estimated average of measurement expressed in its default unit
     * (m/s^2 for acceleration, rad/s for angular speed or T for magnetic flux density).
     */
    private double avg;

    /**
     * Contains estimated variance of measurement expressed in its default squared unit
     * (m^2/s^4 for acceleration, rad^2/s^2 for angular speed or T^2 for magnetic
     * flux density).
     */
    private double variance;

    /**
     * Indicates position of first element in window.
     */
    private int firstCursor;

    /**
     * Indicates position of last element in window.
     */
    private int lastCursor;

    /**
     * Number of processed measurement samples.
     */
    private int numberOfProcessedSamples;

    /**
     * Number of added measurement samples.
     */
    private int numberOfAddedSamples;

    /**
     * Indicates whether estimator is running or not.
     */
    private boolean running;

    /**
     * Constructor.
     */
<span class="fc" id="L133">    protected WindowedMeasurementNoiseEstimator() {</span>
<span class="fc" id="L134">    }</span>

    /**
     * Constructor.
     *
     * @param listener listener to handle events raised by this estimator.
     */
<span class="fc" id="L141">    protected WindowedMeasurementNoiseEstimator(final L listener) {</span>
<span class="fc" id="L142">        this.listener = listener;</span>
<span class="fc" id="L143">    }</span>

    /**
     * Gets length of number of samples to keep within the window being processed.
     * Window size must always be larger than allowed minimum value and must have
     * and odd value.
     *
     * @return length of number of samples to keep within the window.
     */
    public int getWindowSize() {
<span class="fc" id="L153">        return windowSize;</span>
    }

    /**
     * Sets length of number of samples to keep within the window being processed.
     * Window size must always be larger than allowed minimum value and must have
     * an odd value.
     *
     * @param windowSize length of number of samples to keep within the window.
     * @throws IllegalArgumentException if provided value is not valid.
     * @throws LockedException          if estimator is currently running.
     */
    public void setWindowSize(final int windowSize) throws LockedException {
<span class="fc bfc" id="L166" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L167">            throw new LockedException();</span>
        }

        // check that window is larger than minimum allowed value
<span class="fc bfc" id="L171" title="All 2 branches covered.">        if (windowSize &lt; MIN_WINDOW_SIZE) {</span>
<span class="fc" id="L172">            throw new IllegalArgumentException();</span>
        }

        // check that window size is not even
<span class="pc bpc" id="L176" title="1 of 2 branches missed.">        if (windowSize % 2 == 0) {</span>
<span class="nc" id="L177">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L180">        this.windowSize = windowSize;</span>
<span class="fc" id="L181">        windowedMeasurements = new double[windowSize];</span>
<span class="fc" id="L182">        reset();</span>
<span class="fc" id="L183">    }</span>

    /**
     * Gets time interval between accelerometer triad samples expressed in
     * seconds (s).
     *
     * @return time interval between accelerometer triad samples.
     */
    public double getTimeInterval() {
<span class="fc" id="L192">        return timeInterval;</span>
    }

    /**
     * Sets time interval between accelerometer triad samples expressed in
     * seconds (s).
     *
     * @param timeInterval time interval between accelerometer triad samples.
     * @throws IllegalArgumentException if provided value is negative.
     * @throws LockedException          if estimator is currently running.
     */
    public void setTimeInterval(final double timeInterval) throws LockedException {
<span class="fc bfc" id="L204" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L205">            throw new LockedException();</span>
        }

<span class="fc bfc" id="L208" title="All 2 branches covered.">        if (timeInterval &lt; 0.0) {</span>
<span class="fc" id="L209">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L212">        this.timeInterval = timeInterval;</span>
<span class="fc" id="L213">    }</span>

    /**
     * Gets time interval between accelerometer triad samples.
     *
     * @return time interval between accelerometer triad samples.
     */
    public Time getTimeIntervalAsTime() {
<span class="fc" id="L221">        return new Time(timeInterval, TimeUnit.SECOND);</span>
    }

    /**
     * Gets time interval between accelerometer triad samples.
     *
     * @param result instance where time interval will be stored.
     */
    public void getTimeIntervalAsTime(final Time result) {
<span class="fc" id="L230">        result.setValue(timeInterval);</span>
<span class="fc" id="L231">        result.setUnit(TimeUnit.SECOND);</span>
<span class="fc" id="L232">    }</span>

    /**
     * Sets time interval between accelerometer triad samples.
     *
     * @param timeInterval time interval between accelerometer triad samples.
     * @throws LockedException if estimator is currently running.
     */
    public void setTimeInterval(final Time timeInterval) throws LockedException {
<span class="fc" id="L241">        setTimeInterval(TimeConverter.convert(timeInterval.getValue().doubleValue(), timeInterval.getUnit(),</span>
                TimeUnit.SECOND));
<span class="fc" id="L243">    }</span>

    /**
     * Gets listener to handle events raised by this estimator.
     *
     * @return listener to handle events raised by this estimator.
     */
    public L getListener() {
<span class="fc" id="L251">        return listener;</span>
    }

    /**
     * Sets listener to handle events raised by this estimator.
     *
     * @param listener listener to handle events raised by this estimator.
     * @throws LockedException if this estimator is running.
     */
    public void setListener(final L listener) throws LockedException {
<span class="fc bfc" id="L261" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L262">            throw new LockedException();</span>
        }

<span class="fc" id="L265">        this.listener = listener;</span>
<span class="fc" id="L266">    }</span>

    /**
     * Gets first provided measurement value expressed in its default units.
     * (m/s^2 for acceleration, rad/s for angular speed or T for magnetic flux density).
     *
     * @return first provided measurement value or null if not available.
     */
    public Double getFirstWindowedMeasurementValue() {
<span class="fc bfc" id="L275" title="All 2 branches covered.">        if (numberOfAddedSamples == 0) {</span>
<span class="fc" id="L276">            return null;</span>
        } else {
<span class="fc" id="L278">            return windowedMeasurements[firstCursor % windowSize];</span>
        }
    }

    /**
     * Gets las provided measurement value expressed in its default units.
     * (m/s^2 for acceleration, rad/s for angular speed or T for magnetic flux density).
     *
     * @return last provided measurement value or null if not available.
     */
    public Double getLastWindowedMeasurementValue() {
<span class="fc bfc" id="L289" title="All 2 branches covered.">        if (numberOfAddedSamples == 0) {</span>
<span class="fc" id="L290">            return null;</span>
        } else {
<span class="fc" id="L292">            return windowedMeasurements[(lastCursor - 1 + windowSize) % windowSize];</span>
        }
    }

    /**
     * Gets first provided measurement within the window.
     *
     * @return first provided measurement within the window or null if not available.
     */
    public M getFirstWindowedMeasurement() {
<span class="fc" id="L302">        final var value = getFirstWindowedMeasurementValue();</span>
<span class="fc bfc" id="L303" title="All 2 branches covered.">        return value != null ? createMeasurement(value, getDefaultUnit()) : null;</span>
    }

    /**
     * Gets first provided measurement within the window.
     *
     * @param result instance where first provided measurement will be stored.
     * @return true if result was updated, false if first measurement is not available.
     */
    public boolean getFirstWindowedMeasurement(final M result) {
<span class="fc" id="L313">        final var value = getFirstWindowedMeasurementValue();</span>
<span class="fc bfc" id="L314" title="All 2 branches covered.">        if (value != null) {</span>
<span class="fc" id="L315">            result.setValue(value);</span>
<span class="fc" id="L316">            result.setUnit(getDefaultUnit());</span>
<span class="fc" id="L317">            return true;</span>
        } else {
<span class="fc" id="L319">            return false;</span>
        }
    }

    /**
     * Gets last provided measurement within the window.
     *
     * @return last provided measurement within the window or null if not available.
     */
    public M getLastWindowedMeasurement() {
<span class="fc" id="L329">        final var value = getLastWindowedMeasurementValue();</span>
<span class="fc bfc" id="L330" title="All 2 branches covered.">        return value != null ? createMeasurement(value, getDefaultUnit()) : null;</span>
    }

    /**
     * Gets last provided measurement within the window.
     *
     * @param result instance where last provided measurement will be stored.
     * @return true if result was updated, false if last measurement is not available.
     */
    public boolean getLastWindowedMeasurement(final M result) {
<span class="fc" id="L340">        final var value = getLastWindowedMeasurementValue();</span>
<span class="fc bfc" id="L341" title="All 2 branches covered.">        if (value != null) {</span>
<span class="fc" id="L342">            result.setValue(value);</span>
<span class="fc" id="L343">            result.setUnit(getDefaultUnit());</span>
<span class="fc" id="L344">            return true;</span>
        } else {
<span class="fc" id="L346">            return false;</span>
        }
    }

    /**
     * Gets estimated average of measurement expressed in its default unit
     * (m/s^2 for acceleration, rad/s for angular speed or T for magnetic flux density).
     *
     * @return average of measurement in current window.
     */
    public double getAvg() {
<span class="fc" id="L357">        return avg;</span>
    }

    /**
     * Gets estimated average of measurement within current window.
     *
     * @return average of measurement in current window
     */
    public M getAvgAsMeasurement() {
<span class="fc" id="L366">        return createMeasurement(avg, getDefaultUnit());</span>
    }

    /**
     * Gets estimated average of measurement within current window.
     *
     * @param result instance where average of measurement will be stored.
     */
    public void getAvgAsMeasurement(final M result) {
<span class="fc" id="L375">        result.setValue(avg);</span>
<span class="fc" id="L376">        result.setUnit(getDefaultUnit());</span>
<span class="fc" id="L377">    }</span>

    /**
     * Gets estimated variance of measurement within current window
     * expressed in its default squared unit (m^2/s^4 for acceleration,
     * rad^2/s^2 for angular speed or T^2 for magnetic flux density).
     *
     * @return estimated variance of measurement within current window.
     */
    public double getVariance() {
<span class="fc" id="L387">        return variance;</span>
    }

    /**
     * Gets estimated standard deviation of measurement within current window
     * and expressed in its default unit (m/s^2 for acceleration, rad/s for
     * angular speed or T for magnetic flux density).
     *
     * @return estimated standard of measurement.
     */
    public double getStandardDeviation() {
<span class="fc" id="L398">        return Math.sqrt(variance);</span>
    }

    /**
     * Gets estimated standard deviation of measurement within current window.
     *
     * @return estimated standard deviation of measurement.
     */
    public M getStandardDeviationAsMeasurement() {
<span class="fc" id="L407">        return createMeasurement(getStandardDeviation(), getDefaultUnit());</span>
    }

    /**
     * Gets estimated standard deviation of measurement within current window.
     *
     * @param result instance where estimated standard deviation of measurement
     *               will be stored.
     */
    public void getStandardDeviationAsMeasurement(final M result) {
<span class="fc" id="L417">        result.setValue(getStandardDeviation());</span>
<span class="fc" id="L418">        result.setUnit(getDefaultUnit());</span>
<span class="fc" id="L419">    }</span>

    /**
     * Gets measurement noise PSD (Power Spectral Density) expressed
     * in (m^2 * s^-3) for accelerometer, (rad^2/s) for gyroscope or (T^2 * s) for
     * magnetometer.
     *
     * @return measurement noise PSD.
     */
    public double getPsd() {
<span class="fc" id="L429">        return variance * timeInterval;</span>
    }

    /**
     * Gets measurement noise root PSD (Power Spectral Density) expressed in
     * (m * s^-1.5) for accelerometer, (rad * s^-0.5) for gyroscope or (T * s^0.5) for
     * magnetometer.
     *
     * @return measurement noise root PSD.
     */
    public double getRootPsd() {
<span class="fc" id="L440">        return Math.sqrt(getPsd());</span>
    }

    /**
     * Gets number of samples that have been processed so far.
     *
     * @return number of samples that have been processed so far.
     */
    public int getNumberOfProcessedSamples() {
<span class="fc" id="L449">        return numberOfProcessedSamples;</span>
    }

    /**
     * Gets number of samples that have been added so far.
     *
     * @return number of samples that have been added so far.
     */
    public int getNumberOfAddedSamples() {
<span class="fc" id="L458">        return numberOfAddedSamples;</span>
    }

    /**
     * Gets number of currently windowed samples.
     *
     * @return number of samples within the window.
     */
    public int getNumberOfSamplesInWindow() {
<span class="fc" id="L467">        return Math.min(numberOfAddedSamples, windowSize);</span>
    }

    /**
     * Indicates whether window of samples is filled or not.
     *
     * @return true if window is filled, false otherwise.
     */
    public boolean isWindowFilled() {
<span class="fc bfc" id="L476" title="All 2 branches covered.">        return getNumberOfSamplesInWindow() == windowSize;</span>
    }

    /**
     * Indicates whether estimator is currently running or not.
     *
     * @return true if estimator is running, false otherwise.
     */
    public boolean isRunning() {
<span class="fc" id="L485">        return running;</span>
    }

    /**
     * Adds a measurement value expressed in its default unit (m/s^2 for acceleration, rad/s for
     * angular speed or T for magnetic flux density) and processes current window.
     * Notice that if there are less than {@link #getWindowSize()} processed
     * samples in the window, the remaining ones are considered to be zero
     * when average values and standard deviation is estimated.
     *
     * @param value value to be added.
     * @throws LockedException if estimator is currently running.
     */
    public void addMeasurementAndProcess(final double value) throws LockedException {
<span class="fc" id="L499">        internalAdd(value, true);</span>
<span class="fc" id="L500">    }</span>

    /**
     * Adds a measurement and processes current window.
     * Notice that if there are less than {@link #getWindowSize()} processed
     * samples in the window, the remaining ones are considered to be zero
     * when average values and standard deviation is estimated.
     *
     * @param value value to be added.
     * @throws LockedException if estimator is currently running.
     */
    public void addMeasurementAndProcess(final M value) throws LockedException {
<span class="fc" id="L512">        internalAdd(convertToDefaultUnit(value), true);</span>
<span class="fc" id="L513">    }</span>

    /**
     * Adds a measurement value expressed in its default unit (m/s^2 for acceleration, rad/s for
     * angular speed or T for magnetic flux density).
     * Notice that if there are less than {@link #getWindowSize()} processed
     * samples in the window, the remaining ones are considered to be zero
     * when average values and standard deviation is estimated.
     *
     * @param value value to be added.
     * @throws LockedException if estimator is currently running.
     */
    public void addMeasurement(final double value) throws LockedException {
<span class="fc" id="L526">        internalAdd(value, false);</span>
<span class="fc" id="L527">    }</span>

    /**
     * Adds a measurement.
     * Notice that if there are less than {@link #getWindowSize()} processed
     * samples in the window, the remaining ones are considered to be zero
     * when average values and standard deviation is estimated.
     *
     * @param value value to be added.
     * @throws LockedException if estimator is currently running
     */
    public void addMeasurement(final M value) throws LockedException {
<span class="fc" id="L539">        internalAdd(convertToDefaultUnit(value), false);</span>
<span class="fc" id="L540">    }</span>

    /**
     * Resets current estimator.
     *
     * @return true if estimator was successfully reset, false if no reset was needed.
     * @throws LockedException if estimator is currently running.
     */
    public boolean reset() throws LockedException {
<span class="fc bfc" id="L549" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L550">            throw new LockedException();</span>
        }

<span class="fc bfc" id="L553" title="All 2 branches covered.">        if (numberOfProcessedSamples == 0) {</span>
<span class="fc" id="L554">            return false;</span>
        }

<span class="fc" id="L557">        Arrays.fill(windowedMeasurements, 0.0);</span>
<span class="fc" id="L558">        firstCursor = 0;</span>
<span class="fc" id="L559">        lastCursor = 0;</span>
<span class="fc" id="L560">        avg = 0.0;</span>
<span class="fc" id="L561">        variance = 0.0;</span>
<span class="fc" id="L562">        numberOfProcessedSamples = 0;</span>
<span class="fc" id="L563">        numberOfAddedSamples = 0;</span>

<span class="pc bpc" id="L565" title="1 of 2 branches missed.">        if (listener != null) {</span>
            //noinspection unchecked
<span class="fc" id="L567">            listener.onReset((E) this);</span>
        }

<span class="fc" id="L570">        return true;</span>
    }

    /**
     * Gets default unit for a measurement.
     *
     * @return default unit for a measurement.
     */
    protected abstract U getDefaultUnit();

    /**
     * Creates a measurement with provided value and unit.
     *
     * @param value value to be set.
     * @param unit  unit to be set.
     * @return created measurement.
     */
    protected abstract M createMeasurement(final double value, final U unit);

    /**
     * Converts provided measurement into default unit.
     *
     * @param value measurement to be converted.
     * @return converted value.
     */
    protected abstract double convertToDefaultUnit(M value);

    /**
     * Internally adds a measurement value and processes current window if indicated.
     *
     * @param value   measurement value to be added.
     * @param process true if window of samples must also be processed, false otherwise.
     * @throws LockedException if estimator is currently running.
     */
    private void internalAdd(final double value, final boolean process) throws LockedException {
<span class="fc bfc" id="L605" title="All 2 branches covered.">        if (running) {</span>
<span class="fc" id="L606">            throw new LockedException();</span>
        }

<span class="fc" id="L609">        running = true;</span>

<span class="pc bpc" id="L611" title="1 of 4 branches missed.">        if (numberOfAddedSamples == 0 &amp;&amp; listener != null) {</span>
            //noinspection unchecked
<span class="fc" id="L613">            listener.onStart((E) this);</span>
        }

<span class="fc" id="L616">        final var wasFilled = isWindowFilled();</span>
<span class="fc bfc" id="L617" title="All 2 branches covered.">        if (wasFilled) {</span>
            // increase first cursor
<span class="fc" id="L619">            firstCursor = (firstCursor + 1) % windowSize;</span>
        }
<span class="fc" id="L621">        windowedMeasurements[lastCursor] = value;</span>
<span class="fc" id="L622">        lastCursor = (lastCursor + 1) % windowSize;</span>
<span class="fc" id="L623">        numberOfAddedSamples++;</span>

        // process window
<span class="fc bfc" id="L626" title="All 2 branches covered.">        if (process) {</span>
<span class="fc" id="L627">            processWindow();</span>
        }

<span class="fc" id="L630">        running = false;</span>

<span class="pc bpc" id="L632" title="1 of 2 branches missed.">        if (listener != null) {</span>
            //noinspection unchecked
<span class="fc" id="L634">            listener.onMeasurementAdded((E) this);</span>

<span class="fc bfc" id="L636" title="All 4 branches covered.">            if (!wasFilled &amp;&amp; isWindowFilled()) {</span>
                //noinspection unchecked
<span class="fc" id="L638">                listener.onWindowFilled((E) this);</span>
            }
        }
<span class="fc" id="L641">    }</span>

    /**
     * Processes current windowed samples.
     */
    private void processWindow() {
<span class="fc" id="L647">        numberOfProcessedSamples++;</span>

<span class="fc" id="L649">        final var n = getNumberOfSamplesInWindow();</span>

<span class="fc" id="L651">        final var endPos = Math.min(n, windowSize);</span>

        // compute averages
<span class="fc" id="L654">        var localAverage = 0.0;</span>
<span class="fc bfc" id="L655" title="All 2 branches covered.">        for (var i = 0; i &lt; endPos; i++) {</span>
<span class="fc" id="L656">            final var value = windowedMeasurements[i];</span>
<span class="fc" id="L657">            localAverage += value;</span>
        }

<span class="fc" id="L660">        localAverage /= windowSize;</span>

        // compute variances
<span class="fc" id="L663">        var localVariance = 0.0;</span>
<span class="fc bfc" id="L664" title="All 2 branches covered.">        for (var i = 0; i &lt; endPos; i++) {</span>
<span class="fc" id="L665">            final var value = windowedMeasurements[i];</span>
<span class="fc" id="L666">            final var diff = value - localAverage;</span>
<span class="fc" id="L667">            final var diff2 = diff * diff;</span>

<span class="fc" id="L669">            localVariance += diff2;</span>
        }

<span class="fc" id="L672">        final var m = windowSize - 1;</span>

<span class="fc" id="L674">        localVariance /= m;</span>

<span class="fc" id="L676">        this.avg = localAverage;</span>
<span class="fc" id="L677">        this.variance = localVariance;</span>
<span class="fc" id="L678">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>