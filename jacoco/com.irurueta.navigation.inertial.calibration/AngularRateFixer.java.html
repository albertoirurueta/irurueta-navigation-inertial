<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AngularRateFixer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-navigation-inertial</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.navigation.inertial.calibration</a> &gt; <span class="el_source">AngularRateFixer.java</span></div><h1>AngularRateFixer.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2020 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.navigation.inertial.calibration;

import com.irurueta.algebra.AlgebraException;
import com.irurueta.algebra.Matrix;
import com.irurueta.algebra.Utils;
import com.irurueta.algebra.WrongSizeException;
import com.irurueta.navigation.inertial.BodyKinematics;
import com.irurueta.units.Acceleration;
import com.irurueta.units.AccelerationConverter;
import com.irurueta.units.AccelerationUnit;
import com.irurueta.units.AngularSpeed;
import com.irurueta.units.AngularSpeedConverter;
import com.irurueta.units.AngularSpeedUnit;

/**
 * Fixes angular rate values taking into
 * account provided bias, cross coupling errors and G-dependant errors.
 */
@SuppressWarnings(&quot;DuplicatedCode&quot;)
public class AngularRateFixer {
    /**
     * Identity matrix to be reused.
     */
    private Matrix identity;

    /**
     * Temporary matrix to be reused.
     */
    private Matrix tmp1;

    /**
     * Temporary matrix to be reused.
     */
    private Matrix tmp2;

    /**
     * Temporary matrix to be reused.
     */
    private Matrix tmp3;

    /**
     * Temporary matrix to be reused.
     */
    private Matrix tmp4;

    /**
     * Temporary matrix to be reused.
     */
    private Matrix diff;

    /**
     * Temporary matrix to be reused.
     */
    private Matrix tmp5;

    /**
     * Measured angular rate to be reused.
     */
<span class="fc" id="L74">    private final double[] measuredAngularRate = new double[BodyKinematics.COMPONENTS];</span>

    /**
     * True specific force to be reused.
     */
<span class="fc" id="L79">    private final double[] trueF = new double[BodyKinematics.COMPONENTS];</span>

    /**
     * Array containing result values to be reused.
     */
<span class="fc" id="L84">    private final double[] res = new double[BodyKinematics.COMPONENTS];</span>

    /**
     * Bias matrix to be reused.
     */
    private Matrix bias;

    /**
     * Cross coupling errors matrix to be reused.
     */
    private Matrix crossCouplingErrors;

    /**
     * G-dependant cross biases to be reused.
     */
    private Matrix gDependantCrossBias;

    /**
     * Constructor.
     */
<span class="fc" id="L104">    public AngularRateFixer() {</span>
        try {
<span class="fc" id="L106">            identity = Matrix.identity(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS);</span>
<span class="fc" id="L107">            tmp1 = Matrix.identity(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS);</span>
<span class="fc" id="L108">            tmp2 = Matrix.identity(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS);</span>
<span class="fc" id="L109">            tmp3 = new Matrix(BodyKinematics.COMPONENTS, 1);</span>
<span class="fc" id="L110">            tmp4 = new Matrix(BodyKinematics.COMPONENTS, 1);</span>
<span class="fc" id="L111">            diff = new Matrix(BodyKinematics.COMPONENTS, 1);</span>
<span class="fc" id="L112">            tmp5 = new Matrix(BodyKinematics.COMPONENTS, 1);</span>

<span class="fc" id="L114">            bias = new Matrix(BodyKinematics.COMPONENTS, 1);</span>
<span class="fc" id="L115">            crossCouplingErrors = new Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS);</span>
<span class="fc" id="L116">            gDependantCrossBias = new Matrix(BodyKinematics.COMPONENTS, BodyKinematics.COMPONENTS);</span>
<span class="nc" id="L117">        } catch (final WrongSizeException ignore) {</span>
            // never happens
<span class="fc" id="L119">        }</span>
<span class="fc" id="L120">    }</span>

    /**
     * Gets bias values expressed in radians per second (rad/s).
     *
     * @return bias values expressed in radians per second.
     */
    public Matrix getBias() {
<span class="fc" id="L128">        return new Matrix(bias);</span>
    }

    /**
     * Gets bias values expressed in radians per second (rad/s).
     *
     * @param result instance where result will be stored.
     */
    public void getBias(final Matrix result) {
<span class="fc" id="L137">        bias.copyTo(result);</span>
<span class="fc" id="L138">    }</span>

    /**
     * Sets bias values expressed in radians per second (rad/s).
     *
     * @param bias bias values expressed in radians per second. Must be 3x1.
     * @throws IllegalArgumentException if provided matrix is not 3x1.
     */
    public void setBias(final Matrix bias) {
<span class="fc bfc" id="L147" title="All 4 branches covered.">        if (bias.getRows() != BodyKinematics.COMPONENTS || bias.getColumns() != 1) {</span>
<span class="fc" id="L148">            throw new IllegalArgumentException();</span>
        }
<span class="fc" id="L150">        this.bias = bias;</span>
<span class="fc" id="L151">    }</span>

    /**
     * Gets bias values expressed in radians per second (rad/s).
     *
     * @return bias values expressed in radians per second.
     */
    public double[] getBiasArray() {
<span class="fc" id="L159">        final var result = new double[BodyKinematics.COMPONENTS];</span>
<span class="fc" id="L160">        getBiasArray(result);</span>
<span class="fc" id="L161">        return result;</span>
    }

    /**
     * Gets bias values expressed in radians per second (rad/s).
     *
     * @param result instance where result data will be stored.
     * @throws IllegalArgumentException if provided array does not have
     *                                  length 3.
     */
    public void getBiasArray(final double[] result) {
<span class="fc bfc" id="L172" title="All 2 branches covered.">        if (result.length != BodyKinematics.COMPONENTS) {</span>
<span class="fc" id="L173">            throw new IllegalArgumentException();</span>
        }

        try {
<span class="fc" id="L177">            bias.toArray(result);</span>
<span class="nc" id="L178">        } catch (final WrongSizeException ignore) {</span>
            // never happens
<span class="fc" id="L180">        }</span>
<span class="fc" id="L181">    }</span>

    /**
     * Sets bias values expressed in radians per second (rad/s).
     *
     * @param bias bias values expressed in radians per second (rad/s). Must
     *             have length 3.
     * @throws IllegalArgumentException if provided array does not have
     *                                  length 3.
     */
    public void setBias(final double[] bias) {
<span class="fc bfc" id="L192" title="All 2 branches covered.">        if (bias.length != BodyKinematics.COMPONENTS) {</span>
<span class="fc" id="L193">            throw new IllegalArgumentException();</span>
        }

        try {
<span class="fc" id="L197">            this.bias.fromArray(bias);</span>
<span class="nc" id="L198">        } catch (final WrongSizeException ignore) {</span>
            // never happens
<span class="fc" id="L200">        }</span>
<span class="fc" id="L201">    }</span>

    /**
     * Gets angular speed bias.
     *
     * @return angular speed bias.
     */
    public AngularSpeedTriad getBiasAsTriad() {
<span class="fc" id="L209">        return new AngularSpeedTriad(AngularSpeedUnit.RADIANS_PER_SECOND,</span>
<span class="fc" id="L210">                bias.getElementAtIndex(0), bias.getElementAtIndex(1), bias.getElementAtIndex(2));</span>
    }

    /**
     * Gets angular speed bias.
     *
     * @param result instance where result will be stored.
     */
    public void getBiasAsTriad(final AngularSpeedTriad result) {
<span class="fc" id="L219">        result.setValueCoordinates(bias);</span>
<span class="fc" id="L220">        result.setUnit(AngularSpeedUnit.RADIANS_PER_SECOND);</span>
<span class="fc" id="L221">    }</span>

    /**
     * Sets angular speed bias.
     *
     * @param bias angular speed bias to be set.
     */
    public void setBias(final AngularSpeedTriad bias) {
<span class="fc" id="L229">        final var biasX = convertAngularSpeed(bias.getValueX(), bias.getUnit());</span>
<span class="fc" id="L230">        final var biasY = convertAngularSpeed(bias.getValueY(), bias.getUnit());</span>
<span class="fc" id="L231">        final var biasZ = convertAngularSpeed(bias.getValueZ(), bias.getUnit());</span>
<span class="fc" id="L232">        this.bias.setElementAtIndex(0, biasX);</span>
<span class="fc" id="L233">        this.bias.setElementAtIndex(1, biasY);</span>
<span class="fc" id="L234">        this.bias.setElementAtIndex(2, biasZ);</span>
<span class="fc" id="L235">    }</span>

    /**
     * Gets x-coordinate of bias expressed in radians per second (rad/s).
     *
     * @return x-coordinate of bias expressed in radians per second (rad/s).
     */
    public double getBiasX() {
<span class="fc" id="L243">        return bias.getElementAtIndex(0);</span>
    }

    /**
     * Sets x-coordinate of bias expressed in radians per second (rad/s).
     *
     * @param biasX x-coordinate of bias expressed in radians per second
     *              (rad/s).
     */
    public void setBiasX(final double biasX) {
<span class="fc" id="L253">        bias.setElementAtIndex(0, biasX);</span>
<span class="fc" id="L254">    }</span>

    /**
     * Gets y-coordinate of bias expressed in radians per second (rad/s).
     *
     * @return y-coordinate of bias expressed in radians per second (rad/s).
     */
    public double getBiasY() {
<span class="fc" id="L262">        return bias.getElementAtIndex(1);</span>
    }

    /**
     * Sets y-coordinate of bias expressed in radians per second (rad/s).
     *
     * @param biasY y-coordinate of bias expressed in radians per second
     *              (rad/s).
     */
    public void setBiasY(final double biasY) {
<span class="fc" id="L272">        bias.setElementAtIndex(1, biasY);</span>
<span class="fc" id="L273">    }</span>

    /**
     * Gets z-coordinate of bias expressed in radians per second (rad/s).
     *
     * @return z-coordinate of bias expressed in radians per second (rad/s).
     */
    public double getBiasZ() {
<span class="fc" id="L281">        return bias.getElementAtIndex(2);</span>
    }

    /**
     * Sets z-coordinate of bias expressed in radians per second (rad/s).
     *
     * @param biasZ z-coordinate of bias expressed in radians per second
     *              (rad/s).
     */
    public void setBiasZ(final double biasZ) {
<span class="fc" id="L291">        bias.setElementAtIndex(2, biasZ);</span>
<span class="fc" id="L292">    }</span>

    /**
     * Sets coordinates of bias expressed in radians per second (rad/s).
     *
     * @param biasX x-coordinate of bias.
     * @param biasY y-coordinate of bias.
     * @param biasZ z-coordinate of bias.
     */
    public void setBias(final double biasX, final double biasY, final double biasZ) {
<span class="fc" id="L302">        setBiasX(biasX);</span>
<span class="fc" id="L303">        setBiasY(biasY);</span>
<span class="fc" id="L304">        setBiasZ(biasZ);</span>
<span class="fc" id="L305">    }</span>

    /**
     * Gets x-coordinate of bias.
     *
     * @return x-coordinate of bias.
     */
    public AngularSpeed getBiasXAsAngularSpeed() {
<span class="fc" id="L313">        return new AngularSpeed(getBiasX(), AngularSpeedUnit.RADIANS_PER_SECOND);</span>
    }

    /**
     * Gets x-coordinate of bias.
     *
     * @param result instance where result will be stored.
     */
    public void getBiasXAsAngularSpeed(final AngularSpeed result) {
<span class="fc" id="L322">        result.setValue(getBiasX());</span>
<span class="fc" id="L323">        result.setUnit(AngularSpeedUnit.RADIANS_PER_SECOND);</span>
<span class="fc" id="L324">    }</span>

    /**
     * Sets x-coordinate of bias.
     *
     * @param biasX x-coordinate of bias.
     */
    public void setBiasX(final AngularSpeed biasX) {
<span class="fc" id="L332">        setBiasX(convertAngularSpeed(biasX));</span>
<span class="fc" id="L333">    }</span>

    /**
     * Gets y-coordinate of bias.
     *
     * @return y-coordinate of bias.
     */
    public AngularSpeed getBiasYAsAngularSpeed() {
<span class="fc" id="L341">        return new AngularSpeed(getBiasY(), AngularSpeedUnit.RADIANS_PER_SECOND);</span>
    }

    /**
     * Gets y-coordinate of bias.
     *
     * @param result instance where result will be stored.
     */
    public void getBiasYAsAngularSpeed(final AngularSpeed result) {
<span class="fc" id="L350">        result.setValue(getBiasY());</span>
<span class="fc" id="L351">        result.setUnit(AngularSpeedUnit.RADIANS_PER_SECOND);</span>
<span class="fc" id="L352">    }</span>

    /**
     * Sets y-coordinate of bias.
     *
     * @param biasY y-coordinate of bias.
     */
    public void setBiasY(final AngularSpeed biasY) {
<span class="fc" id="L360">        setBiasY(convertAngularSpeed(biasY));</span>
<span class="fc" id="L361">    }</span>

    /**
     * Gets z-coordinate of bias.
     *
     * @return z-coordinate of bias.
     */
    public AngularSpeed getBiasZAsAngularSpeed() {
<span class="fc" id="L369">        return new AngularSpeed(getBiasZ(), AngularSpeedUnit.RADIANS_PER_SECOND);</span>
    }

    /**
     * Gets z-coordinate of bias.
     *
     * @param result instance where result will be stored.
     */
    public void getBiasZAsAngularSpeed(final AngularSpeed result) {
<span class="fc" id="L378">        result.setValue(getBiasZ());</span>
<span class="fc" id="L379">        result.setUnit(AngularSpeedUnit.RADIANS_PER_SECOND);</span>
<span class="fc" id="L380">    }</span>

    /**
     * Sets z-coordinate of bias.
     *
     * @param biasZ z-coordinate of bias.
     */
    public void setBiasZ(final AngularSpeed biasZ) {
<span class="fc" id="L388">        setBiasZ(convertAngularSpeed(biasZ));</span>
<span class="fc" id="L389">    }</span>

    /**
     * Sets coordinates of bias.
     *
     * @param biasX x-coordinate of bias.
     * @param biasY y-coordinate of bias.
     * @param biasZ z-coordinate of bias.
     */
    public void setBias(final AngularSpeed biasX, final AngularSpeed biasY, final AngularSpeed biasZ) {
<span class="fc" id="L399">        setBiasX(biasX);</span>
<span class="fc" id="L400">        setBiasY(biasY);</span>
<span class="fc" id="L401">        setBiasZ(biasZ);</span>
<span class="fc" id="L402">    }</span>

    /**
     * Gets cross coupling errors matrix.
     *
     * @return cross coupling errors matrix.
     */
    public Matrix getCrossCouplingErrors() {
<span class="fc" id="L410">        return new Matrix(crossCouplingErrors);</span>
    }

    /**
     * Gets cross coupling errors matrix.
     *
     * @param result instance where result will be stored.
     */
    public void getCrossCouplingErrors(final Matrix result) {
<span class="fc" id="L419">        crossCouplingErrors.copyTo(result);</span>
<span class="fc" id="L420">    }</span>

    /**
     * Sets cross coupling errors matrix.
     *
     * @param crossCouplingErrors cross coupling errors matrix. Must be 3x3.
     * @throws AlgebraException         if provided matrix cannot be inverted.
     * @throws IllegalArgumentException if provided matrix is not 3x3.
     */
    public void setCrossCouplingErrors(final Matrix crossCouplingErrors) throws AlgebraException {
<span class="fc bfc" id="L430" title="All 2 branches covered.">        if (crossCouplingErrors.getRows() != BodyKinematics.COMPONENTS</span>
<span class="fc bfc" id="L431" title="All 2 branches covered.">                || crossCouplingErrors.getColumns() != BodyKinematics.COMPONENTS) {</span>
<span class="fc" id="L432">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L435">        this.crossCouplingErrors = crossCouplingErrors;</span>

<span class="fc" id="L437">        identity.add(crossCouplingErrors, tmp1);</span>

<span class="fc" id="L439">        Utils.inverse(tmp1, tmp2);</span>
<span class="fc" id="L440">    }</span>

    /**
     * Gets x scaling factor.
     *
     * @return x scaling factor.
     */
    public double getSx() {
<span class="fc" id="L448">        return crossCouplingErrors.getElementAt(0, 0);</span>
    }

    /**
     * Sets x scaling factor
     *
     * @param sx x scaling factor.
     * @throws AlgebraException if provided value makes cross coupling matrix
     *                          non-invertible.
     */
    public void setSx(final double sx) throws AlgebraException {
<span class="fc" id="L459">        final var m = new Matrix(Triad.COMPONENTS, Triad.COMPONENTS);</span>
<span class="fc" id="L460">        m.copyFrom(crossCouplingErrors);</span>
<span class="fc" id="L461">        m.setElementAt(0, 0, sx);</span>
<span class="fc" id="L462">        setCrossCouplingErrors(m);</span>
<span class="fc" id="L463">    }</span>

    /**
     * Gets y scaling factor.
     *
     * @return y scaling factor.
     */
    public double getSy() {
<span class="fc" id="L471">        return crossCouplingErrors.getElementAt(1, 1);</span>
    }

    /**
     * Sets y scaling factor.
     *
     * @param sy y scaling factor.
     * @throws AlgebraException if provided value makes cross coupling matrix
     *                          non-invertible.
     */
    public void setSy(final double sy) throws AlgebraException {
<span class="fc" id="L482">        final var m = new Matrix(Triad.COMPONENTS, Triad.COMPONENTS);</span>
<span class="fc" id="L483">        m.copyFrom(crossCouplingErrors);</span>
<span class="fc" id="L484">        m.setElementAt(1, 1, sy);</span>
<span class="fc" id="L485">        setCrossCouplingErrors(m);</span>
<span class="fc" id="L486">    }</span>

    /**
     * Gets z scaling factor.
     *
     * @return z scaling factor.
     */
    public double getSz() {
<span class="fc" id="L494">        return crossCouplingErrors.getElementAt(2, 2);</span>
    }

    /**
     * Sets z scaling factor.
     *
     * @param sz z scaling factor.
     * @throws AlgebraException if provided value makes cross coupling matrix
     *                          non-invertible.
     */
    public void setSz(final double sz) throws AlgebraException {
<span class="fc" id="L505">        final var m = new Matrix(Triad.COMPONENTS, Triad.COMPONENTS);</span>
<span class="fc" id="L506">        m.copyFrom(crossCouplingErrors);</span>
<span class="fc" id="L507">        m.setElementAt(2, 2, sz);</span>
<span class="fc" id="L508">        setCrossCouplingErrors(m);</span>
<span class="fc" id="L509">    }</span>

    /**
     * Gets x-y cross coupling error.
     *
     * @return x-y cross coupling error.
     */
    public double getMxy() {
<span class="fc" id="L517">        return crossCouplingErrors.getElementAt(0, 1);</span>
    }

    /**
     * Sets x-y cross coupling error.
     *
     * @param mxy x-y cross coupling error.
     * @throws AlgebraException if provided value makes cross coupling matrix
     *                          non-invertible.
     */
    public void setMxy(final double mxy) throws AlgebraException {
<span class="fc" id="L528">        final var m = new Matrix(Triad.COMPONENTS, Triad.COMPONENTS);</span>
<span class="fc" id="L529">        m.copyFrom(crossCouplingErrors);</span>
<span class="fc" id="L530">        m.setElementAt(0, 1, mxy);</span>
<span class="fc" id="L531">        setCrossCouplingErrors(m);</span>
<span class="fc" id="L532">    }</span>

    /**
     * Gets x-z cross coupling error.
     *
     * @return x-z cross coupling error.
     */
    public double getMxz() {
<span class="fc" id="L540">        return crossCouplingErrors.getElementAt(0, 2);</span>
    }

    /**
     * Sets x-z cross coupling error.
     *
     * @param mxz x-z cross coupling error.
     * @throws AlgebraException if provided value makes cross coupling matrix
     *                          non-invertible.
     */
    public void setMxz(final double mxz) throws AlgebraException {
<span class="fc" id="L551">        final var m = new Matrix(Triad.COMPONENTS, Triad.COMPONENTS);</span>
<span class="fc" id="L552">        m.copyFrom(crossCouplingErrors);</span>
<span class="fc" id="L553">        m.setElementAt(0, 2, mxz);</span>
<span class="fc" id="L554">        setCrossCouplingErrors(m);</span>
<span class="fc" id="L555">    }</span>

    /**
     * Gets y-x cross coupling error.
     *
     * @return y-x cross coupling error.
     */
    public double getMyx() {
<span class="fc" id="L563">        return crossCouplingErrors.getElementAt(1, 0);</span>
    }

    /**
     * Sets y-x cross coupling error.
     *
     * @param myx y-x cross coupling error.
     * @throws AlgebraException if provided value makes cross coupling matrix
     *                          non-invertible.
     */
    public void setMyx(final double myx) throws AlgebraException {
<span class="fc" id="L574">        final var m = new Matrix(Triad.COMPONENTS, Triad.COMPONENTS);</span>
<span class="fc" id="L575">        m.copyFrom(crossCouplingErrors);</span>
<span class="fc" id="L576">        m.setElementAt(1, 0, myx);</span>
<span class="fc" id="L577">        setCrossCouplingErrors(m);</span>
<span class="fc" id="L578">    }</span>

    /**
     * Gets y-z cross coupling error.
     *
     * @return y-z cross coupling error.
     */
    public double getMyz() {
<span class="fc" id="L586">        return crossCouplingErrors.getElementAt(1, 2);</span>
    }

    /**
     * Sets y-z cross coupling error.
     *
     * @param myz y-z cross coupling error.
     * @throws AlgebraException if provided value makes cross coupling matrix
     *                          non-invertible.
     */
    public void setMyz(final double myz) throws AlgebraException {
<span class="fc" id="L597">        final var m = new Matrix(Triad.COMPONENTS, Triad.COMPONENTS);</span>
<span class="fc" id="L598">        m.copyFrom(crossCouplingErrors);</span>
<span class="fc" id="L599">        m.setElementAt(1, 2, myz);</span>
<span class="fc" id="L600">        setCrossCouplingErrors(m);</span>
<span class="fc" id="L601">    }</span>

    /**
     * Gets z-x cross coupling error.
     *
     * @return z-x cross coupling error.
     */
    public double getMzx() {
<span class="fc" id="L609">        return crossCouplingErrors.getElementAt(2, 0);</span>
    }

    /**
     * Sets z-x cross coupling error.
     *
     * @param mzx z-x cross coupling error.
     * @throws AlgebraException if provided value makes cross coupling matrix
     *                          non-invertible.
     */
    public void setMzx(final double mzx) throws AlgebraException {
<span class="fc" id="L620">        final var m = new Matrix(Triad.COMPONENTS, Triad.COMPONENTS);</span>
<span class="fc" id="L621">        m.copyFrom(crossCouplingErrors);</span>
<span class="fc" id="L622">        m.setElementAt(2, 0, mzx);</span>
<span class="fc" id="L623">        setCrossCouplingErrors(m);</span>
<span class="fc" id="L624">    }</span>

    /**
     * Gets z-y cross coupling error.
     *
     * @return z-y cross coupling error.
     */
    public double getMzy() {
<span class="fc" id="L632">        return crossCouplingErrors.getElementAt(2, 1);</span>
    }

    /**
     * Sets z-y cross coupling error.
     *
     * @param mzy z-y cross coupling error.
     * @throws AlgebraException if provided value makes cross coupling matrix
     *                          non-invertible.
     */
    public void setMzy(final double mzy) throws AlgebraException {
<span class="fc" id="L643">        final var m = new Matrix(Triad.COMPONENTS, Triad.COMPONENTS);</span>
<span class="fc" id="L644">        m.copyFrom(crossCouplingErrors);</span>
<span class="fc" id="L645">        m.setElementAt(2, 1, mzy);</span>
<span class="fc" id="L646">        setCrossCouplingErrors(m);</span>
<span class="fc" id="L647">    }</span>

    /**
     * Sets scaling factors.
     *
     * @param sx x scaling factor.
     * @param sy y scaling factor.
     * @param sz z scaling factor.
     * @throws AlgebraException if provided values make cross coupling matrix
     *                          non-invertible.
     */
    public void setScalingFactors(
            final double sx, final double sy, final double sz) throws AlgebraException {
<span class="fc" id="L660">        final var m = new Matrix(Triad.COMPONENTS, Triad.COMPONENTS);</span>
<span class="fc" id="L661">        m.copyFrom(crossCouplingErrors);</span>
<span class="fc" id="L662">        m.setElementAt(0, 0, sx);</span>
<span class="fc" id="L663">        m.setElementAt(1, 1, sy);</span>
<span class="fc" id="L664">        m.setElementAt(2, 2, sz);</span>
<span class="fc" id="L665">        setCrossCouplingErrors(m);</span>
<span class="fc" id="L666">    }</span>

    /**
     * Sets cross coupling errors.
     *
     * @param mxy x-y cross coupling error.
     * @param mxz x-z cross coupling error.
     * @param myx y-x cross coupling error.
     * @param myz y-z cross coupling error.
     * @param mzx z-x cross coupling error.
     * @param mzy z-y cross coupling error.
     * @throws AlgebraException if provided values make cross coupling matrix
     *                          non-invertible.
     */
    public void setCrossCouplingErrors(
            final double mxy, final double mxz, final double myx,
            final double myz, final double mzx, final double mzy) throws AlgebraException {
<span class="fc" id="L683">        final var m = new Matrix(Triad.COMPONENTS, Triad.COMPONENTS);</span>
<span class="fc" id="L684">        m.copyFrom(crossCouplingErrors);</span>
<span class="fc" id="L685">        m.setElementAt(0, 1, mxy);</span>
<span class="fc" id="L686">        m.setElementAt(0, 2, mxz);</span>
<span class="fc" id="L687">        m.setElementAt(1, 0, myx);</span>
<span class="fc" id="L688">        m.setElementAt(1, 2, myz);</span>
<span class="fc" id="L689">        m.setElementAt(2, 0, mzx);</span>
<span class="fc" id="L690">        m.setElementAt(2, 1, mzy);</span>
<span class="fc" id="L691">        setCrossCouplingErrors(m);</span>
<span class="fc" id="L692">    }</span>

    /**
     * Sets scaling factors and cross coupling errors.
     *
     * @param sx  x scaling factor.
     * @param sy  y scaling factor.
     * @param sz  z scaling factor.
     * @param mxy x-y cross coupling error.
     * @param mxz x-z cross coupling error.
     * @param myx y-x cross coupling error.
     * @param myz y-z cross coupling error.
     * @param mzx z-x cross coupling error.
     * @param mzy z-y cross coupling error.
     * @throws AlgebraException if provided values make cross coupling matrix
     *                          non-invertible.
     */
    public void setScalingFactorsAndCrossCouplingErrors(
            final double sx, final double sy, final double sz,
            final double mxy, final double mxz, final double myx,
            final double myz, final double mzx, final double mzy) throws AlgebraException {
<span class="fc" id="L713">        final var m = new Matrix(Triad.COMPONENTS, Triad.COMPONENTS);</span>
<span class="fc" id="L714">        m.copyFrom(crossCouplingErrors);</span>
<span class="fc" id="L715">        m.setElementAt(0, 0, sx);</span>
<span class="fc" id="L716">        m.setElementAt(1, 1, sy);</span>
<span class="fc" id="L717">        m.setElementAt(2, 2, sz);</span>
<span class="fc" id="L718">        m.setElementAt(0, 1, mxy);</span>
<span class="fc" id="L719">        m.setElementAt(0, 2, mxz);</span>
<span class="fc" id="L720">        m.setElementAt(1, 0, myx);</span>
<span class="fc" id="L721">        m.setElementAt(1, 2, myz);</span>
<span class="fc" id="L722">        m.setElementAt(2, 0, mzx);</span>
<span class="fc" id="L723">        m.setElementAt(2, 1, mzy);</span>
<span class="fc" id="L724">        setCrossCouplingErrors(m);</span>
<span class="fc" id="L725">    }</span>

    /**
     * Gets g-dependant cross biases matrix.
     *
     * @return g-dependant cross biases matrix.
     */
    public Matrix getGDependantCrossBias() {
<span class="fc" id="L733">        return new Matrix(gDependantCrossBias);</span>
    }

    /**
     * Gets g-dependant cross biases matrix.
     *
     * @param result instance where result will be stored.
     */
    public void getGDependantCrossBias(final Matrix result) {
<span class="fc" id="L742">        gDependantCrossBias.copyTo(result);</span>
<span class="fc" id="L743">    }</span>

    /**
     * Sets g-dependant cross biases matrix.
     *
     * @param gDependantCrossBias g-dependant cross biases matrix.
     * @throws IllegalArgumentException if provided matrix is not 3x3.
     */
    public void setGDependantCrossBias(final Matrix gDependantCrossBias) {
<span class="fc bfc" id="L752" title="All 2 branches covered.">        if (gDependantCrossBias.getRows() != BodyKinematics.COMPONENTS</span>
<span class="fc bfc" id="L753" title="All 2 branches covered.">                || gDependantCrossBias.getColumns() != BodyKinematics.COMPONENTS) {</span>
<span class="fc" id="L754">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L757">        this.gDependantCrossBias = gDependantCrossBias;</span>
<span class="fc" id="L758">    }</span>

    /**
     * Fixes provided measured angular rate values by undoing the errors
     * introduced by the gyroscope model to restore the true angular rate.
     * This method uses last provided bias and cross coupling errors.
     *
     * @param measuredAngularRate measured angular rate.
     * @param trueF               true (i.e. fixed) specific force.
     * @param result              instance where restored true angular rate will
     *                            be stored. Must have length 3.
     * @throws AlgebraException         if there are numerical instabilities.
     * @throws IllegalArgumentException if length of provided result array is
     *                                  not 3.
     */
    public void fix(
            final AngularSpeedTriad measuredAngularRate, final AccelerationTriad trueF, final double[] result)
            throws AlgebraException {
<span class="fc bfc" id="L776" title="All 2 branches covered.">        if (result.length != Triad.COMPONENTS) {</span>
<span class="fc" id="L777">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L780">        final var wX = convertAngularSpeed(measuredAngularRate.getValueX(), measuredAngularRate.getUnit());</span>
<span class="fc" id="L781">        final var wY = convertAngularSpeed(measuredAngularRate.getValueY(), measuredAngularRate.getUnit());</span>
<span class="fc" id="L782">        final var wZ = convertAngularSpeed(measuredAngularRate.getValueZ(), measuredAngularRate.getUnit());</span>
<span class="fc" id="L783">        final var trueFx = convertAcceleration(trueF.getValueX(), trueF.getUnit());</span>
<span class="fc" id="L784">        final var trueFy = convertAcceleration(trueF.getValueY(), trueF.getUnit());</span>
<span class="fc" id="L785">        final var trueFz = convertAcceleration(trueF.getValueZ(), trueF.getUnit());</span>
<span class="fc" id="L786">        fix(wX, wY, wZ, trueFx, trueFy, trueFz, result);</span>
<span class="fc" id="L787">    }</span>

    /**
     * Fixes provided measured angular rate values by undoing the errors
     * introduced by the gyroscope model to restore the true angular rate.
     * This method uses last provided bias and cross coupling errors.
     *
     * @param measuredAngularRate measured angular rate.
     * @param trueF               true (i.e. fixed) specific force.
     * @param result              instance where restored true angular rate will
     *                            be stored. Must be 3x1.
     * @throws AlgebraException         if there are numerical instabilities.
     * @throws IllegalArgumentException if result matrix is not 3x1.
     */
    public void fix(
            final AngularSpeedTriad measuredAngularRate, final AccelerationTriad trueF, final Matrix result)
            throws AlgebraException {
<span class="pc bpc" id="L804" title="1 of 4 branches missed.">        if (result.getRows() != Triad.COMPONENTS || result.getColumns() != 1) {</span>
<span class="fc" id="L805">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L808">        fix(measuredAngularRate, trueF, result.getBuffer());</span>
<span class="fc" id="L809">    }</span>

    /**
     * Fixes provided measured angular rate values by undoing the errors
     * introduced by the gyroscope model to restore the true angular rate.
     * This method uses last provided bias and cross coupling errors.
     *
     * @param measuredAngularRate measured angular rate.
     * @param trueF               true (i.e. fixed) specific force.
     * @param result              instance where restored true angular rate will be stored.
     * @throws AlgebraException if there are numerical instabilities.
     */
    public void fix(
            final AngularSpeedTriad measuredAngularRate, final AccelerationTriad trueF, final AngularSpeedTriad result)
            throws AlgebraException {
<span class="fc" id="L824">        fix(measuredAngularRate, trueF, this.res);</span>
<span class="fc" id="L825">        result.setValueCoordinates(this.res);</span>
<span class="fc" id="L826">        result.setUnit(AngularSpeedUnit.RADIANS_PER_SECOND);</span>
<span class="fc" id="L827">    }</span>

    /**
     * Fixes provided measured angular rate values by undoing the errors
     * introduced by the gyroscope model to restore the true angular rate.
     * This method uses last provided and cross coupling errors.
     *
     * @param measuredAngularRateX x-coordinate of measured angular rate.
     * @param measuredAngularRateY y-coordinate of measured angular rate.
     * @param measuredAngularRateZ z-coordinate of measured angular rate.
     * @param trueFx               x-coordinate of true (i.e. fixed) specific force.
     * @param trueFy               y-coordinate of true (i.e. fixed) specific force.
     * @param trueFz               z-coordinate of true (i.e. fixed) specific force.
     * @param result               instance where restored true angular rate will be stored.
     * @throws AlgebraException if there are numerical instabilities.
     */
    public void fix(
            final AngularSpeed measuredAngularRateX, final AngularSpeed measuredAngularRateY,
            final AngularSpeed measuredAngularRateZ, final Acceleration trueFx, final Acceleration trueFy,
            final Acceleration trueFz, final AngularSpeedTriad result) throws AlgebraException {
<span class="fc" id="L847">        final var wX = convertAngularSpeed(measuredAngularRateX);</span>
<span class="fc" id="L848">        final var wY = convertAngularSpeed(measuredAngularRateY);</span>
<span class="fc" id="L849">        final var wZ = convertAngularSpeed(measuredAngularRateZ);</span>
<span class="fc" id="L850">        final var fX = convertAcceleration(trueFx);</span>
<span class="fc" id="L851">        final var fY = convertAcceleration(trueFy);</span>
<span class="fc" id="L852">        final var fZ = convertAcceleration(trueFz);</span>
<span class="fc" id="L853">        fix(wX, wY, wZ, fX, fY, fZ, this.res);</span>
<span class="fc" id="L854">        result.setValueCoordinates(this.res);</span>
<span class="fc" id="L855">        result.setUnit(AngularSpeedUnit.RADIANS_PER_SECOND);</span>
<span class="fc" id="L856">    }</span>

    /**
     * Fixes provided measured angular rate values by undoing the errors
     * introduced by the gyroscope model to restore the true angular
     * rate.
     * This method uses last provided bias and cross coupling errors.
     *
     * @param measuredAngularRate measured angular rate expressed in radians
     *                            per second (rad/s). Must have length 3.
     * @param trueF               true (i.e. fixed) specific force expressed
     *                            in meters per squared second (m/s^2). Must
     *                            have length 3.
     * @param result              instance where restored true angular rate
     *                            will be stored. Must have length 3.
     * @throws AlgebraException         if there are numerical instabilities.
     * @throws IllegalArgumentException if any of the provided parameters
     *                                  does not have proper size.
     */
    public void fix(
            final double[] measuredAngularRate, final double[] trueF, final double[] result) throws AlgebraException {
<span class="fc bfc" id="L877" title="All 2 branches covered.">        if (measuredAngularRate.length != BodyKinematics.COMPONENTS) {</span>
<span class="fc" id="L878">            throw new IllegalArgumentException();</span>
        }
<span class="fc bfc" id="L880" title="All 2 branches covered.">        if (trueF.length != BodyKinematics.COMPONENTS) {</span>
<span class="fc" id="L881">            throw new IllegalArgumentException();</span>
        }
<span class="fc bfc" id="L883" title="All 2 branches covered.">        if (result.length != BodyKinematics.COMPONENTS) {</span>
<span class="fc" id="L884">            throw new IllegalArgumentException();</span>
        }

        // The gyroscope model is
        // Ωmeas = bg + (I + Mg) * Ωtrue + Gg * ftrue

        // Ωtrue = (I + Mg)^-1 * (Ωmeas - bg - Gg * ftrue)

<span class="fc" id="L892">        tmp3.fromArray(trueF);</span>
<span class="fc" id="L893">        gDependantCrossBias.multiply(tmp3, tmp4);</span>

<span class="fc bfc" id="L895" title="All 2 branches covered.">        for (var i = 0; i &lt; BodyKinematics.COMPONENTS; i++) {</span>
<span class="fc" id="L896">            diff.setElementAtIndex(i, measuredAngularRate[i] - bias.getElementAtIndex(i)</span>
<span class="fc" id="L897">                    - tmp4.getElementAtIndex(i));</span>
        }

<span class="fc" id="L900">        tmp2.multiply(diff, tmp5);</span>

<span class="fc" id="L902">        tmp5.toArray(result);</span>
<span class="fc" id="L903">    }</span>

    /**
     * Fixes provided measured angular rate values by undoing the errors
     * introduced by the gyroscope model to restore the true angular
     * rate.
     * This method uses last provided bias and cross coupling errors.
     *
     * @param measuredAngularRate measured angular rate expressed in radians
     *                            per second (rad/s). Must be 3x1.
     * @param trueF               true (i.e. fixed) specific force expressed
     *                            in meters per squared second (m/s^2). Must
     *                            be 3x1.
     * @param result              instance where restored true angular rate
     *                            will be stored. Must have length 3.
     * @throws AlgebraException         if there are numerical instabilities.
     * @throws IllegalArgumentException if any of the provided parameters
     *                                  does not have proper size.
     */
    public void fix(
            final Matrix measuredAngularRate, final Matrix trueF, final double[] result) throws AlgebraException {
<span class="fc bfc" id="L924" title="All 4 branches covered.">        if (measuredAngularRate.getRows() != BodyKinematics.COMPONENTS || measuredAngularRate.getColumns() != 1) {</span>
<span class="fc" id="L925">            throw new IllegalArgumentException();</span>
        }
<span class="fc bfc" id="L927" title="All 4 branches covered.">        if (trueF.getRows() != BodyKinematics.COMPONENTS || trueF.getColumns() != 1) {</span>
<span class="fc" id="L928">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L931">        fix(measuredAngularRate.getBuffer(), trueF.getBuffer(), result);</span>
<span class="fc" id="L932">    }</span>

    /**
     * Fixes provided measured angular rate values by undoing the errors
     * introduced by the gyroscope model to restore the true angular
     * rate.
     * This method uses last provided bias and cross coupling errors.
     *
     * @param measuredAngularRate measured angular rate expressed in radians
     *                            per second (rad/s). Must be 3x1.
     * @param trueF               true (i.e. fixed) specific force expressed
     *                            in meters per squared second (m/s^2). Must
     *                            be 3x1.
     * @param result              instance where restored true angular rate
     *                            will be stored. Must be 3x1.
     * @throws AlgebraException         if there are numerical instabilities.
     * @throws IllegalArgumentException if any of the provided parameters
     *                                  does not have proper size.
     */
    public void fix(
            final Matrix measuredAngularRate, final Matrix trueF, final Matrix result) throws AlgebraException {

<span class="pc bpc" id="L954" title="1 of 4 branches missed.">        if (result.getRows() != BodyKinematics.COMPONENTS || result.getColumns() != 1) {</span>
<span class="fc" id="L955">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L958">        fix(measuredAngularRate, trueF, result.getBuffer());</span>
<span class="fc" id="L959">    }</span>

    /**
     * Fixes provided measured angular rate values by undoing the errors
     * introduced by the gyroscope model to restore the true angular
     * rate.
     * This method uses last provided bias and cross coupling errors.
     *
     * @param measuredAngularRateX x-coordinate of measured angular rate
     *                             expressed in radians per second (rad/s).
     * @param measuredAngularRateY y-coordinate of measured angular rate
     *                             expressed in radians per second (rad/s).
     * @param measuredAngularRateZ z-coordinate of measured angular rate
     *                             expressed in radians per second (rad/s).
     * @param trueFx               x-coordinate of true (i.e. fixed)
     *                             specific force expressed in meters per
     *                             squared second (m/s^2).
     * @param trueFy               y-coordinate of true (i.e. fixed)
     *                             specific force expressed in meters per
     *                             squared second (m/s^2).
     * @param trueFz               z-coordinate of true (i.e. fixed)
     *                             specific force expressed in meters per
     *                             squared second (m/s^2).
     * @param result               instance where restored true angular rate
     *                             will be stored. Must have length 3.
     * @throws AlgebraException         if there are numerical instabilities.
     * @throws IllegalArgumentException if any of the provided parameters
     *                                  does not have proper size.
     */
    public void fix(
            final double measuredAngularRateX, final double measuredAngularRateY, final double measuredAngularRateZ,
            final double trueFx, final double trueFy, final double trueFz, final double[] result)
            throws AlgebraException {

<span class="fc" id="L993">        measuredAngularRate[0] = measuredAngularRateX;</span>
<span class="fc" id="L994">        measuredAngularRate[1] = measuredAngularRateY;</span>
<span class="fc" id="L995">        measuredAngularRate[2] = measuredAngularRateZ;</span>

<span class="fc" id="L997">        trueF[0] = trueFx;</span>
<span class="fc" id="L998">        trueF[1] = trueFy;</span>
<span class="fc" id="L999">        trueF[2] = trueFz;</span>

<span class="fc" id="L1001">        fix(measuredAngularRate, trueF, result);</span>
<span class="fc" id="L1002">    }</span>

    /**
     * Fixes provided measured angular rate values by undoing the errors
     * introduced by the gyroscope model to restore the true angular
     * rate.
     * This method uses last provided bias and cross coupling errors.
     *
     * @param measuredAngularRateX x-coordinate of measured angular rate
     *                             expressed in radians per second (rad/s).
     * @param measuredAngularRateY y-coordinate of measured angular rate
     *                             expressed in radians per second (rad/s).
     * @param measuredAngularRateZ z-coordinate of measured angular rate
     *                             expressed in radians per second (rad/s).
     * @param trueFx               x-coordinate of true (i.e. fixed)
     *                             specific force expressed in meters per
     *                             squared second (m/s^2).
     * @param trueFy               y-coordinate of true (i.e. fixed)
     *                             specific force expressed in meters per
     *                             squared second (m/s^2).
     * @param trueFz               z-coordinate of true (i.e. fixed)
     *                             specific force expressed in meters per
     *                             squared second (m/s^2).
     * @param result               instance where restored true angular rate
     *                             will be stored. Must be 3x1.
     * @throws AlgebraException         if there are numerical instabilities.
     * @throws IllegalArgumentException if any of the provided parameters
     *                                  does not have proper size.
     */
    public void fix(
            final double measuredAngularRateX, final double measuredAngularRateY, final double measuredAngularRateZ,
            final double trueFx, final double trueFy, final double trueFz, final Matrix result)
            throws AlgebraException {

<span class="fc bfc" id="L1036" title="All 4 branches covered.">        if (result.getRows() != BodyKinematics.COMPONENTS || result.getColumns() != 1) {</span>
<span class="fc" id="L1037">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L1040">        fix(measuredAngularRateX, measuredAngularRateY, measuredAngularRateZ, trueFx, trueFy, trueFz,</span>
<span class="fc" id="L1041">                result.getBuffer());</span>
<span class="fc" id="L1042">    }</span>

    /**
     * Fixes provided measured angular rate values by undoing the errors
     * introduced by the gyroscope model to restore the true angular
     * rate.
     *
     * @param measuredAngularRate measured angular rate expressed in radians
     *                            per second (rad/s). Must have length 3.
     * @param trueF               true (i.e. fixed) specific force expressed
     *                            in meters per squared second (m/s^2). Must
     *                            have length 3.
     * @param bias                bias values expressed in radians per
     *                            second (rad/s). Must be 3x1.
     * @param crossCouplingErrors cross coupling errors matrix. Must be 3x3.
     * @param gDependantCrossBias g-dependant cross biases matrix. Must be
     *                            3x3.
     * @param result              instance where restored true angular rate
     *                            will be stored. Must have length 3.
     * @throws AlgebraException         if there are numerical instabilities.
     * @throws IllegalArgumentException if any of the provided parameters
     *                                  does not have proper size.
     */
    public void fix(
            final double[] measuredAngularRate, final double[] trueF, final Matrix bias,
            final Matrix crossCouplingErrors, final Matrix gDependantCrossBias, final double[] result)
            throws AlgebraException {
<span class="fc bfc" id="L1069" title="All 2 branches covered.">        if (measuredAngularRate.length != BodyKinematics.COMPONENTS) {</span>
<span class="fc" id="L1070">            throw new IllegalArgumentException();</span>
        }
<span class="fc bfc" id="L1072" title="All 2 branches covered.">        if (trueF.length != BodyKinematics.COMPONENTS) {</span>
<span class="fc" id="L1073">            throw new IllegalArgumentException();</span>
        }
<span class="fc bfc" id="L1075" title="All 4 branches covered.">        if (bias.getRows() != BodyKinematics.COMPONENTS || bias.getColumns() != 1) {</span>
<span class="fc" id="L1076">            throw new IllegalArgumentException();</span>
        }
<span class="fc bfc" id="L1078" title="All 2 branches covered.">        if (crossCouplingErrors.getRows() != BodyKinematics.COMPONENTS</span>
<span class="fc bfc" id="L1079" title="All 2 branches covered.">                || crossCouplingErrors.getColumns() != BodyKinematics.COMPONENTS) {</span>
<span class="fc" id="L1080">            throw new IllegalArgumentException();</span>
        }
<span class="fc bfc" id="L1082" title="All 2 branches covered.">        if (gDependantCrossBias.getRows() != BodyKinematics.COMPONENTS</span>
<span class="fc bfc" id="L1083" title="All 2 branches covered.">                || gDependantCrossBias.getColumns() != BodyKinematics.COMPONENTS) {</span>
<span class="fc" id="L1084">            throw new IllegalArgumentException();</span>
        }
<span class="fc bfc" id="L1086" title="All 2 branches covered.">        if (result.length != BodyKinematics.COMPONENTS) {</span>
<span class="fc" id="L1087">            throw new IllegalArgumentException();</span>
        }

        // The gyroscope model is
        // Ωmeas = bg + (I + Mg) * Ωtrue + Gg * ftrue

        // Ωtrue = (I + Mg)^-1 * (Ωmeas - bg - Gg * ftrue)
<span class="fc" id="L1094">        identity.add(crossCouplingErrors, tmp1);</span>

<span class="fc" id="L1096">        Utils.inverse(tmp1, tmp2);</span>

<span class="fc" id="L1098">        tmp3.fromArray(trueF);</span>
<span class="fc" id="L1099">        gDependantCrossBias.multiply(tmp3, tmp4);</span>

<span class="fc bfc" id="L1101" title="All 2 branches covered.">        for (var i = 0; i &lt; BodyKinematics.COMPONENTS; i++) {</span>
<span class="fc" id="L1102">            diff.setElementAtIndex(i, measuredAngularRate[i] - bias.getElementAtIndex(i)</span>
<span class="fc" id="L1103">                    - tmp4.getElementAtIndex(i));</span>
        }

<span class="fc" id="L1106">        tmp2.multiply(diff, tmp5);</span>

<span class="fc" id="L1108">        tmp5.toArray(result);</span>
<span class="fc" id="L1109">    }</span>

    /**
     * Fixes provided measured angular rate values by undoing the errors
     * introduced by the gyroscope model to restore the true angular
     * rate.
     *
     * @param measuredAngularRate measured angular rate expressed in radians
     *                            per second (rad/s). Must be 3x1.
     * @param trueF               true (i.e. fixed) specific force expressed
     *                            in meters per squared second (m/s^2). Must
     *                            be 3x1.
     * @param bias                bias values expressed in radians per
     *                            second (rad/s). Must be 3x1.
     * @param crossCouplingErrors cross coupling errors matrix. Must be 3x3.
     * @param gDependantCrossBias g-dependant cross biases matrix. Must be
     *                            3x3.
     * @param result              instance where restored true angular rate
     *                            will be stored. Must have length 3.
     * @throws AlgebraException         if there are numerical instabilities.
     * @throws IllegalArgumentException if any of the provided parameters
     *                                  does not have proper size.
     */
    public void fix(
            final Matrix measuredAngularRate, final Matrix trueF, final Matrix bias, final Matrix crossCouplingErrors,
            final Matrix gDependantCrossBias, final double[] result) throws AlgebraException {

<span class="fc bfc" id="L1136" title="All 4 branches covered.">        if (measuredAngularRate.getRows() != BodyKinematics.COMPONENTS || measuredAngularRate.getColumns() != 1) {</span>
<span class="fc" id="L1137">            throw new IllegalArgumentException();</span>
        }
<span class="fc bfc" id="L1139" title="All 4 branches covered.">        if (trueF.getRows() != BodyKinematics.COMPONENTS || trueF.getColumns() != 1) {</span>
<span class="fc" id="L1140">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L1143">        fix(measuredAngularRate.getBuffer(), trueF.getBuffer(), bias, crossCouplingErrors, gDependantCrossBias, result);</span>
<span class="fc" id="L1144">    }</span>

    /**
     * Fixes provided measured angular rate values by undoing the errors
     * introduced by the gyroscope model to restore the true angular
     * rate.
     *
     * @param measuredAngularRate measured angular rate expressed in radians
     *                            per second (rad/s). Must be 3x1.
     * @param trueF               true (i.e. fixed) specific force expressed
     *                            in meters per squared second (m/s^2). Must
     *                            be 3x1.
     * @param bias                bias values expressed in radians per
     *                            second (rad/s). Must be 3x1.
     * @param crossCouplingErrors cross coupling errors matrix. Must be 3x3.
     * @param gDependantCrossBias g-dependant cross biases matrix. Must be
     *                            3x3.
     * @param result              instance where restored true angular rate
     *                            will be stored. Must be 3x1.
     * @throws AlgebraException         if there are numerical instabilities.
     * @throws IllegalArgumentException if any of the provided parameters
     *                                  does not have proper size.
     */
    public void fix(
            final Matrix measuredAngularRate, final Matrix trueF, final Matrix bias, final Matrix crossCouplingErrors,
            final Matrix gDependantCrossBias, final Matrix result) throws AlgebraException {

<span class="pc bpc" id="L1171" title="1 of 4 branches missed.">        if (result.getRows() != BodyKinematics.COMPONENTS || result.getColumns() != 1) {</span>
<span class="fc" id="L1172">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L1175">        fix(measuredAngularRate, trueF, bias, crossCouplingErrors, gDependantCrossBias, result.getBuffer());</span>
<span class="fc" id="L1176">    }</span>

    /**
     * Fixes provided measured angular rate values by undoing the errors
     * introduced by the gyroscope model to restore the true angular
     * rate.
     *
     * @param measuredAngularRateX x-coordinate of measured angular rate
     *                             expressed in radians per second (rad/s).
     * @param measuredAngularRateY y-coordinate of measured angular rate
     *                             expressed in radians per second (rad/s).
     * @param measuredAngularRateZ z-coordinate of measured angular rate
     *                             expressed in radians per second (rad/s).
     * @param trueFx               x-coordinate of true (i.e. fixed)
     *                             specific force expressed in meters per
     *                             squared second (m/s^2).
     * @param trueFy               y-coordinate of true (i.e. fixed)
     *                             specific force expressed in meters per
     *                             squared second (m/s^2).
     * @param trueFz               z-coordinate of true (i.e. fixed)
     *                             specific force expressed in meters per
     *                             squared second (m/s^2).
     * @param biasX                x-coordinate of bias expressed in
     *                             meters per squared second (m/s^2).
     * @param biasY                y-coordinate of bias expressed in
     *                             meters per squared second (m/s^2).
     * @param biasZ                z-coordinate of bias expressed in
     *                             meters per squared second (m/s^2).
     * @param crossCouplingErrors  cross coupling errors matrix. Must be 3x3.
     * @param gDependantCrossBias  g-dependant cross biases matrix. Must be
     *                             3x3.
     * @param result               instance where restored true angular rate
     *                             will be stored. Must have length 3.
     * @throws AlgebraException         if there are numerical instabilities.
     * @throws IllegalArgumentException if any of the provided parameters
     *                                  does not have proper size.
     */
    public void fix(
            final double measuredAngularRateX, final double measuredAngularRateY, final double measuredAngularRateZ,
            final double trueFx, final double trueFy, final double trueFz,
            final double biasX, final double biasY, final double biasZ, final Matrix crossCouplingErrors,
            final Matrix gDependantCrossBias, final double[] result) throws AlgebraException {

<span class="fc" id="L1219">        measuredAngularRate[0] = measuredAngularRateX;</span>
<span class="fc" id="L1220">        measuredAngularRate[1] = measuredAngularRateY;</span>
<span class="fc" id="L1221">        measuredAngularRate[2] = measuredAngularRateZ;</span>

<span class="fc" id="L1223">        trueF[0] = trueFx;</span>
<span class="fc" id="L1224">        trueF[1] = trueFy;</span>
<span class="fc" id="L1225">        trueF[2] = trueFz;</span>

<span class="fc" id="L1227">        bias.setElementAtIndex(0, biasX);</span>
<span class="fc" id="L1228">        bias.setElementAtIndex(1, biasY);</span>
<span class="fc" id="L1229">        bias.setElementAtIndex(2, biasZ);</span>

<span class="fc" id="L1231">        fix(measuredAngularRate, trueF, bias, crossCouplingErrors, gDependantCrossBias, result);</span>
<span class="fc" id="L1232">    }</span>

    /**
     * Fixes provided measured angular rate values by undoing the errors
     * introduced by the gyroscope model to restore the true angular
     * rate.
     *
     * @param measuredAngularRateX x-coordinate of measured angular rate
     *                             expressed in radians per second (rad/s).
     * @param measuredAngularRateY y-coordinate of measured angular rate
     *                             expressed in radians per second (rad/s).
     * @param measuredAngularRateZ z-coordinate of measured angular rate
     *                             expressed in radians per second (rad/s).
     * @param trueFx               x-coordinate of true (i.e. fixed)
     *                             specific force expressed in meters per
     *                             squared second (m/s^2).
     * @param trueFy               y-coordinate of true (i.e. fixed)
     *                             specific force expressed in meters per
     *                             squared second (m/s^2).
     * @param trueFz               z-coordinate of true (i.e. fixed)
     *                             specific force expressed in meters per
     *                             squared second (m/s^2).
     * @param biasX                x-coordinate of bias expressed in
     *                             meters per squared second (m/s^2).
     * @param biasY                y-coordinate of bias expressed in
     *                             meters per squared second (m/s^2).
     * @param biasZ                z-coordinate of bias expressed in
     *                             meters per squared second (m/s^2).
     * @param crossCouplingErrors  cross coupling errors matrix. Must be 3x3.
     * @param gDependantCrossBias  g-dependant cross biases matrix. Must be
     *                             3x3.
     * @param result               instance where restored true angular rate
     *                             will be stored. Must be 3x1.
     * @throws AlgebraException         if there are numerical instabilities.
     * @throws IllegalArgumentException if any of the provided parameters
     *                                  does not have proper size.
     */
    public void fix(
            final double measuredAngularRateX, final double measuredAngularRateY, final double measuredAngularRateZ,
            final double trueFx, final double trueFy, final double trueFz,
            final double biasX, final double biasY, final double biasZ, final Matrix crossCouplingErrors,
            final Matrix gDependantCrossBias, final Matrix result) throws AlgebraException {

<span class="fc bfc" id="L1275" title="All 4 branches covered.">        if (result.getRows() != BodyKinematics.COMPONENTS || result.getColumns() != 1) {</span>
<span class="fc" id="L1276">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L1279">        fix(measuredAngularRateX, measuredAngularRateY, measuredAngularRateZ,</span>
                trueFx, trueFy, trueFz, biasX, biasY, biasZ, crossCouplingErrors, gDependantCrossBias,
<span class="fc" id="L1281">                result.getBuffer());</span>
<span class="fc" id="L1282">    }</span>

    /**
     * Fixes provided measured angular rate values by undoing the errors
     * introduced by the gyroscope model to restore the true angular
     * rate.
     *
     * @param measuredAngularRateX x-coordinate of measured angular rate
     *                             expressed in radians per second (rad/s).
     * @param measuredAngularRateY y-coordinate of measured angular rate
     *                             expressed in radians per second (rad/s).
     * @param measuredAngularRateZ z-coordinate of measured angular rate
     *                             expressed in radians per second (rad/s).
     * @param trueFx               x-coordinate of true (i.e. fixed)
     *                             specific force expressed in meters per
     *                             squared second (m/s^2).
     * @param trueFy               y-coordinate of true (i.e. fixed)
     *                             specific force expressed in meters per
     *                             squared second (m/s^2).
     * @param trueFz               z-coordinate of true (i.e. fixed)
     *                             specific force expressed in meters per
     *                             squared second (m/s^2).
     * @param biasX                x-coordinate of bias expressed in
     *                             meters per squared second (m/s^2).
     * @param biasY                y-coordinate of bias expressed in
     *                             meters per squared second (m/s^2).
     * @param biasZ                z-coordinate of bias expressed in
     *                             meters per squared second (m/s^2).
     * @param sx                   initial x scaling factor.
     * @param sy                   initial y scaling factor.
     * @param sz                   initial z scaling factor.
     * @param mxy                  initial x-y cross coupling error.
     * @param mxz                  initial x-z cross coupling error.
     * @param myx                  initial y-x cross coupling error.
     * @param myz                  initial y-z cross coupling error.
     * @param mzx                  initial z-x cross coupling error.
     * @param mzy                  initial z-y cross coupling error.
     * @param g11                  element 1,1 of g-dependant cross biases.
     * @param g21                  element 2,1 of g-dependant cross biases.
     * @param g31                  element 3,1 of g-dependant cross biases.
     * @param g12                  element 1,2 of g-dependant cross biases.
     * @param g22                  element 2,2 of g-dependant cross biases.
     * @param g32                  element 3,2 of g-dependant cross biases.
     * @param g13                  element 1,3 of g-dependant cross biases.
     * @param g23                  element 2,3 of g-dependant cross biases.
     * @param g33                  element 3,3 of g-dependant cross biases.
     * @param result               instance where restored true angular rate
     *                             will be stored. Must have length 3.
     * @throws AlgebraException         if there are numerical instabilities.
     * @throws IllegalArgumentException if any of the provided parameters
     *                                  does not have proper size.
     */
    public void fix(
            final double measuredAngularRateX, final double measuredAngularRateY, final double measuredAngularRateZ,
            final double trueFx, final double trueFy, final double trueFz,
            final double biasX, final double biasY, final double biasZ,
            final double sx, final double sy, final double sz,
            final double mxy, final double mxz, final double myx,
            final double myz, final double mzx, final double mzy,
            final double g11, final double g21, final double g31,
            final double g12, final double g22, final double g32,
            final double g13, final double g23, final double g33, final double[] result) throws AlgebraException {

<span class="fc" id="L1345">        crossCouplingErrors.setElementAt(0, 0, sx);</span>
<span class="fc" id="L1346">        crossCouplingErrors.setElementAt(1, 1, sy);</span>
<span class="fc" id="L1347">        crossCouplingErrors.setElementAt(2, 2, sz);</span>
<span class="fc" id="L1348">        crossCouplingErrors.setElementAt(0, 1, mxy);</span>
<span class="fc" id="L1349">        crossCouplingErrors.setElementAt(0, 2, mxz);</span>
<span class="fc" id="L1350">        crossCouplingErrors.setElementAt(1, 0, myx);</span>
<span class="fc" id="L1351">        crossCouplingErrors.setElementAt(1, 2, myz);</span>
<span class="fc" id="L1352">        crossCouplingErrors.setElementAt(2, 0, mzx);</span>
<span class="fc" id="L1353">        crossCouplingErrors.setElementAt(2, 1, mzy);</span>

<span class="fc" id="L1355">        gDependantCrossBias.setElementAt(0, 0, g11);</span>
<span class="fc" id="L1356">        gDependantCrossBias.setElementAt(1, 0, g21);</span>
<span class="fc" id="L1357">        gDependantCrossBias.setElementAt(2, 0, g31);</span>
<span class="fc" id="L1358">        gDependantCrossBias.setElementAt(0, 1, g12);</span>
<span class="fc" id="L1359">        gDependantCrossBias.setElementAt(1, 1, g22);</span>
<span class="fc" id="L1360">        gDependantCrossBias.setElementAt(2, 1, g32);</span>
<span class="fc" id="L1361">        gDependantCrossBias.setElementAt(0, 2, g13);</span>
<span class="fc" id="L1362">        gDependantCrossBias.setElementAt(1, 2, g23);</span>
<span class="fc" id="L1363">        gDependantCrossBias.setElementAt(2, 2, g33);</span>

<span class="fc" id="L1365">        fix(measuredAngularRateX, measuredAngularRateY, measuredAngularRateZ, trueFx, trueFy, trueFz,</span>
                biasX, biasY, biasZ, crossCouplingErrors, gDependantCrossBias, result);
<span class="fc" id="L1367">    }</span>

    /**
     * Fixes provided measured angular rate values by undoing the errors
     * introduced by the gyroscope model to restore the true angular
     * rate.
     *
     * @param measuredAngularRateX x-coordinate of measured angular rate
     *                             expressed in radians per second (rad/s).
     * @param measuredAngularRateY y-coordinate of measured angular rate
     *                             expressed in radians per second (rad/s).
     * @param measuredAngularRateZ z-coordinate of measured angular rate
     *                             expressed in radians per second (rad/s).
     * @param trueFx               x-coordinate of true (i.e. fixed)
     *                             specific force expressed in meters per
     *                             squared second (m/s^2).
     * @param trueFy               y-coordinate of true (i.e. fixed)
     *                             specific force expressed in meters per
     *                             squared second (m/s^2).
     * @param trueFz               z-coordinate of true (i.e. fixed)
     *                             specific force expressed in meters per
     *                             squared second (m/s^2).
     * @param biasX                x-coordinate of bias expressed in
     *                             meters per squared second (m/s^2).
     * @param biasY                y-coordinate of bias expressed in
     *                             meters per squared second (m/s^2).
     * @param biasZ                z-coordinate of bias expressed in
     *                             meters per squared second (m/s^2).
     * @param sx                   initial x scaling factor.
     * @param sy                   initial y scaling factor.
     * @param sz                   initial z scaling factor.
     * @param mxy                  initial x-y cross coupling error.
     * @param mxz                  initial x-z cross coupling error.
     * @param myx                  initial y-x cross coupling error.
     * @param myz                  initial y-z cross coupling error.
     * @param mzx                  initial z-x cross coupling error.
     * @param mzy                  initial z-y cross coupling error.
     * @param g11                  element 1,1 of g-dependant cross biases.
     * @param g21                  element 2,1 of g-dependant cross biases.
     * @param g31                  element 3,1 of g-dependant cross biases.
     * @param g12                  element 1,2 of g-dependant cross biases.
     * @param g22                  element 2,2 of g-dependant cross biases.
     * @param g32                  element 3,2 of g-dependant cross biases.
     * @param g13                  element 1,3 of g-dependant cross biases.
     * @param g23                  element 2,3 of g-dependant cross biases.
     * @param g33                  element 3,3 of g-dependant cross biases.
     * @param result               instance where restored true angular rate
     *                             will be stored. Must be 3x1.
     * @throws AlgebraException         if there are numerical instabilities.
     * @throws IllegalArgumentException if any of the provided parameters
     *                                  does not have proper size.
     */
    public void fix(
            final double measuredAngularRateX, final double measuredAngularRateY, final double measuredAngularRateZ,
            final double trueFx, final double trueFy, final double trueFz,
            final double biasX, final double biasY, final double biasZ,
            final double sx, final double sy, final double sz,
            final double mxy, final double mxz, final double myx,
            final double myz, final double mzx, final double mzy,
            final double g11, final double g21, final double g31,
            final double g12, final double g22, final double g32,
            final double g13, final double g23, final double g33, final Matrix result) throws AlgebraException {

<span class="fc bfc" id="L1430" title="All 4 branches covered.">        if (result.getRows() != BodyKinematics.COMPONENTS || result.getColumns() != 1) {</span>
<span class="fc" id="L1431">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L1434">        fix(measuredAngularRateX, measuredAngularRateY, measuredAngularRateZ,</span>
                trueFx, trueFy, trueFz, biasX, biasY, biasZ,
                sx, sy, sz, mxy, mxz, myx, myz, mzx, mzy,
<span class="fc" id="L1437">                g11, g21, g31, g12, g22, g32, g13, g23, g33, result.getBuffer());</span>
<span class="fc" id="L1438">    }</span>

    /**
     * Fixes provided measured angular rate values by undoing the errors
     * introduced by the gyroscope model to restore the true angular rate.
     * This method uses last provided bias and cross coupling errors.
     *
     * @param measuredAngularRate measured angular rate.
     * @param trueF               true (i.e. fixed) specific force.
     * @return restored true angular rate.
     * @throws AlgebraException if there are numerical instabilities.
     */
    public AngularSpeedTriad fixAndReturnNew(
            final AngularSpeedTriad measuredAngularRate, final AccelerationTriad trueF) throws AlgebraException {
<span class="fc" id="L1452">        final var result = new AngularSpeedTriad();</span>
<span class="fc" id="L1453">        fix(measuredAngularRate, trueF, result);</span>
<span class="fc" id="L1454">        return result;</span>
    }

    /**
     * Fixes provided measured angular rate values by undoing the errors
     * introduced by the gyroscope model to restore the true angular rate.
     * This method uses last provided bias and cross coupling errors.
     *
     * @param measuredAngularRateX x-coordinate of measured angular rate.
     * @param measuredAngularRateY y-coordinate of measured angular rate.
     * @param measuredAngularRateZ z-coordinate of measured angular rate.
     * @param trueFx               x-coordinate of true (i.e. fixed) specific force.
     * @param trueFy               y-coordinate of true (i.e. fixed) specific force.
     * @param trueFz               z-coordinate of true (i.e. fixed) specific force.
     * @return restored true angular rate.
     * @throws AlgebraException if there are numerical instabilities.
     */
    public AngularSpeedTriad fixAndReturnNew(
            final AngularSpeed measuredAngularRateX, final AngularSpeed measuredAngularRateY,
            final AngularSpeed measuredAngularRateZ, final Acceleration trueFx, final Acceleration trueFy,
            final Acceleration trueFz) throws AlgebraException {
<span class="fc" id="L1475">        final var result = new AngularSpeedTriad();</span>
<span class="fc" id="L1476">        fix(measuredAngularRateX, measuredAngularRateY, measuredAngularRateZ, trueFx, trueFy, trueFz, result);</span>
<span class="fc" id="L1477">        return result;</span>
    }

    /**
     * Fixes provided measured angular rate values by undoing the errors
     * introduced by the gyroscope model to restore the true angular
     * rate.
     * This method uses last provided bias and cross coupling errors.
     *
     * @param measuredAngularRate measured angular rate expressed in radians
     *                            per second (rad/s). Must have length 3.
     * @param trueF               true (i.e. fixed) specific force expressed
     *                            in meters per squared second (m/s^2). Must
     *                            have length 3.
     * @return restored true angular rate.
     * @throws AlgebraException         if there are numerical instabilities.
     * @throws IllegalArgumentException if any of the provided parameters
     *                                  does not have proper size.
     */
    public double[] fixAndReturnNew(final double[] measuredAngularRate, final double[] trueF) throws AlgebraException {
<span class="fc" id="L1497">        final var result = new double[BodyKinematics.COMPONENTS];</span>
<span class="fc" id="L1498">        fix(measuredAngularRate, trueF, result);</span>
<span class="fc" id="L1499">        return result;</span>
    }

    /**
     * Fixes provided measured angular rate values by undoing the errors
     * introduced by the gyroscope model to restore the true angular
     * rate.
     * This method uses last provided bias and cross coupling errors.
     *
     * @param measuredAngularRate measured angular rate expressed in radians
     *                            per second (rad/s). Must be 3x1.
     * @param trueF               true (i.e. fixed) specific force expressed
     *                            in meters per squared second (m/s^2). Must
     *                            be 3x1.
     * @return restored true angular rate.
     * @throws AlgebraException         if there are numerical instabilities.
     * @throws IllegalArgumentException if any of the provided parameters
     *                                  does not have proper size.
     */
    public double[] fixAndReturnNew(final Matrix measuredAngularRate, final Matrix trueF) throws AlgebraException {
<span class="fc" id="L1519">        final var result = new double[BodyKinematics.COMPONENTS];</span>
<span class="fc" id="L1520">        fix(measuredAngularRate, trueF, result);</span>
<span class="fc" id="L1521">        return result;</span>
    }

    /**
     * Fixes provided measured angular rate values by undoing the errors
     * introduced by the gyroscope model to restore the true angular
     * rate.
     * This method uses last provided bias and cross coupling errors.
     *
     * @param measuredAngularRate measured angular rate expressed in radians
     *                            per second (rad/s). Must be 3x1.
     * @param trueF               true (i.e. fixed) specific force expressed
     *                            in meters per squared second (m/s^2). Must
     *                            be 3x1.
     * @return restored true angular rate.
     * @throws AlgebraException         if there are numerical instabilities.
     * @throws IllegalArgumentException if any of the provided parameters
     *                                  does not have proper size.
     */
    public Matrix fixAndReturnNewMatrix(
            final Matrix measuredAngularRate, final Matrix trueF) throws AlgebraException {

<span class="fc" id="L1543">        final var result = new Matrix(BodyKinematics.COMPONENTS, 1);</span>
<span class="fc" id="L1544">        fix(measuredAngularRate, trueF, result);</span>
<span class="fc" id="L1545">        return result;</span>
    }

    /**
     * Fixes provided measured angular rate values by undoing the errors
     * introduced by the gyroscope model to restore the true angular
     * rate.
     * This method uses last provided bias and cross coupling errors.
     *
     * @param measuredAngularRateX x-coordinate of measured angular rate
     *                             expressed in radians per second (rad/s).
     * @param measuredAngularRateY y-coordinate of measured angular rate
     *                             expressed in radians per second (rad/s).
     * @param measuredAngularRateZ z-coordinate of measured angular rate
     *                             expressed in radians per second (rad/s).
     * @param trueFx               x-coordinate of true (i.e. fixed)
     *                             specific force expressed in meters per
     *                             squared second (m/s^2).
     * @param trueFy               y-coordinate of true (i.e. fixed)
     *                             specific force expressed in meters per
     *                             squared second (m/s^2).
     * @param trueFz               z-coordinate of true (i.e. fixed)
     *                             specific force expressed in meters per
     *                             squared second (m/s^2).
     * @return restored true angular rate.
     * @throws AlgebraException if there are numerical instabilities.
     */
    public double[] fixAndReturnNew(
            final double measuredAngularRateX, final double measuredAngularRateY, final double measuredAngularRateZ,
            final double trueFx, final double trueFy, final double trueFz) throws AlgebraException {

<span class="fc" id="L1576">        final var result = new double[BodyKinematics.COMPONENTS];</span>
<span class="fc" id="L1577">        fix(measuredAngularRateX, measuredAngularRateY, measuredAngularRateZ, trueFx, trueFy, trueFz, result);</span>
<span class="fc" id="L1578">        return result;</span>
    }

    /**
     * Fixes provided measured angular rate values by undoing the errors
     * introduced by the gyroscope model to restore the true angular
     * rate.
     * This method uses last provided bias and cross coupling errors.
     *
     * @param measuredAngularRateX x-coordinate of measured angular rate
     *                             expressed in radians per second (rad/s).
     * @param measuredAngularRateY y-coordinate of measured angular rate
     *                             expressed in radians per second (rad/s).
     * @param measuredAngularRateZ z-coordinate of measured angular rate
     *                             expressed in radians per second (rad/s).
     * @param trueFx               x-coordinate of true (i.e. fixed)
     *                             specific force expressed in meters per
     *                             squared second (m/s^2).
     * @param trueFy               y-coordinate of true (i.e. fixed)
     *                             specific force expressed in meters per
     *                             squared second (m/s^2).
     * @param trueFz               z-coordinate of true (i.e. fixed)
     *                             specific force expressed in meters per
     *                             squared second (m/s^2).
     * @return restored true angular rate.
     * @throws AlgebraException if there are numerical instabilities.
     */
    public Matrix fixAndReturnNewMatrix(
            final double measuredAngularRateX, final double measuredAngularRateY, final double measuredAngularRateZ,
            final double trueFx, final double trueFy, final double trueFz) throws AlgebraException {

<span class="fc" id="L1609">        final var result = new Matrix(BodyKinematics.COMPONENTS, 1);</span>
<span class="fc" id="L1610">        fix(measuredAngularRateX, measuredAngularRateY, measuredAngularRateZ, trueFx, trueFy, trueFz, result);</span>
<span class="fc" id="L1611">        return result;</span>
    }


    /**
     * Fixes provided measured angular rate values by undoing the errors
     * introduced by the gyroscope model to restore the true angular
     * rate.
     *
     * @param measuredAngularRate measured angular rate expressed in radians
     *                            per second (rad/s). Must have length 3.
     * @param trueF               true (i.e. fixed) specific force expressed
     *                            in meters per squared second (m/s^2). Must
     *                            have length 3.
     * @param bias                bias values expressed in radians per
     *                            second (rad/s). Must be 3x1.
     * @param crossCouplingErrors cross coupling errors matrix. Must be 3x3.
     * @param gDependantCrossBias g-dependant cross biases matrix. Must be
     *                            3x3.
     * @return restored true angular rate.
     * @throws AlgebraException         if there are numerical instabilities.
     * @throws IllegalArgumentException if any of the provided parameters
     *                                  does not have proper size.
     */
    public double[] fixAndReturnNew(
            final double[] measuredAngularRate, final double[] trueF, final Matrix bias,
            final Matrix crossCouplingErrors, final Matrix gDependantCrossBias) throws AlgebraException {

<span class="fc" id="L1639">        final var result = new double[BodyKinematics.COMPONENTS];</span>
<span class="fc" id="L1640">        fix(measuredAngularRate, trueF, bias, crossCouplingErrors, gDependantCrossBias, result);</span>
<span class="fc" id="L1641">        return result;</span>
    }

    /**
     * Fixes provided measured angular rate values by undoing the errors
     * introduced by the gyroscope model to restore the true angular
     * rate.
     *
     * @param measuredAngularRate measured angular rate expressed in radians
     *                            per second (rad/s). Must be 3x1.
     * @param trueF               true (i.e. fixed) specific force expressed
     *                            in meters per squared second (m/s^2). Must
     *                            be 3x1.
     * @param bias                bias values expressed in radians per
     *                            second (rad/s). Must be 3x1.
     * @param crossCouplingErrors cross coupling errors matrix. Must be 3x3.
     * @param gDependantCrossBias g-dependant cross biases matrix. Must be
     *                            3x3.
     * @return restored true angular rate.
     * @throws AlgebraException         if there are numerical instabilities.
     * @throws IllegalArgumentException if any of the provided parameters
     *                                  does not have proper size.
     */
    public double[] fixAndReturnNew(
            final Matrix measuredAngularRate, final Matrix trueF, final Matrix bias,
            final Matrix crossCouplingErrors, final Matrix gDependantCrossBias) throws AlgebraException {

<span class="fc" id="L1668">        final var result = new double[BodyKinematics.COMPONENTS];</span>
<span class="fc" id="L1669">        fix(measuredAngularRate, trueF, bias, crossCouplingErrors, gDependantCrossBias, result);</span>
<span class="fc" id="L1670">        return result;</span>
    }

    /**
     * Fixes provided measured angular rate values by undoing the errors
     * introduced by the gyroscope model to restore the true angular
     * rate.
     *
     * @param measuredAngularRate measured angular rate expressed in radians
     *                            per second (rad/s). Must be 3x1.
     * @param trueF               true (i.e. fixed) specific force expressed
     *                            in meters per squared second (m/s^2). Must
     *                            be 3x1.
     * @param bias                bias values expressed in radians per
     *                            second (rad/s). Must be 3x1.
     * @param crossCouplingErrors cross coupling errors matrix. Must be 3x3.
     * @param gDependantCrossBias g-dependant cross biases matrix. Must be
     *                            3x3.
     * @return restored true angular rate.
     * @throws AlgebraException         if there are numerical instabilities.
     * @throws IllegalArgumentException if any of the provided parameters
     *                                  does not have proper size.
     */
    public Matrix fixAndReturnNewMatrix(
            final Matrix measuredAngularRate, final Matrix trueF, final Matrix bias,
            final Matrix crossCouplingErrors, final Matrix gDependantCrossBias) throws AlgebraException {

<span class="fc" id="L1697">        final var result = new Matrix(BodyKinematics.COMPONENTS, 1);</span>
<span class="fc" id="L1698">        fix(measuredAngularRate, trueF, bias, crossCouplingErrors, gDependantCrossBias, result);</span>
<span class="fc" id="L1699">        return result;</span>
    }

    /**
     * Fixes provided measured angular rate values by undoing the errors
     * introduced by the gyroscope model to restore the true angular
     * rate.
     *
     * @param measuredAngularRateX x-coordinate of measured angular rate
     *                             expressed in radians per second (rad/s).
     * @param measuredAngularRateY y-coordinate of measured angular rate
     *                             expressed in radians per second (rad/s).
     * @param measuredAngularRateZ z-coordinate of measured angular rate
     *                             expressed in radians per second (rad/s).
     * @param trueFx               x-coordinate of true (i.e. fixed)
     *                             specific force expressed in meters per
     *                             squared second (m/s^2).
     * @param trueFy               y-coordinate of true (i.e. fixed)
     *                             specific force expressed in meters per
     *                             squared second (m/s^2).
     * @param trueFz               z-coordinate of true (i.e. fixed)
     *                             specific force expressed in meters per
     *                             squared second (m/s^2).
     * @param biasX                x-coordinate of bias expressed in
     *                             meters per squared second (m/s^2).
     * @param biasY                y-coordinate of bias expressed in
     *                             meters per squared second (m/s^2).
     * @param biasZ                z-coordinate of bias expressed in
     *                             meters per squared second (m/s^2).
     * @param crossCouplingErrors  cross coupling errors matrix. Must be 3x3.
     * @param gDependantCrossBias  g-dependant cross biases matrix. Must be
     *                             3x3.
     * @return restored true angular rate.
     * @throws AlgebraException         if there are numerical instabilities.
     * @throws IllegalArgumentException if any of the provided parameters
     *                                  does not have proper size.
     */
    public double[] fixAndReturnNew(
            final double measuredAngularRateX, final double measuredAngularRateY, final double measuredAngularRateZ,
            final double trueFx, final double trueFy, final double trueFz,
            final double biasX, final double biasY, final double biasZ, final Matrix crossCouplingErrors,
            final Matrix gDependantCrossBias) throws AlgebraException {

<span class="fc" id="L1742">        final var result = new double[BodyKinematics.COMPONENTS];</span>
<span class="fc" id="L1743">        fix(measuredAngularRateX, measuredAngularRateY, measuredAngularRateZ,</span>
                trueFx, trueFy, trueFz, biasX, biasY, biasZ, crossCouplingErrors, gDependantCrossBias, result);
<span class="fc" id="L1745">        return result;</span>
    }

    /**
     * Fixes provided measured angular rate values by undoing the errors
     * introduced by the gyroscope model to restore the true angular
     * rate.
     *
     * @param measuredAngularRateX x-coordinate of measured angular rate
     *                             expressed in radians per second (rad/s).
     * @param measuredAngularRateY y-coordinate of measured angular rate
     *                             expressed in radians per second (rad/s).
     * @param measuredAngularRateZ z-coordinate of measured angular rate
     *                             expressed in radians per second (rad/s).
     * @param trueFx               x-coordinate of true (i.e. fixed)
     *                             specific force expressed in meters per
     *                             squared second (m/s^2).
     * @param trueFy               y-coordinate of true (i.e. fixed)
     *                             specific force expressed in meters per
     *                             squared second (m/s^2).
     * @param trueFz               z-coordinate of true (i.e. fixed)
     *                             specific force expressed in meters per
     *                             squared second (m/s^2).
     * @param biasX                x-coordinate of bias expressed in
     *                             meters per squared second (m/s^2).
     * @param biasY                y-coordinate of bias expressed in
     *                             meters per squared second (m/s^2).
     * @param biasZ                z-coordinate of bias expressed in
     *                             meters per squared second (m/s^2).
     * @param crossCouplingErrors  cross coupling errors matrix. Must be 3x3.
     * @param gDependantCrossBias  g-dependant cross biases matrix. Must be
     *                             3x3.
     * @return restored true angular rate.
     * @throws AlgebraException         if there are numerical instabilities.
     * @throws IllegalArgumentException if any of the provided parameters
     *                                  does not have proper size.
     */
    public Matrix fixAndReturnNewMatrix(
            final double measuredAngularRateX, final double measuredAngularRateY, final double measuredAngularRateZ,
            final double trueFx, final double trueFy, final double trueFz,
            final double biasX, final double biasY, final double biasZ,
            final Matrix crossCouplingErrors, final Matrix gDependantCrossBias) throws AlgebraException {

<span class="fc" id="L1788">        final var result = new Matrix(BodyKinematics.COMPONENTS, 1);</span>
<span class="fc" id="L1789">        fix(measuredAngularRateX, measuredAngularRateY, measuredAngularRateZ,</span>
                trueFx, trueFy, trueFz, biasX, biasY, biasZ, crossCouplingErrors, gDependantCrossBias, result);
<span class="fc" id="L1791">        return result;</span>
    }

    /**
     * Fixes provided measured angular rate values by undoing the errors
     * introduced by the gyroscope model to restore the true angular
     * rate.
     *
     * @param measuredAngularRateX x-coordinate of measured angular rate
     *                             expressed in radians per second (rad/s).
     * @param measuredAngularRateY y-coordinate of measured angular rate
     *                             expressed in radians per second (rad/s).
     * @param measuredAngularRateZ z-coordinate of measured angular rate
     *                             expressed in radians per second (rad/s).
     * @param trueFx               x-coordinate of true (i.e. fixed)
     *                             specific force expressed in meters per
     *                             squared second (m/s^2).
     * @param trueFy               y-coordinate of true (i.e. fixed)
     *                             specific force expressed in meters per
     *                             squared second (m/s^2).
     * @param trueFz               z-coordinate of true (i.e. fixed)
     *                             specific force expressed in meters per
     *                             squared second (m/s^2).
     * @param biasX                x-coordinate of bias expressed in
     *                             meters per squared second (m/s^2).
     * @param biasY                y-coordinate of bias expressed in
     *                             meters per squared second (m/s^2).
     * @param biasZ                z-coordinate of bias expressed in
     *                             meters per squared second (m/s^2).
     * @param sx                   initial x scaling factor.
     * @param sy                   initial y scaling factor.
     * @param sz                   initial z scaling factor.
     * @param mxy                  initial x-y cross coupling error.
     * @param mxz                  initial x-z cross coupling error.
     * @param myx                  initial y-x cross coupling error.
     * @param myz                  initial y-z cross coupling error.
     * @param mzx                  initial z-x cross coupling error.
     * @param mzy                  initial z-y cross coupling error.
     * @param g11                  element 1,1 of g-dependant cross biases.
     * @param g21                  element 2,1 of g-dependant cross biases.
     * @param g31                  element 3,1 of g-dependant cross biases.
     * @param g12                  element 1,2 of g-dependant cross biases.
     * @param g22                  element 2,2 of g-dependant cross biases.
     * @param g32                  element 3,2 of g-dependant cross biases.
     * @param g13                  element 1,3 of g-dependant cross biases.
     * @param g23                  element 2,3 of g-dependant cross biases.
     * @param g33                  element 3,3 of g-dependant cross biases.
     * @return restored true angular rate.
     * @throws AlgebraException if there are numerical instabilities.
     */
    public double[] fixAndReturnNew(
            final double measuredAngularRateX, final double measuredAngularRateY, final double measuredAngularRateZ,
            final double trueFx, final double trueFy, final double trueFz,
            final double biasX, final double biasY, final double biasZ,
            final double sx, final double sy, final double sz,
            final double mxy, final double mxz, final double myx,
            final double myz, final double mzx, final double mzy,
            final double g11, final double g21, final double g31,
            final double g12, final double g22, final double g32,
            final double g13, final double g23, final double g33) throws AlgebraException {

<span class="fc" id="L1852">        final var result = new double[BodyKinematics.COMPONENTS];</span>
<span class="fc" id="L1853">        fix(measuredAngularRateX, measuredAngularRateY, measuredAngularRateZ,</span>
                trueFx, trueFy, trueFz, biasX, biasY, biasZ, sx, sy, sz, mxy, mxz, myx, myz, mzx, mzy,
                g11, g21, g31, g12, g22, g32, g13, g23, g33, result);
<span class="fc" id="L1856">        return result;</span>
    }

    /**
     * Fixes provided measured angular rate values by undoing the errors
     * introduced by the gyroscope model to restore the true angular
     * rate.
     *
     * @param measuredAngularRateX x-coordinate of measured angular rate
     *                             expressed in radians per second (rad/s).
     * @param measuredAngularRateY y-coordinate of measured angular rate
     *                             expressed in radians per second (rad/s).
     * @param measuredAngularRateZ z-coordinate of measured angular rate
     *                             expressed in radians per second (rad/s).
     * @param trueFx               x-coordinate of true (i.e. fixed)
     *                             specific force expressed in meters per
     *                             squared second (m/s^2).
     * @param trueFy               y-coordinate of true (i.e. fixed)
     *                             specific force expressed in meters per
     *                             squared second (m/s^2).
     * @param trueFz               z-coordinate of true (i.e. fixed)
     *                             specific force expressed in meters per
     *                             squared second (m/s^2).
     * @param biasX                x-coordinate of bias expressed in
     *                             meters per squared second (m/s^2).
     * @param biasY                y-coordinate of bias expressed in
     *                             meters per squared second (m/s^2).
     * @param biasZ                z-coordinate of bias expressed in
     *                             meters per squared second (m/s^2).
     * @param sx                   initial x scaling factor.
     * @param sy                   initial y scaling factor.
     * @param sz                   initial z scaling factor.
     * @param mxy                  initial x-y cross coupling error.
     * @param mxz                  initial x-z cross coupling error.
     * @param myx                  initial y-x cross coupling error.
     * @param myz                  initial y-z cross coupling error.
     * @param mzx                  initial z-x cross coupling error.
     * @param mzy                  initial z-y cross coupling error.
     * @param g11                  element 1,1 of g-dependant cross biases.
     * @param g21                  element 2,1 of g-dependant cross biases.
     * @param g31                  element 3,1 of g-dependant cross biases.
     * @param g12                  element 1,2 of g-dependant cross biases.
     * @param g22                  element 2,2 of g-dependant cross biases.
     * @param g32                  element 3,2 of g-dependant cross biases.
     * @param g13                  element 1,3 of g-dependant cross biases.
     * @param g23                  element 2,3 of g-dependant cross biases.
     * @param g33                  element 3,3 of g-dependant cross biases.
     * @return restored true angular rate.
     * @throws AlgebraException if there are numerical instabilities.
     */
    public Matrix fixAndReturnNewMatrix(
            final double measuredAngularRateX, final double measuredAngularRateY, final double measuredAngularRateZ,
            final double trueFx, final double trueFy, final double trueFz,
            final double biasX, final double biasY, final double biasZ,
            final double sx, final double sy, final double sz,
            final double mxy, final double mxz, final double myx,
            final double myz, final double mzx, final double mzy,
            final double g11, final double g21, final double g31,
            final double g12, final double g22, final double g32,
            final double g13, final double g23, final double g33) throws AlgebraException {

<span class="fc" id="L1917">        final var result = new Matrix(BodyKinematics.COMPONENTS, 1);</span>
<span class="fc" id="L1918">        fix(measuredAngularRateX, measuredAngularRateY, measuredAngularRateZ,</span>
                trueFx, trueFy, trueFz, biasX, biasY, biasZ, sx, sy, sz, mxy, mxz, myx, myz, mzx, mzy,
                g11, g21, g31, g12, g22, g32, g13, g23, g33, result);
<span class="fc" id="L1921">        return result;</span>
    }

    /**
     * Converts angular speed value and unit to radians per second (rad/s).
     *
     * @param value value to be converted.
     * @param unit  unit of value to be converted.
     * @return converted value.
     */
    private static double convertAngularSpeed(final double value, final AngularSpeedUnit unit) {
<span class="fc" id="L1932">        return AngularSpeedConverter.convert(value, unit, AngularSpeedUnit.RADIANS_PER_SECOND);</span>
    }

    /**
     * Converts angular speed measurement to radians per second (rad/s).
     *
     * @param angularSpeed angular speed to be converted.
     * @return converted value.
     */
    private static double convertAngularSpeed(final AngularSpeed angularSpeed) {
<span class="fc" id="L1942">        return convertAngularSpeed(angularSpeed.getValue().doubleValue(), angularSpeed.getUnit());</span>
    }

    /**
     * Converts acceleration value and unit to meters per squared second (m/s^2).
     *
     * @param value value to be converted.
     * @param unit  unit of value to be converted.
     * @return converted value.
     */
    private static double convertAcceleration(final double value, final AccelerationUnit unit) {
<span class="fc" id="L1953">        return AccelerationConverter.convert(value, unit, AccelerationUnit.METERS_PER_SQUARED_SECOND);</span>
    }

    /**
     * Converts acceleration measurement to meters per squared second (m/s^2).
     *
     * @param acceleration acceleration to be converted.
     * @return converted value.
     */
    private static double convertAcceleration(final Acceleration acceleration) {
<span class="fc" id="L1963">        return convertAcceleration(acceleration.getValue().doubleValue(), acceleration.getUnit());</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>