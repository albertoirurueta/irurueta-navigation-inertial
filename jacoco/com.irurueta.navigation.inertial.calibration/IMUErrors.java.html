<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IMUErrors.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-navigation-inertial</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.navigation.inertial.calibration</a> &gt; <span class="el_source">IMUErrors.java</span></div><h1>IMUErrors.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2020 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.navigation.inertial.calibration;

import com.irurueta.algebra.Matrix;
import com.irurueta.algebra.WrongSizeException;
import com.irurueta.units.Acceleration;
import com.irurueta.units.AccelerationConverter;
import com.irurueta.units.AccelerationUnit;
import com.irurueta.units.AngularSpeed;
import com.irurueta.units.AngularSpeedConverter;
import com.irurueta.units.AngularSpeedUnit;

import java.io.Serial;
import java.io.Serializable;
import java.util.Arrays;
import java.util.Objects;

/**
 * Contains Inertial Measurement Unit (IMU) errors statistics obtained from
 * calibration.
 * This data can also be used to generate synthetic IMU data.
 * IMU errors are related to accelerometer and gyroscope calibration parameters.
 */
public class IMUErrors implements Serializable, Cloneable {

    /**
     * Number of components of accelerometer measures.
     */
    public static final int ACCELEROMETER_COMPONENTS = 3;

    /**
     * Number of components og gyro measures.
     */
    public static final int GYRO_COMPONENTS = 3;

    /**
     * Number of components minus one.
     */
    private static final int COMPONENTS_MINUS_ONE = 2;

    /**
     * Serialization version. This is used to ensure compatibility of deserialization of permanently stored serialized
     * instances.
     */
    @Serial
    private static final long serialVersionUID = 0L;

    /**
     * Accelerometer biases for each IMU axis expressed in meters per squared
     * second (m/s^2).
     * By default, it is assumed to be all zeros.
     */
<span class="fc" id="L67">    private double[] accelerometerBiases = new double[ACCELEROMETER_COMPONENTS];</span>

    /**
     * Gyro biases for each IMU axis expressed in radians per second (rad/s).
     * By default, it is assumed to be all zeros.
     */
<span class="fc" id="L73">    private double[] gyroBiases = new double[GYRO_COMPONENTS];</span>

    /**
     * Contains accelerometer scale factors and cross coupling errors.
     * This is the product of matrix Ta containing cross coupling errors and Ka
     * containing scaling factors.
     * So that:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz] = Ta*Ka
     *          [myx   sy   myz]
     *          [mzx   mzy  sz ]
     * &lt;/pre&gt;
     * Where:
     * &lt;pre&gt;
     *     Ka = [sx 0   0 ]
     *          [0  sy  0 ]
     *          [0  0   sz]
     * &lt;/pre&gt;
     * and
     * &lt;pre&gt;
     *     Ta = [1          -alphaXy    alphaXz ]
     *          [alphaYx    1           -alphaYz]
     *          [-alphaZx   alphaZy     1       ]
     * &lt;/pre&gt;
     * Hence:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz] = Ta*Ka =  [sx             -sy * alphaXy   sz * alphaXz ]
     *          [myx   sy   myz]            [sx * alphaYx   sy              -sz * alphaYz]
     *          [mzx   mzy  sz ]            [-sx * alphaZx  sy * alphaZy    sz           ]
     * &lt;/pre&gt;
     * This instance allows any 3x3 matrix however, typically alphaYx, alphaZx and alphaZy
     * are considered to be zero if the accelerometer z-axis is assumed to be the same
     * as the body z-axis. When this is assumed, myx = mzx = mzy = 0 and the Ma matrix
     * becomes upper diagonal:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz]
     *          [0     sy   myz]
     *          [0     0    sz ]
     * &lt;/pre&gt;
     * Values of this matrix are unit-less.
     * By default, it is the 3x3 zero matrix.
     */
    private Matrix accelerometerScaleFactorAndCrossCouplingErrors;

    /**
     * Contains gyro scale factors and cross coupling errors.
     * This is the product of matrix Tg containing cross coupling errors and Kg
     * containing scaling factors.
     * So that:
     * &lt;pre&gt;
     *     Mg = [sx    mxy  mxz] = Tg*Kg
     *          [myx   sy   myz]
     *          [mzx   mzy  sz ]
     * &lt;/pre&gt;
     * Where:
     * &lt;pre&gt;
     *     Kg = [sx 0   0 ]
     *          [0  sy  0 ]
     *          [0  0   sz]
     * &lt;/pre&gt;
     * and
     * &lt;pre&gt;
     *     Tg = [1          -gammaXy    gammaXz ]
     *          [gammaYx    1           -gammaYz]
     *          [-gammaZx   gammaZy     1       ]
     * &lt;/pre&gt;
     * Hence:
     * &lt;pre&gt;
     *     Mg = [sx    mxy  mxz] = Tg*Kg =  [sx             -sy * gammaXy   sz * gammaXz ]
     *          [myx   sy   myz]            [sx * gammaYx   sy              -sz * gammaYz]
     *          [mzx   mzy  sz ]            [-sx * gammaZx  sy * gammaZy    sz           ]
     * &lt;/pre&gt;
     * This instance allows any 3x3 matrix however, typically gammaYx, gammaZx and gammaZy
     * are considered to be zero if the accelerometer z-axis is assumed to be the same
     * as the body z-axis. When this is assumed, myx = mzx = mzy = 0 and the Ma matrix
     * becomes upper diagonal:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz]
     *          [0     sy   myz]
     *          [0     0    sz ]
     * &lt;/pre&gt;
     * Values of this matrix are unit-less.
     * By default, it is the 3x3 zero matrix.
     */
    private Matrix gyroScaleFactorAndCrossCouplingErrors;

    /**
     * 3x3 matrix containing cross biases introduced by the specific forces sensed
     * by the accelerometer.
     * Values of this matrix are expressed in (rad-sec/m).
     * By default, it is all zeros.
     */
    private Matrix gyroGDependentBiases;

    /**
     * Accelerometer noise root PSD expressed in (m * s^-1.5).
     * By default it is zero.
     */
    private double accelerometerNoiseRootPSD;

    /**
     * Gyro noise root PSD expressed in (rad * s^-0.5).
     * By default, it is zero.
     */
    private double gyroNoiseRootPSD;

    /**
     * Accelerometer quantization level expressed in meters per squared second (m/s^2).
     * By default, it is zero when no quantization is assumed.
     */
    private double accelerometerQuantizationLevel;

    /**
     * Gyro quantization level expressed in radians per second (rad/s).
     * By default, it is zero when no quantization is assumed.
     */
    private double gyroQuantizationLevel;

    /**
     * Constructor.
     */
<span class="fc" id="L194">    public IMUErrors() {</span>
        try {
<span class="fc" id="L196">            accelerometerScaleFactorAndCrossCouplingErrors = Matrix.identity(</span>
                    ACCELEROMETER_COMPONENTS, ACCELEROMETER_COMPONENTS);
<span class="fc" id="L198">            gyroScaleFactorAndCrossCouplingErrors = Matrix.identity(GYRO_COMPONENTS, GYRO_COMPONENTS);</span>
<span class="fc" id="L199">            gyroGDependentBiases = new Matrix(ACCELEROMETER_COMPONENTS, ACCELEROMETER_COMPONENTS);</span>
<span class="nc" id="L200">        } catch (final WrongSizeException ignore) {</span>
            // never happens
<span class="fc" id="L202">        }</span>
<span class="fc" id="L203">    }</span>

    /**
     * Constructor.
     *
     * @param accelerometerBiases                            accelerometer biases for each IMU axis expressed in meters
     *                                                       per squared second (m/s^2). Must have length 3.
     * @param gyroBiases                                     gyro biases for each IMU axis expressed in radians per
     *                                                       second (rad/s). Must have length 3.
     * @param accelerometerScaleFactorAndCrossCouplingErrors accelerometer scale factors and cross coupling errors.
     *                                                       Must be 3x3.
     * @param gyroScaleFactorAndCrossCouplingErrors          gyro scale factors and cross coupling errors. Must be 3x3.
     * @param accelerometerNoiseRootPSD                      accelerometer noise root PSD expressed in (m * s^-1.5).
     * @param gyroNoiseRootPSD                               gyro noise root PSD expressed in (rad * s^-0.5).
     * @throws IllegalArgumentException if any value is invalid.
     */
    public IMUErrors(final double[] accelerometerBiases, final double[] gyroBiases,
                     final Matrix accelerometerScaleFactorAndCrossCouplingErrors,
                     final Matrix gyroScaleFactorAndCrossCouplingErrors, final double accelerometerNoiseRootPSD,
                     final double gyroNoiseRootPSD) {
<span class="fc" id="L223">        this();</span>
<span class="fc" id="L224">        setAccelerometerBiases(accelerometerBiases);</span>
<span class="fc" id="L225">        setGyroBiases(gyroBiases);</span>
<span class="fc" id="L226">        setAccelerometerScaleFactorAndCrossCouplingErrors(accelerometerScaleFactorAndCrossCouplingErrors);</span>
<span class="fc" id="L227">        setGyroScaleFactorAndCrossCouplingErrors(gyroScaleFactorAndCrossCouplingErrors);</span>
<span class="fc" id="L228">        setAccelerometerNoiseRootPSD(accelerometerNoiseRootPSD);</span>
<span class="fc" id="L229">        setGyroNoiseRootPSD(gyroNoiseRootPSD);</span>
<span class="fc" id="L230">    }</span>

    /**
     * Constructor.
     *
     * @param accelerometerBiases                            accelerometer biases for each IMU axis expressed in meters
     *                                                       per squared second (m/s^2). Must be 3x1.
     * @param gyroBiases                                     gyro biases for each IMU axis expressed in radians per
     *                                                       second (rad/s). Must be 3x1.
     * @param accelerometerScaleFactorAndCrossCouplingErrors accelerometer scale factors and cross coupling errors.
     *                                                       Must be 3x3.
     * @param gyroScaleFactorAndCrossCouplingErrors          gyro scale factors and cross coupling errors. Must be 3x3.
     * @param accelerometerNoiseRootPSD                      accelerometer noise root PSD expressed in (m * s^-1.5).
     * @param gyroNoiseRootPSD                               gyro noise root PSD expressed in (rad * s^-0.5).
     * @throws IllegalArgumentException if any value is invalid.
     */
    public IMUErrors(final Matrix accelerometerBiases, final Matrix gyroBiases,
                     final Matrix accelerometerScaleFactorAndCrossCouplingErrors,
                     final Matrix gyroScaleFactorAndCrossCouplingErrors, final double accelerometerNoiseRootPSD,
                     final double gyroNoiseRootPSD) {
<span class="fc" id="L250">        this();</span>
<span class="fc" id="L251">        setAccelerometerBiases(accelerometerBiases);</span>
<span class="fc" id="L252">        setGyroBiases(gyroBiases);</span>
<span class="fc" id="L253">        setAccelerometerScaleFactorAndCrossCouplingErrors(accelerometerScaleFactorAndCrossCouplingErrors);</span>
<span class="fc" id="L254">        setGyroScaleFactorAndCrossCouplingErrors(gyroScaleFactorAndCrossCouplingErrors);</span>
<span class="fc" id="L255">        setAccelerometerNoiseRootPSD(accelerometerNoiseRootPSD);</span>
<span class="fc" id="L256">        setGyroNoiseRootPSD(gyroNoiseRootPSD);</span>
<span class="fc" id="L257">    }</span>

    /**
     * Constructor.
     *
     * @param accelerometerBiases                            accelerometer biases for each IMU axis. Must have length 3.
     * @param gyroBiases                                     gyro biases for each IMU axis. Must have length 3.
     * @param accelerometerScaleFactorAndCrossCouplingErrors accelerometer scale factors and cross coupling errors.
     *                                                       Must be 3x3.
     * @param gyroScaleFactorAndCrossCouplingErrors          gyro scale factors and cross coupling errors. Must be 3x3.
     * @param accelerometerNoiseRootPSD                      accelerometer noise root PSD expressed in (m * s^-1.5).
     * @param gyroNoiseRootPSD                               gyro noise root PSD expressed in (rad * s^-0.5).
     * @throws IllegalArgumentException if any value is invalid.
     */
    public IMUErrors(final Acceleration[] accelerometerBiases, final AngularSpeed[] gyroBiases,
                     final Matrix accelerometerScaleFactorAndCrossCouplingErrors,
                     final Matrix gyroScaleFactorAndCrossCouplingErrors, final double accelerometerNoiseRootPSD,
                     final double gyroNoiseRootPSD) {
<span class="fc" id="L275">        this();</span>
<span class="fc" id="L276">        setAccelerometerBiases(accelerometerBiases);</span>
<span class="fc" id="L277">        setGyroBiases(gyroBiases);</span>
<span class="fc" id="L278">        setAccelerometerScaleFactorAndCrossCouplingErrors(accelerometerScaleFactorAndCrossCouplingErrors);</span>
<span class="fc" id="L279">        setGyroScaleFactorAndCrossCouplingErrors(gyroScaleFactorAndCrossCouplingErrors);</span>
<span class="fc" id="L280">        setAccelerometerNoiseRootPSD(accelerometerNoiseRootPSD);</span>
<span class="fc" id="L281">        setGyroNoiseRootPSD(gyroNoiseRootPSD);</span>
<span class="fc" id="L282">    }</span>

    /**
     * Constructor.
     *
     * @param accelerometerBiases                            accelerometer biases for each IMU axis expressed in meters
     *                                                       per squared second (m/s^2). Must have length 3.
     * @param gyroBiases                                     gyro biases for each IMU axis expressed in radians per
     *                                                       second (rad/s). Must have length 3.
     * @param accelerometerScaleFactorAndCrossCouplingErrors accelerometer scale factors and cross coupling errors.
     *                                                       Must be 3x3.
     * @param gyroScaleFactorAndCrossCouplingErrors          gyro scale factors and cross coupling errors. Must be 3x3.
     * @param gyroGDependentBiases                           Cross biases introduced by the specific forces sensed by
     *                                                       the accelerometer expressed in (rad-sec/m). Must be 3x3.
     * @param accelerometerNoiseRootPSD                      accelerometer noise root PSD expressed in (m * s^-1.5).
     * @param gyroNoiseRootPSD                               gyro noise root PSD expressed in (rad * s^-0.5).
     * @param accelerometerQuantizationLevel                 accelerometer quantization level expressed in meters per
     *                                                       squared second (m/s^2).
     * @param gyroQuantizationLevel                          gyro quantization level expressed in radians per second
     *                                                       (rad/s).
     * @throws IllegalArgumentException if any value is invalid.
     */
    public IMUErrors(final double[] accelerometerBiases, final double[] gyroBiases,
                     final Matrix accelerometerScaleFactorAndCrossCouplingErrors,
                     final Matrix gyroScaleFactorAndCrossCouplingErrors, final Matrix gyroGDependentBiases,
                     final double accelerometerNoiseRootPSD, final double gyroNoiseRootPSD,
                     final double accelerometerQuantizationLevel, final double gyroQuantizationLevel) {
<span class="fc" id="L309">        this();</span>
<span class="fc" id="L310">        setAccelerometerBiases(accelerometerBiases);</span>
<span class="fc" id="L311">        setGyroBiases(gyroBiases);</span>
<span class="fc" id="L312">        setAccelerometerScaleFactorAndCrossCouplingErrors(accelerometerScaleFactorAndCrossCouplingErrors);</span>
<span class="fc" id="L313">        setGyroScaleFactorAndCrossCouplingErrors(gyroScaleFactorAndCrossCouplingErrors);</span>
<span class="fc" id="L314">        setGyroGDependentBiases(gyroGDependentBiases);</span>
<span class="fc" id="L315">        setAccelerometerNoiseRootPSD(accelerometerNoiseRootPSD);</span>
<span class="fc" id="L316">        setGyroNoiseRootPSD(gyroNoiseRootPSD);</span>
<span class="fc" id="L317">        setAccelerometerQuantizationLevel(accelerometerQuantizationLevel);</span>
<span class="fc" id="L318">        setGyroQuantizationLevel(gyroQuantizationLevel);</span>
<span class="fc" id="L319">    }</span>

    /**
     * Constructor.
     *
     * @param accelerometerBiases                            accelerometer biases for each IMU axis expressed in meters
     *                                                       per squared second (m/s^2). Must be 3x1.
     * @param gyroBiases                                     gyro biases for each IMU axis expressed in radians per
     *                                                       second (rad/s). Must be 3x1.
     * @param accelerometerScaleFactorAndCrossCouplingErrors accelerometer scale factors and cross coupling errors.
     *                                                       Must be 3x3.
     * @param gyroScaleFactorAndCrossCouplingErrors          gyro scale factors and cross coupling errors. Must be 3x3.
     * @param gyroGDependentBiases                           Cross biases introduced by the specific forces sensed by
     *                                                       the accelerometer expressed in (rad-sec/m). Must be 3x3.
     * @param accelerometerNoiseRootPSD                      accelerometer noise root PSD expressed in (m * s^-1.5).
     * @param gyroNoiseRootPSD                               gyro noise root PSD expressed in (rad * s^-0.5).
     * @param accelerometerQuantizationLevel                 accelerometer quantization level expressed in meters per
     *                                                       squared second (m/s^2).
     * @param gyroQuantizationLevel                          gyro quantization level expressed in radians per second
     *                                                       (rad/s).
     * @throws IllegalArgumentException if any value is invalid.
     */
    public IMUErrors(final Matrix accelerometerBiases, final Matrix gyroBiases,
                     final Matrix accelerometerScaleFactorAndCrossCouplingErrors,
                     final Matrix gyroScaleFactorAndCrossCouplingErrors, final Matrix gyroGDependentBiases,
                     final double accelerometerNoiseRootPSD, final double gyroNoiseRootPSD,
                     final double accelerometerQuantizationLevel, final double gyroQuantizationLevel) {
<span class="fc" id="L346">        this();</span>
<span class="fc" id="L347">        setAccelerometerBiases(accelerometerBiases);</span>
<span class="fc" id="L348">        setGyroBiases(gyroBiases);</span>
<span class="fc" id="L349">        setAccelerometerScaleFactorAndCrossCouplingErrors(accelerometerScaleFactorAndCrossCouplingErrors);</span>
<span class="fc" id="L350">        setGyroScaleFactorAndCrossCouplingErrors(gyroScaleFactorAndCrossCouplingErrors);</span>
<span class="fc" id="L351">        setGyroGDependentBiases(gyroGDependentBiases);</span>
<span class="fc" id="L352">        setAccelerometerNoiseRootPSD(accelerometerNoiseRootPSD);</span>
<span class="fc" id="L353">        setGyroNoiseRootPSD(gyroNoiseRootPSD);</span>
<span class="fc" id="L354">        setAccelerometerQuantizationLevel(accelerometerQuantizationLevel);</span>
<span class="fc" id="L355">        setGyroQuantizationLevel(gyroQuantizationLevel);</span>
<span class="fc" id="L356">    }</span>

    /**
     * Constructor.
     *
     * @param accelerometerBiases                            accelerometer biases for each IMU axis. Must have length 3.
     * @param gyroBiases                                     gyro biases for each IMU axis. Must have length 3.
     * @param accelerometerScaleFactorAndCrossCouplingErrors accelerometer scale factors and cross coupling errors.
     *                                                       Must be 3x3.
     * @param gyroScaleFactorAndCrossCouplingErrors          gyro scale factors and cross coupling errors. Must be 3x3.
     * @param gyroGDependentBiases                           Cross biases introduced by the specific forces sensed by
     *                                                       the accelerometer expressed in (rad-sec/m). Must be 3x3.
     * @param accelerometerNoiseRootPSD                      accelerometer noise root PSD expressed in (m * s^-1.5).
     * @param gyroNoiseRootPSD                               gyro noise root PSD expressed in (rad * s^-0.5).
     * @param accelerometerQuantizationLevel                 accelerometer quantization level.
     * @param gyroQuantizationLevel                          gyro quantization level.
     * @throws IllegalArgumentException if any value is invalid.
     */
    public IMUErrors(final Acceleration[] accelerometerBiases, final AngularSpeed[] gyroBiases,
                     final Matrix accelerometerScaleFactorAndCrossCouplingErrors,
                     final Matrix gyroScaleFactorAndCrossCouplingErrors, final Matrix gyroGDependentBiases,
                     final double accelerometerNoiseRootPSD, final double gyroNoiseRootPSD,
                     final Acceleration accelerometerQuantizationLevel,
                     final AngularSpeed gyroQuantizationLevel) {
<span class="fc" id="L380">        this();</span>
<span class="fc" id="L381">        setAccelerometerBiases(accelerometerBiases);</span>
<span class="fc" id="L382">        setGyroBiases(gyroBiases);</span>
<span class="fc" id="L383">        setAccelerometerScaleFactorAndCrossCouplingErrors(accelerometerScaleFactorAndCrossCouplingErrors);</span>
<span class="fc" id="L384">        setGyroScaleFactorAndCrossCouplingErrors(gyroScaleFactorAndCrossCouplingErrors);</span>
<span class="fc" id="L385">        setGyroGDependentBiases(gyroGDependentBiases);</span>
<span class="fc" id="L386">        setAccelerometerNoiseRootPSD(accelerometerNoiseRootPSD);</span>
<span class="fc" id="L387">        setGyroNoiseRootPSD(gyroNoiseRootPSD);</span>
<span class="fc" id="L388">        setAccelerometerQuantizationLevel(accelerometerQuantizationLevel);</span>
<span class="fc" id="L389">        setGyroQuantizationLevel(gyroQuantizationLevel);</span>
<span class="fc" id="L390">    }</span>

    /**
     * Constructor.
     *
     * @param input instance to copy data from.
     */
    @SuppressWarnings(&quot;CopyConstructorMissesField&quot;)
    public IMUErrors(final IMUErrors input) {
<span class="fc" id="L399">        this();</span>
<span class="fc" id="L400">        copyFrom(input);</span>
<span class="fc" id="L401">    }</span>

    /**
     * Gets accelerometer biases for each IMU axis expressed in meters per squared
     * second (m/s^2).
     * By default, it is assumed to be all zeros.
     *
     * @return accelerometer biases for each IMU axis.
     */
    public double[] getAccelerometerBiases() {
<span class="fc" id="L411">        final var result = new double[ACCELEROMETER_COMPONENTS];</span>
<span class="fc" id="L412">        getAccelerometerBiases(result);</span>
<span class="fc" id="L413">        return result;</span>
    }

    /**
     * Gets accelerometer biases for each IMU axis expressed in meters per squared
     * second (m/s^2).
     * By default, it is assumed to be all zeros.
     *
     * @param result instance where data will be stored.
     * @throws IllegalArgumentException if provided array does not have length 3.
     */
    public void getAccelerometerBiases(final double[] result) {
<span class="fc bfc" id="L425" title="All 2 branches covered.">        if (result.length != ACCELEROMETER_COMPONENTS) {</span>
<span class="fc" id="L426">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L429">        System.arraycopy(accelerometerBiases, 0, result, 0, ACCELEROMETER_COMPONENTS);</span>
<span class="fc" id="L430">    }</span>

    /**
     * Sets accelerometer biases for each IMU axis expressed in meters per squared
     * second (m/s^2).
     *
     * @param accelerometerBiases accelerometer biases for each IMU axis.
     * @throws IllegalArgumentException if provided array does not have length 3.
     */
    public void setAccelerometerBiases(final double[] accelerometerBiases) {
<span class="fc bfc" id="L440" title="All 2 branches covered.">        if (accelerometerBiases.length != ACCELEROMETER_COMPONENTS) {</span>
<span class="fc" id="L441">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L444">        this.accelerometerBiases = accelerometerBiases;</span>
<span class="fc" id="L445">    }</span>

    /**
     * Gets accelerometer biases for each IMU axis expressed in meters per squared
     * second (m/s^2) as a column matrix.
     * By default, it is assumed to be all zeros.
     *
     * @return 3x1 column matrix containing accelerometer biases for each IMU axis.
     */
    public Matrix getAccelerometerBiasesAsMatrix() {
<span class="fc" id="L455">        return Matrix.newFromArray(accelerometerBiases);</span>
    }

    /**
     * Gets accelerometer biases for each IMU axis expressed in meters per squared
     * second (m/s^2) as a column matrix.
     * By default, it is assumed to be all zeros.
     *
     * @param result instance where data will be stored.
     * @throws IllegalArgumentException if provided result matrix is not 3x1.
     */
    public void getAccelerometerBiasesAsMatrix(final Matrix result) {
<span class="fc" id="L467">        result.setSubmatrix(0, 0, COMPONENTS_MINUS_ONE, 0,</span>
                accelerometerBiases);
<span class="fc" id="L469">    }</span>

    /**
     * Sets accelerometer biases for each IMU axis expressed in meters per squared
     * second (m/s^2) from a 3x1 column matrix.
     *
     * @param accelerometerBiases 3x1 column matrix containing values to be set.
     * @throws IllegalArgumentException if provided matrix is not 3x1.
     */
    public void setAccelerometerBiases(final Matrix accelerometerBiases) {
<span class="fc bfc" id="L479" title="All 4 branches covered.">        if (accelerometerBiases.getRows() != ACCELEROMETER_COMPONENTS || accelerometerBiases.getColumns() != 1) {</span>
<span class="fc" id="L480">            throw new IllegalArgumentException();</span>
        }

        try {
<span class="fc" id="L484">            accelerometerBiases.getSubmatrixAsArray(0, 0,</span>
                    COMPONENTS_MINUS_ONE, 0, this.accelerometerBiases);
<span class="nc" id="L486">        } catch (final WrongSizeException ignore) {</span>
            // never happens
<span class="fc" id="L488">        }</span>
<span class="fc" id="L489">    }</span>

    /**
     * Gets accelerometer biases for each IMU axis.
     * By default, it is assumed to be all zeros.
     *
     * @return accelerometer biases for each IMU axis.
     */
    public Acceleration[] getAccelerometerBiasesAsAcceleration() {
<span class="fc" id="L498">        final var result = new Acceleration[ACCELEROMETER_COMPONENTS];</span>
<span class="fc" id="L499">        getAccelerometerBiasesAsAcceleration(result);</span>
<span class="fc" id="L500">        return result;</span>
    }

    /**
     * Gets accelerometer biases for each IMU axis.
     * By default, it is assumed to be all zeros.
     *
     * @param result instance where data will be copied to.
     * @throws IllegalArgumentException if provided array does not have length 3.
     */
    public void getAccelerometerBiasesAsAcceleration(final Acceleration[] result) {
<span class="fc bfc" id="L511" title="All 2 branches covered.">        if (result.length != ACCELEROMETER_COMPONENTS) {</span>
<span class="fc" id="L512">            throw new IllegalArgumentException();</span>
        }

<span class="fc bfc" id="L515" title="All 2 branches covered.">        for (var i = 0; i &lt; ACCELEROMETER_COMPONENTS; i++) {</span>
<span class="fc" id="L516">            final var a = result[i];</span>
<span class="fc bfc" id="L517" title="All 2 branches covered.">            if (a == null) {</span>
<span class="fc" id="L518">                result[i] = new Acceleration(accelerometerBiases[i], AccelerationUnit.METERS_PER_SQUARED_SECOND);</span>
            } else {
<span class="fc" id="L520">                a.setValue(accelerometerBiases[i]);</span>
<span class="fc" id="L521">                a.setUnit(AccelerationUnit.METERS_PER_SQUARED_SECOND);</span>
            }
        }
<span class="fc" id="L524">    }</span>

    /**
     * Sets accelerometer biases for each IMU axis.
     *
     * @param accelerometerBiases accelerometer biases to be set.
     * @throws IllegalArgumentException if provided array does not have length 3.
     */
    public void setAccelerometerBiases(final Acceleration[] accelerometerBiases) {
<span class="fc bfc" id="L533" title="All 2 branches covered.">        if (accelerometerBiases.length != ACCELEROMETER_COMPONENTS) {</span>
<span class="fc" id="L534">            throw new IllegalArgumentException();</span>
        }

<span class="fc bfc" id="L537" title="All 2 branches covered.">        for (var i = 0; i &lt; ACCELEROMETER_COMPONENTS; i++) {</span>
<span class="fc" id="L538">            this.accelerometerBiases[i] = convertAcceleration(accelerometerBiases[i]);</span>
        }
<span class="fc" id="L540">    }</span>

    /**
     * Gets gyro biases for each IMU axis expressed in radians per second (rad/s).
     * By default, it is assumed to be all zeros.
     *
     * @return gyro biases for each IMU axis.
     */
    public double[] getGyroBiases() {
<span class="fc" id="L549">        final var result = new double[GYRO_COMPONENTS];</span>
<span class="fc" id="L550">        getGyroBiases(result);</span>
<span class="fc" id="L551">        return result;</span>
    }

    /**
     * Gets gyro biases for each IMU axis expressed in radians per second (rad/s).
     * By default, it is assumed to be all zeros.
     *
     * @param result instance where data will be stored.
     * @throws IllegalArgumentException if provided array does not have length 3.
     */
    public void getGyroBiases(final double[] result) {
<span class="fc bfc" id="L562" title="All 2 branches covered.">        if (result.length != GYRO_COMPONENTS) {</span>
<span class="fc" id="L563">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L566">        System.arraycopy(gyroBiases, 0, result, 0, GYRO_COMPONENTS);</span>
<span class="fc" id="L567">    }</span>

    /**
     * Sets gyro biases for each IMU axis expressed in radians per second (rad/s).
     *
     * @param gyroBiases gyro biases for each IMU axis.
     * @throws IllegalArgumentException if provided array does not have length 3.
     */
    public void setGyroBiases(final double[] gyroBiases) {
<span class="fc bfc" id="L576" title="All 2 branches covered.">        if (gyroBiases.length != GYRO_COMPONENTS) {</span>
<span class="fc" id="L577">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L580">        this.gyroBiases = gyroBiases;</span>
<span class="fc" id="L581">    }</span>

    /**
     * Gets gyro biases for each IMU axis expressed in radians per second (rad/s)
     * as a column matrix.
     * By default, it is assumed to be all zeros.
     *
     * @return 3x1 column matrix containing gyro biases for each IMU axis.
     */
    public Matrix getGyroBiasesAsMatrix() {
<span class="fc" id="L591">        return Matrix.newFromArray(gyroBiases);</span>
    }

    /**
     * Gets gyro biases for each IMU axis expressed in radians per second (rad/s)
     * as a column matrix.
     * By default, it is assumed to be all zeros.
     *
     * @param result instance where data will be stored.
     * @throws IllegalArgumentException if provided result matrix is not 3x1.
     */
    public void getGyroBiasesAsMatrix(final Matrix result) {
<span class="fc" id="L603">        result.setSubmatrix(0, 0, COMPONENTS_MINUS_ONE, 0, gyroBiases);</span>
<span class="fc" id="L604">    }</span>

    /**
     * Sets gyro biases for each IMU axis expressed in radians per second (rad/s)
     * from a 3x1 column matrix.
     *
     * @param gyroBiases 3x1 column matrix containing values to be set.
     * @throws IllegalArgumentException if provided matrix is not 3x1.
     */
    public void setGyroBiases(final Matrix gyroBiases) {
<span class="fc bfc" id="L614" title="All 4 branches covered.">        if (gyroBiases.getRows() != GYRO_COMPONENTS || gyroBiases.getColumns() != 1) {</span>
<span class="fc" id="L615">            throw new IllegalArgumentException();</span>
        }

        try {
<span class="fc" id="L619">            gyroBiases.getSubmatrixAsArray(0, 0, COMPONENTS_MINUS_ONE, 0,</span>
                    this.gyroBiases);
<span class="nc" id="L621">        } catch (final WrongSizeException ignore) {</span>
            // never happens
<span class="fc" id="L623">        }</span>
<span class="fc" id="L624">    }</span>

    /**
     * Gets gyro biases for each IMU axis.
     * By default, it is assumed to be all zeros.
     *
     * @return gyro biases for each IMU axis.
     */
    public AngularSpeed[] getGyroBiasesAsAngularSpeed() {
<span class="fc" id="L633">        final var result = new AngularSpeed[GYRO_COMPONENTS];</span>
<span class="fc" id="L634">        getGyroBiasesAsAngularSpeed(result);</span>
<span class="fc" id="L635">        return result;</span>
    }

    /**
     * Gets gyro biases for each IMU axis.
     * By default, it is assumed to be all zeros.
     *
     * @param result instance where data will be copied to.
     * @throws IllegalArgumentException if provided array does not have length 3.
     */
    public void getGyroBiasesAsAngularSpeed(final AngularSpeed[] result) {
<span class="fc bfc" id="L646" title="All 2 branches covered.">        if (result.length != GYRO_COMPONENTS) {</span>
<span class="fc" id="L647">            throw new IllegalArgumentException();</span>
        }

<span class="fc bfc" id="L650" title="All 2 branches covered.">        for (var i = 0; i &lt; GYRO_COMPONENTS; i++) {</span>
<span class="fc" id="L651">            final var as = result[i];</span>
<span class="fc bfc" id="L652" title="All 2 branches covered.">            if (as == null) {</span>
<span class="fc" id="L653">                result[i] = new AngularSpeed(gyroBiases[i], AngularSpeedUnit.RADIANS_PER_SECOND);</span>
            } else {
<span class="fc" id="L655">                as.setValue(gyroBiases[i]);</span>
<span class="fc" id="L656">                as.setUnit(AngularSpeedUnit.RADIANS_PER_SECOND);</span>
            }
        }
<span class="fc" id="L659">    }</span>

    /**
     * Sets gyro biases for each IMU axis.
     *
     * @param gyroBiases gyro biases to be set.
     * @throws IllegalArgumentException if provided array does not have length 3.
     */
    public void setGyroBiases(final AngularSpeed[] gyroBiases) {
<span class="fc bfc" id="L668" title="All 2 branches covered.">        if (gyroBiases.length != GYRO_COMPONENTS) {</span>
<span class="fc" id="L669">            throw new IllegalArgumentException();</span>
        }

<span class="fc bfc" id="L672" title="All 2 branches covered.">        for (int i = 0; i &lt; GYRO_COMPONENTS; i++) {</span>
<span class="fc" id="L673">            this.gyroBiases[i] = convertAngularSpeed(gyroBiases[i]);</span>
        }
<span class="fc" id="L675">    }</span>

    /**
     * Gets accelerometer scale factors and cross coupling errors.
     * This is the product of matrix Ta containing cross coupling errors and Ka
     * containing scaling factors.
     * So that:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz] = Ta*Ka
     *          [myx   sy   myz]
     *          [mzx   mzy  sz ]
     * &lt;/pre&gt;
     * Where:
     * &lt;pre&gt;
     *     Ka = [sx 0   0 ]
     *          [0  sy  0 ]
     *          [0  0   sz]
     * &lt;/pre&gt;
     * and
     * &lt;pre&gt;
     *     Ta = [1          -alphaXy    alphaXz ]
     *          [alphaYx    1           -alphaYz]
     *          [-alphaZx   alphaZy     1       ]
     * &lt;/pre&gt;
     * Hence:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz] = Ta*Ka =  [sx             -sy * alphaXy   sz * alphaXz ]
     *          [myx   sy   myz]            [sx * alphaYx   sy              -sz * alphaYz]
     *          [mzx   mzy  sz ]            [-sx * alphaZx  sy * alphaZy    sz           ]
     * &lt;/pre&gt;
     * This instance allows any 3x3 matrix however, typically alphaYx, alphaZx and alphaZy
     * are considered to be zero if the accelerometer z-axis is assumed to be the same
     * as the body z-axis. When this is assumed, myx = mzx = mzy = 0 and the Ma matrix
     * becomes upper diagonal:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz]
     *          [0     sy   myz]
     *          [0     0    sz ]
     * &lt;/pre&gt;
     * Values of this matrix are unit-less.
     * By default, it is the 3x3 identity matrix.
     *
     * @return accelerometer scale factors and cross coupling errors.
     */
    public Matrix getAccelerometerScaleFactorAndCrossCouplingErrors() {
<span class="fc" id="L720">        return new Matrix(accelerometerScaleFactorAndCrossCouplingErrors);</span>
    }

    /**
     * Gets accelerometer scale factors and cross coupling errors.
     * This is the product of matrix Ta containing cross coupling errors and Ka
     * containing scaling factors.
     * So that:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz] = Ta*Ka
     *          [myx   sy   myz]
     *          [mzx   mzy  sz ]
     * &lt;/pre&gt;
     * Where:
     * &lt;pre&gt;
     *     Ka = [sx 0   0 ]
     *          [0  sy  0 ]
     *          [0  0   sz]
     * &lt;/pre&gt;
     * and
     * &lt;pre&gt;
     *     Ta = [1          -alphaXy    alphaXz ]
     *          [alphaYx    1           -alphaYz]
     *          [-alphaZx   alphaZy     1       ]
     * &lt;/pre&gt;
     * Hence:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz] = Ta*Ka =  [sx             -sy * alphaXy   sz * alphaXz ]
     *          [myx   sy   myz]            [sx * alphaYx   sy              -sz * alphaYz]
     *          [mzx   mzy  sz ]            [-sx * alphaZx  sy * alphaZy    sz           ]
     * &lt;/pre&gt;
     * This instance allows any 3x3 matrix however, typically alphaYx, alphaZx and alphaZy
     * are considered to be zero if the accelerometer z-axis is assumed to be the same
     * as the body z-axis. When this is assumed, myx = mzx = mzy = 0 and the Ma matrix
     * becomes upper diagonal:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz]
     *          [0     sy   myz]
     *          [0     0    sz ]
     * &lt;/pre&gt;
     * Values of this matrix are unit-less.
     * By default, it is the 3x3 identity matrix.
     *
     * @param result instance where data of scale factor and cross coupling matrix will
     *               be copied to. If needed, result instance will be resized.
     */
    public void getAccelerometerScaleFactorAndCrossCouplingErrors(final Matrix result) {
<span class="fc" id="L767">        result.copyFrom(accelerometerScaleFactorAndCrossCouplingErrors);</span>
<span class="fc" id="L768">    }</span>

    /**
     * Sets accelerometer scale factors and cross coupling errors.
     * This is the product of matrix Ta containing cross coupling errors and Ka
     * containing scaling factors.
     * So that:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz] = Ta*Ka
     *          [myx   sy   myz]
     *          [mzx   mzy  sz ]
     * &lt;/pre&gt;
     * Where:
     * &lt;pre&gt;
     *     Ka = [sx 0   0 ]
     *          [0  sy  0 ]
     *          [0  0   sz]
     * &lt;/pre&gt;
     * and
     * &lt;pre&gt;
     *     Ta = [1          -alphaXy    alphaXz ]
     *          [alphaYx    1           -alphaYz]
     *          [-alphaZx   alphaZy     1       ]
     * &lt;/pre&gt;
     * Hence:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz] = Ta*Ka =  [sx             -sy * alphaXy   sz * alphaXz ]
     *          [myx   sy   myz]            [sx * alphaYx   sy              -sz * alphaYz]
     *          [mzx   mzy  sz ]            [-sx * alphaZx  sy * alphaZy    sz           ]
     * &lt;/pre&gt;
     * This instance allows any 3x3 matrix however, typically alphaYx, alphaZx and alphaZy
     * are considered to be zero if the accelerometer z-axis is assumed to be the same
     * as the body z-axis. When this is assumed, myx = mzx = mzy = 0 and the Ma matrix
     * becomes upper diagonal:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz]
     *          [0     sy   myz]
     *          [0     0    sz ]
     * &lt;/pre&gt;
     * Values of this matrix are unit-less.
     *
     * @param accelerometerScaleFactorAndCrossCouplingErrors scale factors and cross coupling
     *                                                       matrix to be set.
     * @throws IllegalArgumentException if provided matrix is not 3x3.
     */
    public void setAccelerometerScaleFactorAndCrossCouplingErrors(
            final Matrix accelerometerScaleFactorAndCrossCouplingErrors) {
<span class="fc bfc" id="L815" title="All 2 branches covered.">        if (accelerometerScaleFactorAndCrossCouplingErrors.getRows() != ACCELEROMETER_COMPONENTS</span>
<span class="fc bfc" id="L816" title="All 2 branches covered.">                || accelerometerScaleFactorAndCrossCouplingErrors.getColumns() != ACCELEROMETER_COMPONENTS) {</span>
<span class="fc" id="L817">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L820">        this.accelerometerScaleFactorAndCrossCouplingErrors.copyFrom(accelerometerScaleFactorAndCrossCouplingErrors);</span>
<span class="fc" id="L821">    }</span>

    /**
     * Gets gyro scale factors and cross coupling errors.
     * This is the product of matrix Tg containing cross coupling errors and Kg
     * containing scaling factors.
     * So that:
     * &lt;pre&gt;
     *     Mg = [sx    mxy  mxz] = Tg*Kg
     *          [myx   sy   myz]
     *          [mzx   mzy  sz ]
     * &lt;/pre&gt;
     * Where:
     * &lt;pre&gt;
     *     Kg = [sx 0   0 ]
     *          [0  sy  0 ]
     *          [0  0   sz]
     * &lt;/pre&gt;
     * and
     * &lt;pre&gt;
     *     Tg = [1          -gammaXy    gammaXz ]
     *          [gammaYx    1           -gammaYz]
     *          [-gammaZx   gammaZy     1       ]
     * &lt;/pre&gt;
     * Hence:
     * &lt;pre&gt;
     *     Mg = [sx    mxy  mxz] = Tg*Kg =  [sx             -sy * gammaXy   sz * gammaXz ]
     *          [myx   sy   myz]            [sx * gammaYx   sy              -sz * gammaYz]
     *          [mzx   mzy  sz ]            [-sx * gammaZx  sy * gammaZy    sz           ]
     * &lt;/pre&gt;
     * This instance allows any 3x3 matrix however, typically gammaYx, gammaZx and gammaZy
     * are considered to be zero if the accelerometer z-axis is assumed to be the same
     * as the body z-axis. When this is assumed, myx = mzx = mzy = 0 and the Ma matrix
     * becomes upper diagonal:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz]
     *          [0     sy   myz]
     *          [0     0    sz ]
     * &lt;/pre&gt;
     * Values of this matrix are unit-less.
     * By default, it is the 3x3 identity matrix.
     *
     * @return gyro scale factors and cross coupling errors.
     */
    public Matrix getGyroScaleFactorAndCrossCouplingErrors() {
<span class="fc" id="L866">        return new Matrix(gyroScaleFactorAndCrossCouplingErrors);</span>
    }

    /**
     * Gets gyro scale factors and cross coupling errors.
     * This is the product of matrix Tg containing cross coupling errors and Kg
     * containing scaling factors.
     * So that:
     * &lt;pre&gt;
     *     Mg = [sx    mxy  mxz] = Tg*Kg
     *          [myx   sy   myz]
     *          [mzx   mzy  sz ]
     * &lt;/pre&gt;
     * Where:
     * &lt;pre&gt;
     *     Kg = [sx 0   0 ]
     *          [0  sy  0 ]
     *          [0  0   sz]
     * &lt;/pre&gt;
     * and
     * &lt;pre&gt;
     *     Tg = [1          -gammaXy    gammaXz ]
     *          [gammaYx    1           -gammaYz]
     *          [-gammaZx   gammaZy     1       ]
     * &lt;/pre&gt;
     * Hence:
     * &lt;pre&gt;
     *     Mg = [sx    mxy  mxz] = Tg*Kg =  [sx             -sy * gammaXy   sz * gammaXz ]
     *          [myx   sy   myz]            [sx * gammaYx   sy              -sz * gammaYz]
     *          [mzx   mzy  sz ]            [-sx * gammaZx  sy * gammaZy    sz           ]
     * &lt;/pre&gt;
     * This instance allows any 3x3 matrix however, typically gammaYx, gammaZx and gammaZy
     * are considered to be zero if the accelerometer z-axis is assumed to be the same
     * as the body z-axis. When this is assumed, myx = mzx = mzy = 0 and the Ma matrix
     * becomes upper diagonal:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz]
     *          [0     sy   myz]
     *          [0     0    sz ]
     * &lt;/pre&gt;
     * Values of this matrix are unit-less.
     * By default, it is the 3x3 identity matrix.
     *
     * @param result instance where data of scale factor and cross coupling matrix will
     *               be copied to. If needed, result instance will be resized.
     */
    public void getGyroScaleFactorAndCrossCouplingErrors(final Matrix result) {
<span class="fc" id="L913">        result.copyFrom(gyroScaleFactorAndCrossCouplingErrors);</span>
<span class="fc" id="L914">    }</span>

    /**
     * Sets gyro scale factors and cross coupling errors.
     * This is the product of matrix Tg containing cross coupling errors and Kg
     * containing scaling factors.
     * So that:
     * &lt;pre&gt;
     *     Mg = [sx    mxy  mxz] = Tg*Kg
     *          [myx   sy   myz]
     *          [mzx   mzy  sz ]
     * &lt;/pre&gt;
     * Where:
     * &lt;pre&gt;
     *     Kg = [sx 0   0 ]
     *          [0  sy  0 ]
     *          [0  0   sz]
     * &lt;/pre&gt;
     * and
     * &lt;pre&gt;
     *     Tg = [1          -gammaXy    gammaXz ]
     *          [gammaYx    1           -gammaYz]
     *          [-gammaZx   gammaZy     1       ]
     * &lt;/pre&gt;
     * Hence:
     * &lt;pre&gt;
     *     Mg = [sx    mxy  mxz] = Tg*Kg =  [sx             -sy * gammaXy   sz * gammaXz ]
     *          [myx   sy   myz]            [sx * gammaYx   sy              -sz * gammaYz]
     *          [mzx   mzy  sz ]            [-sx * gammaZx  sy * gammaZy    sz           ]
     * &lt;/pre&gt;
     * This instance allows any 3x3 matrix however, typically gammaYx, gammaZx and gammaZy
     * are considered to be zero if the accelerometer z-axis is assumed to be the same
     * as the body z-axis. When this is assumed, myx = mzx = mzy = 0 and the Ma matrix
     * becomes upper diagonal:
     * &lt;pre&gt;
     *     Ma = [sx    mxy  mxz]
     *          [0     sy   myz]
     *          [0     0    sz ]
     * &lt;/pre&gt;
     * Values of this matrix are unit-less.
     *
     * @param gyroScaleFactorAndCrossCouplingErrors scale factors and cross coupling
     *                                              matrix to be set.
     * @throws IllegalArgumentException if provided matrix is not 3x3.
     */
    public void setGyroScaleFactorAndCrossCouplingErrors(final Matrix gyroScaleFactorAndCrossCouplingErrors) {
<span class="fc bfc" id="L960" title="All 2 branches covered.">        if (gyroScaleFactorAndCrossCouplingErrors.getRows() != GYRO_COMPONENTS</span>
<span class="fc bfc" id="L961" title="All 2 branches covered.">                || gyroScaleFactorAndCrossCouplingErrors.getColumns() != GYRO_COMPONENTS) {</span>
<span class="fc" id="L962">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L965">        this.gyroScaleFactorAndCrossCouplingErrors.copyFrom(gyroScaleFactorAndCrossCouplingErrors);</span>
<span class="fc" id="L966">    }</span>

    /**
     * Gets 3x3 matrix containing cross biases introduced by the specific forces
     * sensed by the accelerometer.
     * Values of this matrix are expressed in (rad-sec/m).
     * By default, it is all zeros.
     *
     * @return cross biases introduced by the specific forces sensed by the
     * accelerometer.
     */
    public Matrix getGyroGDependentBiases() {
<span class="fc" id="L978">        return new Matrix(gyroGDependentBiases);</span>
    }

    /**
     * Gets 3x3 matrix containing cross biases introduced by the specific forces
     * sensed by the accelerometer.
     * Values of this matrix are expressed in (rad-sec/m).
     * By default, it is all zeros.
     *
     * @param result instance where data will be stored. If needed, result instance
     *               will be resized.
     */
    public void getGyroGDependentBiases(final Matrix result) {
<span class="fc" id="L991">        result.copyFrom(gyroGDependentBiases);</span>
<span class="fc" id="L992">    }</span>

    /**
     * Sets 3x3 matrix containing cross biases introduced by the specific forces
     * sensed by the accelerometer.
     * Values of this matrix are expressed in (rad-sec/m).
     *
     * @param gyroGDependentBiases cross biases introduced by the specific forces
     *                             sensed by the accelerometer to be set.
     * @throws IllegalArgumentException if provided matrix is not 3x3.
     */
    public void setGyroGDependentBiases(final Matrix gyroGDependentBiases) {
<span class="fc bfc" id="L1004" title="All 2 branches covered.">        if (gyroGDependentBiases.getRows() != ACCELEROMETER_COMPONENTS</span>
<span class="fc bfc" id="L1005" title="All 2 branches covered.">                || gyroGDependentBiases.getColumns() != ACCELEROMETER_COMPONENTS) {</span>
<span class="fc" id="L1006">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L1009">        this.gyroGDependentBiases.copyFrom(gyroGDependentBiases);</span>
<span class="fc" id="L1010">    }</span>

    /**
     * Gets accelerometer noise root PSD expressed in (m * s^-1.5).
     * By default it is zero.
     *
     * @return accelerometer noise root PSD.
     */
    public double getAccelerometerNoiseRootPSD() {
<span class="fc" id="L1019">        return accelerometerNoiseRootPSD;</span>
    }

    /**
     * Sets accelerometer noise root PSD expressed in (m * s^-1.5)
     *
     * @param accelerometerNoiseRootPSD accelerometer noise root PSD to be set.
     */
    public void setAccelerometerNoiseRootPSD(final double accelerometerNoiseRootPSD) {
<span class="fc" id="L1028">        this.accelerometerNoiseRootPSD = accelerometerNoiseRootPSD;</span>
<span class="fc" id="L1029">    }</span>

    /**
     * Gets accelerometer noise PSD expressed in (m^2 * s^-3).
     * By default, it is zero.
     *
     * @return accelerometer noise PSD.
     */
    public double getAccelerometerNoisePSD() {
<span class="fc" id="L1038">        return accelerometerNoiseRootPSD * accelerometerNoiseRootPSD;</span>
    }

    /**
     * Sets accelerometer noise PSD expressed in (m^2 * s^-3).
     *
     * @param accelerometerNoisePSD accelerometer noise PSD to be set.
     * @throws IllegalArgumentException if provided value is negative.
     */
    public void setAccelerometerNoisePSD(final double accelerometerNoisePSD) {
<span class="fc bfc" id="L1048" title="All 2 branches covered.">        if (accelerometerNoisePSD &lt; 0.0) {</span>
<span class="fc" id="L1049">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L1052">        accelerometerNoiseRootPSD = Math.sqrt(accelerometerNoisePSD);</span>
<span class="fc" id="L1053">    }</span>

    /**
     * Gets gyro noise root PSD expressed in (rad * s^-0.5).
     * By default, it is zero.
     *
     * @return gyro noise root PSD.
     */
    public double getGyroNoiseRootPSD() {
<span class="fc" id="L1062">        return gyroNoiseRootPSD;</span>
    }

    /**
     * Sets gyro noise root PSD expressed in (rad * s^-0.5).
     *
     * @param gyroNoiseRootPSD gyro noise root PSD to be set.
     */
    public void setGyroNoiseRootPSD(final double gyroNoiseRootPSD) {
<span class="fc" id="L1071">        this.gyroNoiseRootPSD = gyroNoiseRootPSD;</span>
<span class="fc" id="L1072">    }</span>

    /**
     * Gets gyro noise PSD expressed in (rad^2/s).
     * By default, it is zero.
     *
     * @return gyro noise PSD.
     */
    public double getGyroNoisePSD() {
<span class="fc" id="L1081">        return gyroNoiseRootPSD * gyroNoiseRootPSD;</span>
    }

    /**
     * Sets gyro noise PSD expressed in (rad^2/s).
     *
     * @param gyroNoisePSD gyro noise PSD.
     * @throws IllegalArgumentException if provided value is negative.
     */
    public void setGyroNoisePSD(final double gyroNoisePSD) {
<span class="fc bfc" id="L1091" title="All 2 branches covered.">        if (gyroNoisePSD &lt; 0.0) {</span>
<span class="fc" id="L1092">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L1095">        gyroNoiseRootPSD = Math.sqrt(gyroNoisePSD);</span>
<span class="fc" id="L1096">    }</span>

    /**
     * Gets accelerometer quantization level expressed in meters per squared second
     * (m/s^2).
     * By default, it is zero when no quantization is assumed.
     *
     * @return accelerometer quantization level.
     */
    public double getAccelerometerQuantizationLevel() {
<span class="fc" id="L1106">        return accelerometerQuantizationLevel;</span>
    }

    /**
     * Sets accelerometer quantization level expressed in meters per squared second
     * (m/s^2).
     *
     * @param accelerometerQuantizationLevel accelerometer quantization level to be
     *                                       set.
     */
    public void setAccelerometerQuantizationLevel(final double accelerometerQuantizationLevel) {
<span class="fc" id="L1117">        this.accelerometerQuantizationLevel = accelerometerQuantizationLevel;</span>
<span class="fc" id="L1118">    }</span>

    /**
     * Gets accelerometer quantization level.
     * By default, it is zero when no quantization is assumed.
     *
     * @return accelerometer quantization level.
     */
    public Acceleration getAccelerometerQuantizationLevelAsAcceleration() {
<span class="fc" id="L1127">        return new Acceleration(accelerometerQuantizationLevel, AccelerationUnit.METERS_PER_SQUARED_SECOND);</span>
    }

    /**
     * Gets accelerometer quantization level.
     * By default, it is zero when no quantization is assumed.
     *
     * @param result instance where value will be stored.
     */
    public void getAccelerometerQuantizationLevelAsAcceleration(final Acceleration result) {
<span class="fc" id="L1137">        result.setValue(accelerometerQuantizationLevel);</span>
<span class="fc" id="L1138">        result.setUnit(AccelerationUnit.METERS_PER_SQUARED_SECOND);</span>
<span class="fc" id="L1139">    }</span>

    /**
     * Sets accelerometer quantization level.
     *
     * @param accelerometerQuantizationLevel accelerometer quantization level to be set.
     */
    public void setAccelerometerQuantizationLevel(final Acceleration accelerometerQuantizationLevel) {
<span class="fc" id="L1147">        this.accelerometerQuantizationLevel = convertAcceleration(accelerometerQuantizationLevel);</span>
<span class="fc" id="L1148">    }</span>

    /**
     * Gets gyro quantization level expressed in radians per second (rad/s).
     * By default, it is zero when no quantization is assumed.
     *
     * @return gyro quantization level expressed in radians per second.
     */
    public double getGyroQuantizationLevel() {
<span class="fc" id="L1157">        return gyroQuantizationLevel;</span>
    }

    /**
     * Sets gyro quantization level expressed in radians per second (rad/s).
     *
     * @param gyroQuantizationLevel gyro quantization level to be set.
     */
    public void setGyroQuantizationLevel(final double gyroQuantizationLevel) {
<span class="fc" id="L1166">        this.gyroQuantizationLevel = gyroQuantizationLevel;</span>
<span class="fc" id="L1167">    }</span>

    /**
     * Gets gyro quantization level.
     * By default, it is zero when no quantization is assumed.
     *
     * @return gyro quantization level.
     */
    public AngularSpeed getGyroQuantizationLevelAsAngularSpeed() {
<span class="fc" id="L1176">        return new AngularSpeed(gyroQuantizationLevel, AngularSpeedUnit.RADIANS_PER_SECOND);</span>
    }

    /**
     * Gets gyro quantization level.
     * By default, it is zero when no quantization is assumed.
     *
     * @param result instance where value will be stored.
     */
    public void getGyroQuantizationLevelAsAngularSpeed(final AngularSpeed result) {
<span class="fc" id="L1186">        result.setValue(gyroQuantizationLevel);</span>
<span class="fc" id="L1187">        result.setUnit(AngularSpeedUnit.RADIANS_PER_SECOND);</span>
<span class="fc" id="L1188">    }</span>

    /**
     * Sets gyro quantization level.
     *
     * @param gyroQuantizationLevel gyro quantization level.
     */
    public void setGyroQuantizationLevel(final AngularSpeed gyroQuantizationLevel) {
<span class="fc" id="L1196">        this.gyroQuantizationLevel = convertAngularSpeed(gyroQuantizationLevel);</span>
<span class="fc" id="L1197">    }</span>

    /**
     * Copies this instance data into provided instance.
     *
     * @param output destination instance where data will be copied to.
     */
    public void copyTo(final IMUErrors output) {
<span class="fc" id="L1205">        output.copyFrom(this);</span>
<span class="fc" id="L1206">    }</span>

    /**
     * Copies data of provided instance into this instance.
     *
     * @param input instance to copy data from.
     */
    public void copyFrom(final IMUErrors input) {
<span class="fc" id="L1214">        input.getAccelerometerBiases(accelerometerBiases);</span>
<span class="fc" id="L1215">        input.getGyroBiases(gyroBiases);</span>
<span class="fc" id="L1216">        accelerometerScaleFactorAndCrossCouplingErrors.copyFrom(input.accelerometerScaleFactorAndCrossCouplingErrors);</span>
<span class="fc" id="L1217">        gyroScaleFactorAndCrossCouplingErrors.copyFrom(input.gyroScaleFactorAndCrossCouplingErrors);</span>
<span class="fc" id="L1218">        gyroGDependentBiases.copyFrom(input.gyroGDependentBiases);</span>
<span class="fc" id="L1219">        accelerometerNoiseRootPSD = input.accelerometerNoiseRootPSD;</span>
<span class="fc" id="L1220">        gyroNoiseRootPSD = input.gyroNoiseRootPSD;</span>
<span class="fc" id="L1221">        accelerometerQuantizationLevel = input.accelerometerQuantizationLevel;</span>
<span class="fc" id="L1222">        gyroQuantizationLevel = input.gyroQuantizationLevel;</span>
<span class="fc" id="L1223">    }</span>

    /**
     * Computes and returns hash code for this instance. Hash codes are almost unique
     * values that are useful for fast classification and storage of objects in
     * collections.
     *
     * @return Hash code.
     */
    @Override
    public int hashCode() {
<span class="fc" id="L1234">        return Objects.hash(accelerometerScaleFactorAndCrossCouplingErrors, gyroScaleFactorAndCrossCouplingErrors,</span>
<span class="fc" id="L1235">                gyroGDependentBiases, accelerometerNoiseRootPSD, gyroNoiseRootPSD, accelerometerQuantizationLevel,</span>
<span class="fc" id="L1236">                gyroQuantizationLevel, Arrays.hashCode(accelerometerBiases), Arrays.hashCode(gyroBiases));</span>
    }

    /**
     * Checks if provided object is an IMUErrors instance having exactly the same
     * contents as this instance.
     *
     * @param o Object to be compared.
     * @return true if both objects are considered to be equal, false otherwise.
     */
    @Override
    public boolean equals(Object o) {
<span class="fc bfc" id="L1248" title="All 2 branches covered.">        if (this == o) {</span>
<span class="fc" id="L1249">            return true;</span>
        }
<span class="pc bpc" id="L1251" title="2 of 4 branches missed.">        if (o == null || getClass() != o.getClass()) {</span>
<span class="nc" id="L1252">            return false;</span>
        }

<span class="fc" id="L1255">        final var imuErrors = (IMUErrors) o;</span>
<span class="fc bfc" id="L1256" title="All 2 branches covered.">        return Double.compare(imuErrors.accelerometerNoiseRootPSD, accelerometerNoiseRootPSD) == 0 &amp;&amp;</span>
<span class="pc bpc" id="L1257" title="1 of 2 branches missed.">                Double.compare(imuErrors.gyroNoiseRootPSD, gyroNoiseRootPSD) == 0 &amp;&amp;</span>
<span class="pc bpc" id="L1258" title="1 of 2 branches missed.">                Double.compare(imuErrors.accelerometerQuantizationLevel, accelerometerQuantizationLevel) == 0 &amp;&amp;</span>
<span class="pc bpc" id="L1259" title="1 of 2 branches missed.">                Double.compare(imuErrors.gyroQuantizationLevel, gyroQuantizationLevel) == 0 &amp;&amp;</span>
<span class="pc bpc" id="L1260" title="1 of 2 branches missed.">                Arrays.equals(accelerometerBiases, imuErrors.accelerometerBiases) &amp;&amp;</span>
<span class="pc bpc" id="L1261" title="1 of 2 branches missed.">                Arrays.equals(gyroBiases, imuErrors.gyroBiases) &amp;&amp;</span>
<span class="pc bpc" id="L1262" title="1 of 2 branches missed.">                accelerometerScaleFactorAndCrossCouplingErrors.equals(</span>
                        imuErrors.accelerometerScaleFactorAndCrossCouplingErrors) &amp;&amp;
<span class="pc bpc" id="L1264" title="1 of 2 branches missed.">                gyroScaleFactorAndCrossCouplingErrors.equals(imuErrors.gyroScaleFactorAndCrossCouplingErrors) &amp;&amp;</span>
<span class="pc bpc" id="L1265" title="1 of 2 branches missed.">                gyroGDependentBiases.equals(imuErrors.gyroGDependentBiases);</span>
    }

    /**
     * Makes a copy of this instance.
     *
     * @return a copy of this instance.
     * @throws CloneNotSupportedException if clone fails for some reason.
     */
    @Override
    protected Object clone() throws CloneNotSupportedException {
<span class="fc" id="L1276">        final var result = (IMUErrors) super.clone();</span>
<span class="fc" id="L1277">        copyTo(result);</span>
<span class="fc" id="L1278">        return result;</span>
    }

    /**
     * Converts acceleration instance to meters per squared second (m/s^2).
     *
     * @param acceleration instance to be converted.
     * @return converted value.
     */
    private double convertAcceleration(final Acceleration acceleration) {
<span class="fc" id="L1288">        return AccelerationConverter.convert(acceleration.getValue().doubleValue(), acceleration.getUnit(),</span>
                AccelerationUnit.METERS_PER_SQUARED_SECOND);
    }

    /**
     * Converts angular speed instance to radians per second (rad/s).
     *
     * @param angularSpeed instance ot be converted.
     * @return converted value.
     */
    private double convertAngularSpeed(final AngularSpeed angularSpeed) {
<span class="fc" id="L1299">        return AngularSpeedConverter.convert(angularSpeed.getValue().doubleValue(), angularSpeed.getUnit(),</span>
                AngularSpeedUnit.RADIANS_PER_SECOND);
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>